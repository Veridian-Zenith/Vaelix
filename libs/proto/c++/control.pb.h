// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_control_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_control_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_control_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_control_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_control_2eproto;
namespace vaelix {
namespace control {
class BrowserMetrics;
struct BrowserMetricsDefaultTypeInternal;
extern BrowserMetricsDefaultTypeInternal _BrowserMetrics_default_instance_;
class BrowserShutdownRequest;
struct BrowserShutdownRequestDefaultTypeInternal;
extern BrowserShutdownRequestDefaultTypeInternal _BrowserShutdownRequest_default_instance_;
class BrowserShutdownResponse;
struct BrowserShutdownResponseDefaultTypeInternal;
extern BrowserShutdownResponseDefaultTypeInternal _BrowserShutdownResponse_default_instance_;
class GetBrowserMetricsRequest;
struct GetBrowserMetricsRequestDefaultTypeInternal;
extern GetBrowserMetricsRequestDefaultTypeInternal _GetBrowserMetricsRequest_default_instance_;
class GetBrowserMetricsResponse;
struct GetBrowserMetricsResponseDefaultTypeInternal;
extern GetBrowserMetricsResponseDefaultTypeInternal _GetBrowserMetricsResponse_default_instance_;
class GetTabInfoRequest;
struct GetTabInfoRequestDefaultTypeInternal;
extern GetTabInfoRequestDefaultTypeInternal _GetTabInfoRequest_default_instance_;
class GetTabInfoResponse;
struct GetTabInfoResponseDefaultTypeInternal;
extern GetTabInfoResponseDefaultTypeInternal _GetTabInfoResponse_default_instance_;
class NavigateRequest;
struct NavigateRequestDefaultTypeInternal;
extern NavigateRequestDefaultTypeInternal _NavigateRequest_default_instance_;
class NavigateResponse;
struct NavigateResponseDefaultTypeInternal;
extern NavigateResponseDefaultTypeInternal _NavigateResponse_default_instance_;
class StartTabRequest;
struct StartTabRequestDefaultTypeInternal;
extern StartTabRequestDefaultTypeInternal _StartTabRequest_default_instance_;
class StartTabRequest_HeadersEntry_DoNotUse;
struct StartTabRequest_HeadersEntry_DoNotUseDefaultTypeInternal;
extern StartTabRequest_HeadersEntry_DoNotUseDefaultTypeInternal _StartTabRequest_HeadersEntry_DoNotUse_default_instance_;
class StartTabResponse;
struct StartTabResponseDefaultTypeInternal;
extern StartTabResponseDefaultTypeInternal _StartTabResponse_default_instance_;
class StopTabRequest;
struct StopTabRequestDefaultTypeInternal;
extern StopTabRequestDefaultTypeInternal _StopTabRequest_default_instance_;
class StopTabResponse;
struct StopTabResponseDefaultTypeInternal;
extern StopTabResponseDefaultTypeInternal _StopTabResponse_default_instance_;
class TabClosedEvent;
struct TabClosedEventDefaultTypeInternal;
extern TabClosedEventDefaultTypeInternal _TabClosedEvent_default_instance_;
class TabEvent;
struct TabEventDefaultTypeInternal;
extern TabEventDefaultTypeInternal _TabEvent_default_instance_;
class TabInfo;
struct TabInfoDefaultTypeInternal;
extern TabInfoDefaultTypeInternal _TabInfo_default_instance_;
class TabUpdatedEvent;
struct TabUpdatedEventDefaultTypeInternal;
extern TabUpdatedEventDefaultTypeInternal _TabUpdatedEvent_default_instance_;
}  // namespace control
}  // namespace vaelix
PROTOBUF_NAMESPACE_OPEN
template<> ::vaelix::control::BrowserMetrics* Arena::CreateMaybeMessage<::vaelix::control::BrowserMetrics>(Arena*);
template<> ::vaelix::control::BrowserShutdownRequest* Arena::CreateMaybeMessage<::vaelix::control::BrowserShutdownRequest>(Arena*);
template<> ::vaelix::control::BrowserShutdownResponse* Arena::CreateMaybeMessage<::vaelix::control::BrowserShutdownResponse>(Arena*);
template<> ::vaelix::control::GetBrowserMetricsRequest* Arena::CreateMaybeMessage<::vaelix::control::GetBrowserMetricsRequest>(Arena*);
template<> ::vaelix::control::GetBrowserMetricsResponse* Arena::CreateMaybeMessage<::vaelix::control::GetBrowserMetricsResponse>(Arena*);
template<> ::vaelix::control::GetTabInfoRequest* Arena::CreateMaybeMessage<::vaelix::control::GetTabInfoRequest>(Arena*);
template<> ::vaelix::control::GetTabInfoResponse* Arena::CreateMaybeMessage<::vaelix::control::GetTabInfoResponse>(Arena*);
template<> ::vaelix::control::NavigateRequest* Arena::CreateMaybeMessage<::vaelix::control::NavigateRequest>(Arena*);
template<> ::vaelix::control::NavigateResponse* Arena::CreateMaybeMessage<::vaelix::control::NavigateResponse>(Arena*);
template<> ::vaelix::control::StartTabRequest* Arena::CreateMaybeMessage<::vaelix::control::StartTabRequest>(Arena*);
template<> ::vaelix::control::StartTabRequest_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::control::StartTabRequest_HeadersEntry_DoNotUse>(Arena*);
template<> ::vaelix::control::StartTabResponse* Arena::CreateMaybeMessage<::vaelix::control::StartTabResponse>(Arena*);
template<> ::vaelix::control::StopTabRequest* Arena::CreateMaybeMessage<::vaelix::control::StopTabRequest>(Arena*);
template<> ::vaelix::control::StopTabResponse* Arena::CreateMaybeMessage<::vaelix::control::StopTabResponse>(Arena*);
template<> ::vaelix::control::TabClosedEvent* Arena::CreateMaybeMessage<::vaelix::control::TabClosedEvent>(Arena*);
template<> ::vaelix::control::TabEvent* Arena::CreateMaybeMessage<::vaelix::control::TabEvent>(Arena*);
template<> ::vaelix::control::TabInfo* Arena::CreateMaybeMessage<::vaelix::control::TabInfo>(Arena*);
template<> ::vaelix::control::TabUpdatedEvent* Arena::CreateMaybeMessage<::vaelix::control::TabUpdatedEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vaelix {
namespace control {

// ===================================================================

class TabInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.TabInfo) */ {
 public:
  inline TabInfo() : TabInfo(nullptr) {}
  ~TabInfo() override;
  explicit constexpr TabInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabInfo(const TabInfo& from);
  TabInfo(TabInfo&& from) noexcept
    : TabInfo() {
    *this = ::std::move(from);
  }

  inline TabInfo& operator=(const TabInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabInfo& operator=(TabInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabInfo* internal_default_instance() {
    return reinterpret_cast<const TabInfo*>(
               &_TabInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TabInfo& a, TabInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TabInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.TabInfo";
  }
  protected:
  explicit TabInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kTitleFieldNumber = 3,
    kFaviconDataFieldNumber = 7,
    kContentTypeFieldNumber = 8,
    kTabIdFieldNumber = 1,
    kIsLoadingFieldNumber = 4,
    kCanGoBackFieldNumber = 5,
    kCanGoForwardFieldNumber = 6,
  };
  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // bytes favicon_data = 7;
  void clear_favicon_data();
  const std::string& favicon_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_favicon_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_favicon_data();
  PROTOBUF_NODISCARD std::string* release_favicon_data();
  void set_allocated_favicon_data(std::string* favicon_data);
  private:
  const std::string& _internal_favicon_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon_data(const std::string& value);
  std::string* _internal_mutable_favicon_data();
  public:

  // string content_type = 8;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool is_loading = 4;
  void clear_is_loading();
  bool is_loading() const;
  void set_is_loading(bool value);
  private:
  bool _internal_is_loading() const;
  void _internal_set_is_loading(bool value);
  public:

  // bool can_go_back = 5;
  void clear_can_go_back();
  bool can_go_back() const;
  void set_can_go_back(bool value);
  private:
  bool _internal_can_go_back() const;
  void _internal_set_can_go_back(bool value);
  public:

  // bool can_go_forward = 6;
  void clear_can_go_forward();
  bool can_go_forward() const;
  void set_can_go_forward(bool value);
  private:
  bool _internal_can_go_forward() const;
  void _internal_set_can_go_forward(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.TabInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
  int32_t tab_id_;
  bool is_loading_;
  bool can_go_back_;
  bool can_go_forward_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class StartTabRequest_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StartTabRequest_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StartTabRequest_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StartTabRequest_HeadersEntry_DoNotUse();
  explicit constexpr StartTabRequest_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StartTabRequest_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StartTabRequest_HeadersEntry_DoNotUse& other);
  static const StartTabRequest_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StartTabRequest_HeadersEntry_DoNotUse*>(&_StartTabRequest_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.control.StartTabRequest.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.control.StartTabRequest.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class StartTabRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.StartTabRequest) */ {
 public:
  inline StartTabRequest() : StartTabRequest(nullptr) {}
  ~StartTabRequest() override;
  explicit constexpr StartTabRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartTabRequest(const StartTabRequest& from);
  StartTabRequest(StartTabRequest&& from) noexcept
    : StartTabRequest() {
    *this = ::std::move(from);
  }

  inline StartTabRequest& operator=(const StartTabRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartTabRequest& operator=(StartTabRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartTabRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartTabRequest* internal_default_instance() {
    return reinterpret_cast<const StartTabRequest*>(
               &_StartTabRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StartTabRequest& a, StartTabRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartTabRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartTabRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartTabRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartTabRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartTabRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartTabRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartTabRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.StartTabRequest";
  }
  protected:
  explicit StartTabRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 3,
    kUrlFieldNumber = 1,
    kUserAgentFieldNumber = 5,
    kTabIdFieldNumber = 2,
    kPrivateModeFieldNumber = 4,
  };
  // map<string, string> headers = 3;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string user_agent = 5;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool private_mode = 4;
  void clear_private_mode();
  bool private_mode() const;
  void set_private_mode(bool value);
  private:
  bool _internal_private_mode() const;
  void _internal_set_private_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.StartTabRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StartTabRequest_HeadersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
  int32_t tab_id_;
  bool private_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class StartTabResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.StartTabResponse) */ {
 public:
  inline StartTabResponse() : StartTabResponse(nullptr) {}
  ~StartTabResponse() override;
  explicit constexpr StartTabResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartTabResponse(const StartTabResponse& from);
  StartTabResponse(StartTabResponse&& from) noexcept
    : StartTabResponse() {
    *this = ::std::move(from);
  }

  inline StartTabResponse& operator=(const StartTabResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartTabResponse& operator=(StartTabResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartTabResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartTabResponse* internal_default_instance() {
    return reinterpret_cast<const StartTabResponse*>(
               &_StartTabResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartTabResponse& a, StartTabResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartTabResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartTabResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartTabResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartTabResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartTabResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartTabResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartTabResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.StartTabResponse";
  }
  protected:
  explicit StartTabResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kInitialFaviconFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bytes initial_favicon = 3;
  void clear_initial_favicon();
  const std::string& initial_favicon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_favicon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_favicon();
  PROTOBUF_NODISCARD std::string* release_initial_favicon();
  void set_allocated_initial_favicon(std::string* initial_favicon);
  private:
  const std::string& _internal_initial_favicon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_favicon(const std::string& value);
  std::string* _internal_mutable_initial_favicon();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.StartTabResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_favicon_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class StopTabRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.StopTabRequest) */ {
 public:
  inline StopTabRequest() : StopTabRequest(nullptr) {}
  ~StopTabRequest() override;
  explicit constexpr StopTabRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopTabRequest(const StopTabRequest& from);
  StopTabRequest(StopTabRequest&& from) noexcept
    : StopTabRequest() {
    *this = ::std::move(from);
  }

  inline StopTabRequest& operator=(const StopTabRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTabRequest& operator=(StopTabRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopTabRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopTabRequest* internal_default_instance() {
    return reinterpret_cast<const StopTabRequest*>(
               &_StopTabRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StopTabRequest& a, StopTabRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTabRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopTabRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopTabRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopTabRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopTabRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopTabRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTabRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.StopTabRequest";
  }
  protected:
  explicit StopTabRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabIdFieldNumber = 1,
    kForceCloseFieldNumber = 2,
  };
  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool force_close = 2;
  void clear_force_close();
  bool force_close() const;
  void set_force_close(bool value);
  private:
  bool _internal_force_close() const;
  void _internal_set_force_close(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.StopTabRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t tab_id_;
  bool force_close_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class StopTabResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.StopTabResponse) */ {
 public:
  inline StopTabResponse() : StopTabResponse(nullptr) {}
  ~StopTabResponse() override;
  explicit constexpr StopTabResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopTabResponse(const StopTabResponse& from);
  StopTabResponse(StopTabResponse&& from) noexcept
    : StopTabResponse() {
    *this = ::std::move(from);
  }

  inline StopTabResponse& operator=(const StopTabResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTabResponse& operator=(StopTabResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopTabResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopTabResponse* internal_default_instance() {
    return reinterpret_cast<const StopTabResponse*>(
               &_StopTabResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StopTabResponse& a, StopTabResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTabResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopTabResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopTabResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopTabResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopTabResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopTabResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTabResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.StopTabResponse";
  }
  protected:
  explicit StopTabResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.StopTabResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class NavigateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.NavigateRequest) */ {
 public:
  inline NavigateRequest() : NavigateRequest(nullptr) {}
  ~NavigateRequest() override;
  explicit constexpr NavigateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateRequest(const NavigateRequest& from);
  NavigateRequest(NavigateRequest&& from) noexcept
    : NavigateRequest() {
    *this = ::std::move(from);
  }

  inline NavigateRequest& operator=(const NavigateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateRequest& operator=(NavigateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateRequest* internal_default_instance() {
    return reinterpret_cast<const NavigateRequest*>(
               &_NavigateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NavigateRequest& a, NavigateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NavigateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.NavigateRequest";
  }
  protected:
  explicit NavigateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kTabIdFieldNumber = 1,
    kForceReloadFieldNumber = 3,
  };
  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool force_reload = 3;
  void clear_force_reload();
  bool force_reload() const;
  void set_force_reload(bool value);
  private:
  bool _internal_force_reload() const;
  void _internal_set_force_reload(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.NavigateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int32_t tab_id_;
  bool force_reload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class NavigateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.NavigateResponse) */ {
 public:
  inline NavigateResponse() : NavigateResponse(nullptr) {}
  ~NavigateResponse() override;
  explicit constexpr NavigateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateResponse(const NavigateResponse& from);
  NavigateResponse(NavigateResponse&& from) noexcept
    : NavigateResponse() {
    *this = ::std::move(from);
  }

  inline NavigateResponse& operator=(const NavigateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateResponse& operator=(NavigateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateResponse* internal_default_instance() {
    return reinterpret_cast<const NavigateResponse*>(
               &_NavigateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NavigateResponse& a, NavigateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NavigateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.NavigateResponse";
  }
  protected:
  explicit NavigateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kRedirectedUrlFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string redirected_url = 3;
  void clear_redirected_url();
  const std::string& redirected_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redirected_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redirected_url();
  PROTOBUF_NODISCARD std::string* release_redirected_url();
  void set_allocated_redirected_url(std::string* redirected_url);
  private:
  const std::string& _internal_redirected_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redirected_url(const std::string& value);
  std::string* _internal_mutable_redirected_url();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.NavigateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redirected_url_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class GetTabInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.GetTabInfoRequest) */ {
 public:
  inline GetTabInfoRequest() : GetTabInfoRequest(nullptr) {}
  ~GetTabInfoRequest() override;
  explicit constexpr GetTabInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabInfoRequest(const GetTabInfoRequest& from);
  GetTabInfoRequest(GetTabInfoRequest&& from) noexcept
    : GetTabInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetTabInfoRequest& operator=(const GetTabInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabInfoRequest& operator=(GetTabInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetTabInfoRequest*>(
               &_GetTabInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetTabInfoRequest& a, GetTabInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTabInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.GetTabInfoRequest";
  }
  protected:
  explicit GetTabInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabIdFieldNumber = 1,
  };
  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.GetTabInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t tab_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class GetTabInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.GetTabInfoResponse) */ {
 public:
  inline GetTabInfoResponse() : GetTabInfoResponse(nullptr) {}
  ~GetTabInfoResponse() override;
  explicit constexpr GetTabInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabInfoResponse(const GetTabInfoResponse& from);
  GetTabInfoResponse(GetTabInfoResponse&& from) noexcept
    : GetTabInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetTabInfoResponse& operator=(const GetTabInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabInfoResponse& operator=(GetTabInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetTabInfoResponse*>(
               &_GetTabInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTabInfoResponse& a, GetTabInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTabInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.GetTabInfoResponse";
  }
  protected:
  explicit GetTabInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kTabInfoFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .vaelix.control.TabInfo tab_info = 1;
  bool has_tab_info() const;
  private:
  bool _internal_has_tab_info() const;
  public:
  void clear_tab_info();
  const ::vaelix::control::TabInfo& tab_info() const;
  PROTOBUF_NODISCARD ::vaelix::control::TabInfo* release_tab_info();
  ::vaelix::control::TabInfo* mutable_tab_info();
  void set_allocated_tab_info(::vaelix::control::TabInfo* tab_info);
  private:
  const ::vaelix::control::TabInfo& _internal_tab_info() const;
  ::vaelix::control::TabInfo* _internal_mutable_tab_info();
  public:
  void unsafe_arena_set_allocated_tab_info(
      ::vaelix::control::TabInfo* tab_info);
  ::vaelix::control::TabInfo* unsafe_arena_release_tab_info();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.GetTabInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::vaelix::control::TabInfo* tab_info_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class TabClosedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.TabClosedEvent) */ {
 public:
  inline TabClosedEvent() : TabClosedEvent(nullptr) {}
  ~TabClosedEvent() override;
  explicit constexpr TabClosedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabClosedEvent(const TabClosedEvent& from);
  TabClosedEvent(TabClosedEvent&& from) noexcept
    : TabClosedEvent() {
    *this = ::std::move(from);
  }

  inline TabClosedEvent& operator=(const TabClosedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabClosedEvent& operator=(TabClosedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabClosedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabClosedEvent* internal_default_instance() {
    return reinterpret_cast<const TabClosedEvent*>(
               &_TabClosedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TabClosedEvent& a, TabClosedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TabClosedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabClosedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabClosedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabClosedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabClosedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabClosedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabClosedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.TabClosedEvent";
  }
  protected:
  explicit TabClosedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabIdFieldNumber = 1,
    kCloseReasonFieldNumber = 2,
  };
  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // int32 close_reason = 2;
  void clear_close_reason();
  int32_t close_reason() const;
  void set_close_reason(int32_t value);
  private:
  int32_t _internal_close_reason() const;
  void _internal_set_close_reason(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.TabClosedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t tab_id_;
  int32_t close_reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class TabUpdatedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.TabUpdatedEvent) */ {
 public:
  inline TabUpdatedEvent() : TabUpdatedEvent(nullptr) {}
  ~TabUpdatedEvent() override;
  explicit constexpr TabUpdatedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabUpdatedEvent(const TabUpdatedEvent& from);
  TabUpdatedEvent(TabUpdatedEvent&& from) noexcept
    : TabUpdatedEvent() {
    *this = ::std::move(from);
  }

  inline TabUpdatedEvent& operator=(const TabUpdatedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabUpdatedEvent& operator=(TabUpdatedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabUpdatedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabUpdatedEvent* internal_default_instance() {
    return reinterpret_cast<const TabUpdatedEvent*>(
               &_TabUpdatedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TabUpdatedEvent& a, TabUpdatedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TabUpdatedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabUpdatedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabUpdatedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabUpdatedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabUpdatedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabUpdatedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabUpdatedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.TabUpdatedEvent";
  }
  protected:
  explicit TabUpdatedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateTypeFieldNumber = 3,
    kTabInfoFieldNumber = 2,
    kTabIdFieldNumber = 1,
  };
  // string update_type = 3;
  void clear_update_type();
  const std::string& update_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_type();
  PROTOBUF_NODISCARD std::string* release_update_type();
  void set_allocated_update_type(std::string* update_type);
  private:
  const std::string& _internal_update_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_type(const std::string& value);
  std::string* _internal_mutable_update_type();
  public:

  // .vaelix.control.TabInfo tab_info = 2;
  bool has_tab_info() const;
  private:
  bool _internal_has_tab_info() const;
  public:
  void clear_tab_info();
  const ::vaelix::control::TabInfo& tab_info() const;
  PROTOBUF_NODISCARD ::vaelix::control::TabInfo* release_tab_info();
  ::vaelix::control::TabInfo* mutable_tab_info();
  void set_allocated_tab_info(::vaelix::control::TabInfo* tab_info);
  private:
  const ::vaelix::control::TabInfo& _internal_tab_info() const;
  ::vaelix::control::TabInfo* _internal_mutable_tab_info();
  public:
  void unsafe_arena_set_allocated_tab_info(
      ::vaelix::control::TabInfo* tab_info);
  ::vaelix::control::TabInfo* unsafe_arena_release_tab_info();

  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.TabUpdatedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_type_;
  ::vaelix::control::TabInfo* tab_info_;
  int32_t tab_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class BrowserShutdownRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.BrowserShutdownRequest) */ {
 public:
  inline BrowserShutdownRequest() : BrowserShutdownRequest(nullptr) {}
  ~BrowserShutdownRequest() override;
  explicit constexpr BrowserShutdownRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserShutdownRequest(const BrowserShutdownRequest& from);
  BrowserShutdownRequest(BrowserShutdownRequest&& from) noexcept
    : BrowserShutdownRequest() {
    *this = ::std::move(from);
  }

  inline BrowserShutdownRequest& operator=(const BrowserShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserShutdownRequest& operator=(BrowserShutdownRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrowserShutdownRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const BrowserShutdownRequest*>(
               &_BrowserShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BrowserShutdownRequest& a, BrowserShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserShutdownRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserShutdownRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserShutdownRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserShutdownRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BrowserShutdownRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BrowserShutdownRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrowserShutdownRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.BrowserShutdownRequest";
  }
  protected:
  explicit BrowserShutdownRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kForceKillFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool force_kill = 1;
  void clear_force_kill();
  bool force_kill() const;
  void set_force_kill(bool value);
  private:
  bool _internal_force_kill() const;
  void _internal_set_force_kill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.BrowserShutdownRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool force_kill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class BrowserShutdownResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.BrowserShutdownResponse) */ {
 public:
  inline BrowserShutdownResponse() : BrowserShutdownResponse(nullptr) {}
  ~BrowserShutdownResponse() override;
  explicit constexpr BrowserShutdownResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserShutdownResponse(const BrowserShutdownResponse& from);
  BrowserShutdownResponse(BrowserShutdownResponse&& from) noexcept
    : BrowserShutdownResponse() {
    *this = ::std::move(from);
  }

  inline BrowserShutdownResponse& operator=(const BrowserShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserShutdownResponse& operator=(BrowserShutdownResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrowserShutdownResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const BrowserShutdownResponse*>(
               &_BrowserShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BrowserShutdownResponse& a, BrowserShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserShutdownResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserShutdownResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserShutdownResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserShutdownResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BrowserShutdownResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BrowserShutdownResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrowserShutdownResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.BrowserShutdownResponse";
  }
  protected:
  explicit BrowserShutdownResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemainingTabsFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kShutdownDelayMsFieldNumber = 3,
  };
  // repeated int32 remaining_tabs = 2;
  int remaining_tabs_size() const;
  private:
  int _internal_remaining_tabs_size() const;
  public:
  void clear_remaining_tabs();
  private:
  int32_t _internal_remaining_tabs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_remaining_tabs() const;
  void _internal_add_remaining_tabs(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_remaining_tabs();
  public:
  int32_t remaining_tabs(int index) const;
  void set_remaining_tabs(int index, int32_t value);
  void add_remaining_tabs(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      remaining_tabs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_remaining_tabs();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 shutdown_delay_ms = 3;
  void clear_shutdown_delay_ms();
  int32_t shutdown_delay_ms() const;
  void set_shutdown_delay_ms(int32_t value);
  private:
  int32_t _internal_shutdown_delay_ms() const;
  void _internal_set_shutdown_delay_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.BrowserShutdownResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > remaining_tabs_;
  mutable std::atomic<int> _remaining_tabs_cached_byte_size_;
  bool success_;
  int32_t shutdown_delay_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class BrowserMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.BrowserMetrics) */ {
 public:
  inline BrowserMetrics() : BrowserMetrics(nullptr) {}
  ~BrowserMetrics() override;
  explicit constexpr BrowserMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserMetrics(const BrowserMetrics& from);
  BrowserMetrics(BrowserMetrics&& from) noexcept
    : BrowserMetrics() {
    *this = ::std::move(from);
  }

  inline BrowserMetrics& operator=(const BrowserMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserMetrics& operator=(BrowserMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrowserMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserMetrics* internal_default_instance() {
    return reinterpret_cast<const BrowserMetrics*>(
               &_BrowserMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BrowserMetrics& a, BrowserMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BrowserMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BrowserMetrics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrowserMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.BrowserMetrics";
  }
  protected:
  explicit BrowserMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryUsageMbFieldNumber = 2,
    kCpuUsagePercentFieldNumber = 3,
    kNetworkBytesReceivedFieldNumber = 4,
    kNetworkBytesSentFieldNumber = 5,
    kRenderTimeMsFieldNumber = 6,
    kActiveTabsFieldNumber = 1,
  };
  // int64 memory_usage_mb = 2;
  void clear_memory_usage_mb();
  int64_t memory_usage_mb() const;
  void set_memory_usage_mb(int64_t value);
  private:
  int64_t _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(int64_t value);
  public:

  // double cpu_usage_percent = 3;
  void clear_cpu_usage_percent();
  double cpu_usage_percent() const;
  void set_cpu_usage_percent(double value);
  private:
  double _internal_cpu_usage_percent() const;
  void _internal_set_cpu_usage_percent(double value);
  public:

  // int64 network_bytes_received = 4;
  void clear_network_bytes_received();
  int64_t network_bytes_received() const;
  void set_network_bytes_received(int64_t value);
  private:
  int64_t _internal_network_bytes_received() const;
  void _internal_set_network_bytes_received(int64_t value);
  public:

  // int64 network_bytes_sent = 5;
  void clear_network_bytes_sent();
  int64_t network_bytes_sent() const;
  void set_network_bytes_sent(int64_t value);
  private:
  int64_t _internal_network_bytes_sent() const;
  void _internal_set_network_bytes_sent(int64_t value);
  public:

  // double render_time_ms = 6;
  void clear_render_time_ms();
  double render_time_ms() const;
  void set_render_time_ms(double value);
  private:
  double _internal_render_time_ms() const;
  void _internal_set_render_time_ms(double value);
  public:

  // int32 active_tabs = 1;
  void clear_active_tabs();
  int32_t active_tabs() const;
  void set_active_tabs(int32_t value);
  private:
  int32_t _internal_active_tabs() const;
  void _internal_set_active_tabs(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.BrowserMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t memory_usage_mb_;
  double cpu_usage_percent_;
  int64_t network_bytes_received_;
  int64_t network_bytes_sent_;
  double render_time_ms_;
  int32_t active_tabs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class GetBrowserMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.GetBrowserMetricsRequest) */ {
 public:
  inline GetBrowserMetricsRequest() : GetBrowserMetricsRequest(nullptr) {}
  ~GetBrowserMetricsRequest() override;
  explicit constexpr GetBrowserMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBrowserMetricsRequest(const GetBrowserMetricsRequest& from);
  GetBrowserMetricsRequest(GetBrowserMetricsRequest&& from) noexcept
    : GetBrowserMetricsRequest() {
    *this = ::std::move(from);
  }

  inline GetBrowserMetricsRequest& operator=(const GetBrowserMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBrowserMetricsRequest& operator=(GetBrowserMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBrowserMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBrowserMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const GetBrowserMetricsRequest*>(
               &_GetBrowserMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetBrowserMetricsRequest& a, GetBrowserMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBrowserMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBrowserMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBrowserMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBrowserMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBrowserMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBrowserMetricsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBrowserMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.GetBrowserMetricsRequest";
  }
  protected:
  explicit GetBrowserMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeDetailedStatsFieldNumber = 1,
  };
  // bool include_detailed_stats = 1;
  void clear_include_detailed_stats();
  bool include_detailed_stats() const;
  void set_include_detailed_stats(bool value);
  private:
  bool _internal_include_detailed_stats() const;
  void _internal_set_include_detailed_stats(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.GetBrowserMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool include_detailed_stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class GetBrowserMetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.GetBrowserMetricsResponse) */ {
 public:
  inline GetBrowserMetricsResponse() : GetBrowserMetricsResponse(nullptr) {}
  ~GetBrowserMetricsResponse() override;
  explicit constexpr GetBrowserMetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBrowserMetricsResponse(const GetBrowserMetricsResponse& from);
  GetBrowserMetricsResponse(GetBrowserMetricsResponse&& from) noexcept
    : GetBrowserMetricsResponse() {
    *this = ::std::move(from);
  }

  inline GetBrowserMetricsResponse& operator=(const GetBrowserMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBrowserMetricsResponse& operator=(GetBrowserMetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBrowserMetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBrowserMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const GetBrowserMetricsResponse*>(
               &_GetBrowserMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetBrowserMetricsResponse& a, GetBrowserMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBrowserMetricsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBrowserMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBrowserMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBrowserMetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBrowserMetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBrowserMetricsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBrowserMetricsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.GetBrowserMetricsResponse";
  }
  protected:
  explicit GetBrowserMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 3,
    kMetricsFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string timestamp = 3;
  void clear_timestamp();
  const std::string& timestamp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timestamp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);
  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(const std::string& value);
  std::string* _internal_mutable_timestamp();
  public:

  // .vaelix.control.BrowserMetrics metrics = 1;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::vaelix::control::BrowserMetrics& metrics() const;
  PROTOBUF_NODISCARD ::vaelix::control::BrowserMetrics* release_metrics();
  ::vaelix::control::BrowserMetrics* mutable_metrics();
  void set_allocated_metrics(::vaelix::control::BrowserMetrics* metrics);
  private:
  const ::vaelix::control::BrowserMetrics& _internal_metrics() const;
  ::vaelix::control::BrowserMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::vaelix::control::BrowserMetrics* metrics);
  ::vaelix::control::BrowserMetrics* unsafe_arena_release_metrics();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.control.GetBrowserMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  ::vaelix::control::BrowserMetrics* metrics_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class TabEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.control.TabEvent) */ {
 public:
  inline TabEvent() : TabEvent(nullptr) {}
  ~TabEvent() override;
  explicit constexpr TabEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabEvent(const TabEvent& from);
  TabEvent(TabEvent&& from) noexcept
    : TabEvent() {
    *this = ::std::move(from);
  }

  inline TabEvent& operator=(const TabEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabEvent& operator=(TabEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kClosed = 1,
    kUpdated = 2,
    kBrowserEvent = 3,
    kErrorEvent = 4,
    kPerformanceMetric = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const TabEvent* internal_default_instance() {
    return reinterpret_cast<const TabEvent*>(
               &_TabEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TabEvent& a, TabEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TabEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.control.TabEvent";
  }
  protected:
  explicit TabEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosedFieldNumber = 1,
    kUpdatedFieldNumber = 2,
    kBrowserEventFieldNumber = 3,
    kErrorEventFieldNumber = 4,
    kPerformanceMetricFieldNumber = 5,
  };
  // .vaelix.control.TabClosedEvent closed = 1;
  bool has_closed() const;
  private:
  bool _internal_has_closed() const;
  public:
  void clear_closed();
  const ::vaelix::control::TabClosedEvent& closed() const;
  PROTOBUF_NODISCARD ::vaelix::control::TabClosedEvent* release_closed();
  ::vaelix::control::TabClosedEvent* mutable_closed();
  void set_allocated_closed(::vaelix::control::TabClosedEvent* closed);
  private:
  const ::vaelix::control::TabClosedEvent& _internal_closed() const;
  ::vaelix::control::TabClosedEvent* _internal_mutable_closed();
  public:
  void unsafe_arena_set_allocated_closed(
      ::vaelix::control::TabClosedEvent* closed);
  ::vaelix::control::TabClosedEvent* unsafe_arena_release_closed();

  // .vaelix.control.TabUpdatedEvent updated = 2;
  bool has_updated() const;
  private:
  bool _internal_has_updated() const;
  public:
  void clear_updated();
  const ::vaelix::control::TabUpdatedEvent& updated() const;
  PROTOBUF_NODISCARD ::vaelix::control::TabUpdatedEvent* release_updated();
  ::vaelix::control::TabUpdatedEvent* mutable_updated();
  void set_allocated_updated(::vaelix::control::TabUpdatedEvent* updated);
  private:
  const ::vaelix::control::TabUpdatedEvent& _internal_updated() const;
  ::vaelix::control::TabUpdatedEvent* _internal_mutable_updated();
  public:
  void unsafe_arena_set_allocated_updated(
      ::vaelix::control::TabUpdatedEvent* updated);
  ::vaelix::control::TabUpdatedEvent* unsafe_arena_release_updated();

  // string browser_event = 3;
  bool has_browser_event() const;
  private:
  bool _internal_has_browser_event() const;
  public:
  void clear_browser_event();
  const std::string& browser_event() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_event(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_event();
  PROTOBUF_NODISCARD std::string* release_browser_event();
  void set_allocated_browser_event(std::string* browser_event);
  private:
  const std::string& _internal_browser_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_event(const std::string& value);
  std::string* _internal_mutable_browser_event();
  public:

  // string error_event = 4;
  bool has_error_event() const;
  private:
  bool _internal_has_error_event() const;
  public:
  void clear_error_event();
  const std::string& error_event() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_event(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_event();
  PROTOBUF_NODISCARD std::string* release_error_event();
  void set_allocated_error_event(std::string* error_event);
  private:
  const std::string& _internal_error_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_event(const std::string& value);
  std::string* _internal_mutable_error_event();
  public:

  // double performance_metric = 5;
  bool has_performance_metric() const;
  private:
  bool _internal_has_performance_metric() const;
  public:
  void clear_performance_metric();
  double performance_metric() const;
  void set_performance_metric(double value);
  private:
  double _internal_performance_metric() const;
  void _internal_set_performance_metric(double value);
  public:

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vaelix.control.TabEvent)
 private:
  class _Internal;
  void set_has_closed();
  void set_has_updated();
  void set_has_browser_event();
  void set_has_error_event();
  void set_has_performance_metric();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vaelix::control::TabClosedEvent* closed_;
    ::vaelix::control::TabUpdatedEvent* updated_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_event_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_event_;
    double performance_metric_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_control_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TabInfo

// int32 tab_id = 1;
inline void TabInfo::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabInfo::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabInfo::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.tab_id)
  return _internal_tab_id();
}
inline void TabInfo::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabInfo::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.tab_id)
}

// string url = 2;
inline void TabInfo::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& TabInfo::url() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.url)
}
inline std::string* TabInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabInfo.url)
  return _s;
}
inline const std::string& TabInfo::_internal_url() const {
  return url_.Get();
}
inline void TabInfo::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabInfo::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabInfo::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabInfo.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabInfo.url)
}

// string title = 3;
inline void TabInfo::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& TabInfo::title() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.title)
}
inline std::string* TabInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabInfo.title)
  return _s;
}
inline const std::string& TabInfo::_internal_title() const {
  return title_.Get();
}
inline void TabInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabInfo::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabInfo::release_title() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabInfo.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabInfo.title)
}

// bool is_loading = 4;
inline void TabInfo::clear_is_loading() {
  is_loading_ = false;
}
inline bool TabInfo::_internal_is_loading() const {
  return is_loading_;
}
inline bool TabInfo::is_loading() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.is_loading)
  return _internal_is_loading();
}
inline void TabInfo::_internal_set_is_loading(bool value) {
  
  is_loading_ = value;
}
inline void TabInfo::set_is_loading(bool value) {
  _internal_set_is_loading(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.is_loading)
}

// bool can_go_back = 5;
inline void TabInfo::clear_can_go_back() {
  can_go_back_ = false;
}
inline bool TabInfo::_internal_can_go_back() const {
  return can_go_back_;
}
inline bool TabInfo::can_go_back() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.can_go_back)
  return _internal_can_go_back();
}
inline void TabInfo::_internal_set_can_go_back(bool value) {
  
  can_go_back_ = value;
}
inline void TabInfo::set_can_go_back(bool value) {
  _internal_set_can_go_back(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.can_go_back)
}

// bool can_go_forward = 6;
inline void TabInfo::clear_can_go_forward() {
  can_go_forward_ = false;
}
inline bool TabInfo::_internal_can_go_forward() const {
  return can_go_forward_;
}
inline bool TabInfo::can_go_forward() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.can_go_forward)
  return _internal_can_go_forward();
}
inline void TabInfo::_internal_set_can_go_forward(bool value) {
  
  can_go_forward_ = value;
}
inline void TabInfo::set_can_go_forward(bool value) {
  _internal_set_can_go_forward(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.can_go_forward)
}

// bytes favicon_data = 7;
inline void TabInfo::clear_favicon_data() {
  favicon_data_.ClearToEmpty();
}
inline const std::string& TabInfo::favicon_data() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.favicon_data)
  return _internal_favicon_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabInfo::set_favicon_data(ArgT0&& arg0, ArgT... args) {
 
 favicon_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.favicon_data)
}
inline std::string* TabInfo::mutable_favicon_data() {
  std::string* _s = _internal_mutable_favicon_data();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabInfo.favicon_data)
  return _s;
}
inline const std::string& TabInfo::_internal_favicon_data() const {
  return favicon_data_.Get();
}
inline void TabInfo::_internal_set_favicon_data(const std::string& value) {
  
  favicon_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabInfo::_internal_mutable_favicon_data() {
  
  return favicon_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabInfo::release_favicon_data() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabInfo.favicon_data)
  return favicon_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabInfo::set_allocated_favicon_data(std::string* favicon_data) {
  if (favicon_data != nullptr) {
    
  } else {
    
  }
  favicon_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), favicon_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    favicon_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabInfo.favicon_data)
}

// string content_type = 8;
inline void TabInfo::clear_content_type() {
  content_type_.ClearToEmpty();
}
inline const std::string& TabInfo::content_type() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabInfo.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabInfo::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabInfo.content_type)
}
inline std::string* TabInfo::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabInfo.content_type)
  return _s;
}
inline const std::string& TabInfo::_internal_content_type() const {
  return content_type_.Get();
}
inline void TabInfo::_internal_set_content_type(const std::string& value) {
  
  content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabInfo::_internal_mutable_content_type() {
  
  return content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabInfo::release_content_type() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabInfo.content_type)
  return content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabInfo::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabInfo.content_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StartTabRequest

// string url = 1;
inline void StartTabRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& StartTabRequest::url() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartTabRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabRequest.url)
}
inline std::string* StartTabRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.control.StartTabRequest.url)
  return _s;
}
inline const std::string& StartTabRequest::_internal_url() const {
  return url_.Get();
}
inline void StartTabRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartTabRequest::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartTabRequest::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.control.StartTabRequest.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartTabRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.StartTabRequest.url)
}

// int32 tab_id = 2;
inline void StartTabRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t StartTabRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t StartTabRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabRequest.tab_id)
  return _internal_tab_id();
}
inline void StartTabRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void StartTabRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabRequest.tab_id)
}

// map<string, string> headers = 3;
inline int StartTabRequest::_internal_headers_size() const {
  return headers_.size();
}
inline int StartTabRequest::headers_size() const {
  return _internal_headers_size();
}
inline void StartTabRequest::clear_headers() {
  headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StartTabRequest::_internal_headers() const {
  return headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StartTabRequest::headers() const {
  // @@protoc_insertion_point(field_map:vaelix.control.StartTabRequest.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StartTabRequest::_internal_mutable_headers() {
  return headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StartTabRequest::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.control.StartTabRequest.headers)
  return _internal_mutable_headers();
}

// bool private_mode = 4;
inline void StartTabRequest::clear_private_mode() {
  private_mode_ = false;
}
inline bool StartTabRequest::_internal_private_mode() const {
  return private_mode_;
}
inline bool StartTabRequest::private_mode() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabRequest.private_mode)
  return _internal_private_mode();
}
inline void StartTabRequest::_internal_set_private_mode(bool value) {
  
  private_mode_ = value;
}
inline void StartTabRequest::set_private_mode(bool value) {
  _internal_set_private_mode(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabRequest.private_mode)
}

// string user_agent = 5;
inline void StartTabRequest::clear_user_agent() {
  user_agent_.ClearToEmpty();
}
inline const std::string& StartTabRequest::user_agent() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabRequest.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartTabRequest::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 user_agent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabRequest.user_agent)
}
inline std::string* StartTabRequest::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:vaelix.control.StartTabRequest.user_agent)
  return _s;
}
inline const std::string& StartTabRequest::_internal_user_agent() const {
  return user_agent_.Get();
}
inline void StartTabRequest::_internal_set_user_agent(const std::string& value) {
  
  user_agent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartTabRequest::_internal_mutable_user_agent() {
  
  return user_agent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartTabRequest::release_user_agent() {
  // @@protoc_insertion_point(field_release:vaelix.control.StartTabRequest.user_agent)
  return user_agent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartTabRequest::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  user_agent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_agent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_agent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.StartTabRequest.user_agent)
}

// -------------------------------------------------------------------

// StartTabResponse

// bool success = 1;
inline void StartTabResponse::clear_success() {
  success_ = false;
}
inline bool StartTabResponse::_internal_success() const {
  return success_;
}
inline bool StartTabResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabResponse.success)
  return _internal_success();
}
inline void StartTabResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void StartTabResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabResponse.success)
}

// string error_message = 2;
inline void StartTabResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& StartTabResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartTabResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabResponse.error_message)
}
inline std::string* StartTabResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.control.StartTabResponse.error_message)
  return _s;
}
inline const std::string& StartTabResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void StartTabResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartTabResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartTabResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.control.StartTabResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartTabResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.StartTabResponse.error_message)
}

// bytes initial_favicon = 3;
inline void StartTabResponse::clear_initial_favicon() {
  initial_favicon_.ClearToEmpty();
}
inline const std::string& StartTabResponse::initial_favicon() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StartTabResponse.initial_favicon)
  return _internal_initial_favicon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartTabResponse::set_initial_favicon(ArgT0&& arg0, ArgT... args) {
 
 initial_favicon_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.StartTabResponse.initial_favicon)
}
inline std::string* StartTabResponse::mutable_initial_favicon() {
  std::string* _s = _internal_mutable_initial_favicon();
  // @@protoc_insertion_point(field_mutable:vaelix.control.StartTabResponse.initial_favicon)
  return _s;
}
inline const std::string& StartTabResponse::_internal_initial_favicon() const {
  return initial_favicon_.Get();
}
inline void StartTabResponse::_internal_set_initial_favicon(const std::string& value) {
  
  initial_favicon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartTabResponse::_internal_mutable_initial_favicon() {
  
  return initial_favicon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartTabResponse::release_initial_favicon() {
  // @@protoc_insertion_point(field_release:vaelix.control.StartTabResponse.initial_favicon)
  return initial_favicon_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartTabResponse::set_allocated_initial_favicon(std::string* initial_favicon) {
  if (initial_favicon != nullptr) {
    
  } else {
    
  }
  initial_favicon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_favicon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (initial_favicon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    initial_favicon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.StartTabResponse.initial_favicon)
}

// -------------------------------------------------------------------

// StopTabRequest

// int32 tab_id = 1;
inline void StopTabRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t StopTabRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t StopTabRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StopTabRequest.tab_id)
  return _internal_tab_id();
}
inline void StopTabRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void StopTabRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StopTabRequest.tab_id)
}

// bool force_close = 2;
inline void StopTabRequest::clear_force_close() {
  force_close_ = false;
}
inline bool StopTabRequest::_internal_force_close() const {
  return force_close_;
}
inline bool StopTabRequest::force_close() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StopTabRequest.force_close)
  return _internal_force_close();
}
inline void StopTabRequest::_internal_set_force_close(bool value) {
  
  force_close_ = value;
}
inline void StopTabRequest::set_force_close(bool value) {
  _internal_set_force_close(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StopTabRequest.force_close)
}

// -------------------------------------------------------------------

// StopTabResponse

// bool success = 1;
inline void StopTabResponse::clear_success() {
  success_ = false;
}
inline bool StopTabResponse::_internal_success() const {
  return success_;
}
inline bool StopTabResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StopTabResponse.success)
  return _internal_success();
}
inline void StopTabResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void StopTabResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.StopTabResponse.success)
}

// string error_message = 2;
inline void StopTabResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& StopTabResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.control.StopTabResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTabResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.StopTabResponse.error_message)
}
inline std::string* StopTabResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.control.StopTabResponse.error_message)
  return _s;
}
inline const std::string& StopTabResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void StopTabResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StopTabResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StopTabResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.control.StopTabResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StopTabResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.StopTabResponse.error_message)
}

// -------------------------------------------------------------------

// NavigateRequest

// int32 tab_id = 1;
inline void NavigateRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t NavigateRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t NavigateRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateRequest.tab_id)
  return _internal_tab_id();
}
inline void NavigateRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void NavigateRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateRequest.tab_id)
}

// string url = 2;
inline void NavigateRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& NavigateRequest::url() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateRequest.url)
}
inline std::string* NavigateRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.control.NavigateRequest.url)
  return _s;
}
inline const std::string& NavigateRequest::_internal_url() const {
  return url_.Get();
}
inline void NavigateRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NavigateRequest::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NavigateRequest::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.control.NavigateRequest.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NavigateRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.NavigateRequest.url)
}

// bool force_reload = 3;
inline void NavigateRequest::clear_force_reload() {
  force_reload_ = false;
}
inline bool NavigateRequest::_internal_force_reload() const {
  return force_reload_;
}
inline bool NavigateRequest::force_reload() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateRequest.force_reload)
  return _internal_force_reload();
}
inline void NavigateRequest::_internal_set_force_reload(bool value) {
  
  force_reload_ = value;
}
inline void NavigateRequest::set_force_reload(bool value) {
  _internal_set_force_reload(value);
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateRequest.force_reload)
}

// -------------------------------------------------------------------

// NavigateResponse

// bool success = 1;
inline void NavigateResponse::clear_success() {
  success_ = false;
}
inline bool NavigateResponse::_internal_success() const {
  return success_;
}
inline bool NavigateResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateResponse.success)
  return _internal_success();
}
inline void NavigateResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void NavigateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateResponse.success)
}

// string error_message = 2;
inline void NavigateResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& NavigateResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateResponse.error_message)
}
inline std::string* NavigateResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.control.NavigateResponse.error_message)
  return _s;
}
inline const std::string& NavigateResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void NavigateResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NavigateResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NavigateResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.control.NavigateResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NavigateResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.NavigateResponse.error_message)
}

// string redirected_url = 3;
inline void NavigateResponse::clear_redirected_url() {
  redirected_url_.ClearToEmpty();
}
inline const std::string& NavigateResponse::redirected_url() const {
  // @@protoc_insertion_point(field_get:vaelix.control.NavigateResponse.redirected_url)
  return _internal_redirected_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateResponse::set_redirected_url(ArgT0&& arg0, ArgT... args) {
 
 redirected_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.NavigateResponse.redirected_url)
}
inline std::string* NavigateResponse::mutable_redirected_url() {
  std::string* _s = _internal_mutable_redirected_url();
  // @@protoc_insertion_point(field_mutable:vaelix.control.NavigateResponse.redirected_url)
  return _s;
}
inline const std::string& NavigateResponse::_internal_redirected_url() const {
  return redirected_url_.Get();
}
inline void NavigateResponse::_internal_set_redirected_url(const std::string& value) {
  
  redirected_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NavigateResponse::_internal_mutable_redirected_url() {
  
  return redirected_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NavigateResponse::release_redirected_url() {
  // @@protoc_insertion_point(field_release:vaelix.control.NavigateResponse.redirected_url)
  return redirected_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NavigateResponse::set_allocated_redirected_url(std::string* redirected_url) {
  if (redirected_url != nullptr) {
    
  } else {
    
  }
  redirected_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), redirected_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redirected_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redirected_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.NavigateResponse.redirected_url)
}

// -------------------------------------------------------------------

// GetTabInfoRequest

// int32 tab_id = 1;
inline void GetTabInfoRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t GetTabInfoRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t GetTabInfoRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetTabInfoRequest.tab_id)
  return _internal_tab_id();
}
inline void GetTabInfoRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void GetTabInfoRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.GetTabInfoRequest.tab_id)
}

// -------------------------------------------------------------------

// GetTabInfoResponse

// .vaelix.control.TabInfo tab_info = 1;
inline bool GetTabInfoResponse::_internal_has_tab_info() const {
  return this != internal_default_instance() && tab_info_ != nullptr;
}
inline bool GetTabInfoResponse::has_tab_info() const {
  return _internal_has_tab_info();
}
inline void GetTabInfoResponse::clear_tab_info() {
  if (GetArenaForAllocation() == nullptr && tab_info_ != nullptr) {
    delete tab_info_;
  }
  tab_info_ = nullptr;
}
inline const ::vaelix::control::TabInfo& GetTabInfoResponse::_internal_tab_info() const {
  const ::vaelix::control::TabInfo* p = tab_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::control::TabInfo&>(
      ::vaelix::control::_TabInfo_default_instance_);
}
inline const ::vaelix::control::TabInfo& GetTabInfoResponse::tab_info() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetTabInfoResponse.tab_info)
  return _internal_tab_info();
}
inline void GetTabInfoResponse::unsafe_arena_set_allocated_tab_info(
    ::vaelix::control::TabInfo* tab_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tab_info_);
  }
  tab_info_ = tab_info;
  if (tab_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.control.GetTabInfoResponse.tab_info)
}
inline ::vaelix::control::TabInfo* GetTabInfoResponse::release_tab_info() {
  
  ::vaelix::control::TabInfo* temp = tab_info_;
  tab_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::control::TabInfo* GetTabInfoResponse::unsafe_arena_release_tab_info() {
  // @@protoc_insertion_point(field_release:vaelix.control.GetTabInfoResponse.tab_info)
  
  ::vaelix::control::TabInfo* temp = tab_info_;
  tab_info_ = nullptr;
  return temp;
}
inline ::vaelix::control::TabInfo* GetTabInfoResponse::_internal_mutable_tab_info() {
  
  if (tab_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::control::TabInfo>(GetArenaForAllocation());
    tab_info_ = p;
  }
  return tab_info_;
}
inline ::vaelix::control::TabInfo* GetTabInfoResponse::mutable_tab_info() {
  ::vaelix::control::TabInfo* _msg = _internal_mutable_tab_info();
  // @@protoc_insertion_point(field_mutable:vaelix.control.GetTabInfoResponse.tab_info)
  return _msg;
}
inline void GetTabInfoResponse::set_allocated_tab_info(::vaelix::control::TabInfo* tab_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tab_info_;
  }
  if (tab_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::control::TabInfo>::GetOwningArena(tab_info);
    if (message_arena != submessage_arena) {
      tab_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tab_info, submessage_arena);
    }
    
  } else {
    
  }
  tab_info_ = tab_info;
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.GetTabInfoResponse.tab_info)
}

// bool success = 2;
inline void GetTabInfoResponse::clear_success() {
  success_ = false;
}
inline bool GetTabInfoResponse::_internal_success() const {
  return success_;
}
inline bool GetTabInfoResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetTabInfoResponse.success)
  return _internal_success();
}
inline void GetTabInfoResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetTabInfoResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.GetTabInfoResponse.success)
}

// string error_message = 3;
inline void GetTabInfoResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& GetTabInfoResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetTabInfoResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabInfoResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.GetTabInfoResponse.error_message)
}
inline std::string* GetTabInfoResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.control.GetTabInfoResponse.error_message)
  return _s;
}
inline const std::string& GetTabInfoResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void GetTabInfoResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTabInfoResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTabInfoResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.control.GetTabInfoResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTabInfoResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.GetTabInfoResponse.error_message)
}

// -------------------------------------------------------------------

// TabClosedEvent

// int32 tab_id = 1;
inline void TabClosedEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabClosedEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabClosedEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabClosedEvent.tab_id)
  return _internal_tab_id();
}
inline void TabClosedEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabClosedEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabClosedEvent.tab_id)
}

// int32 close_reason = 2;
inline void TabClosedEvent::clear_close_reason() {
  close_reason_ = 0;
}
inline int32_t TabClosedEvent::_internal_close_reason() const {
  return close_reason_;
}
inline int32_t TabClosedEvent::close_reason() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabClosedEvent.close_reason)
  return _internal_close_reason();
}
inline void TabClosedEvent::_internal_set_close_reason(int32_t value) {
  
  close_reason_ = value;
}
inline void TabClosedEvent::set_close_reason(int32_t value) {
  _internal_set_close_reason(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabClosedEvent.close_reason)
}

// -------------------------------------------------------------------

// TabUpdatedEvent

// int32 tab_id = 1;
inline void TabUpdatedEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabUpdatedEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabUpdatedEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabUpdatedEvent.tab_id)
  return _internal_tab_id();
}
inline void TabUpdatedEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabUpdatedEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabUpdatedEvent.tab_id)
}

// .vaelix.control.TabInfo tab_info = 2;
inline bool TabUpdatedEvent::_internal_has_tab_info() const {
  return this != internal_default_instance() && tab_info_ != nullptr;
}
inline bool TabUpdatedEvent::has_tab_info() const {
  return _internal_has_tab_info();
}
inline void TabUpdatedEvent::clear_tab_info() {
  if (GetArenaForAllocation() == nullptr && tab_info_ != nullptr) {
    delete tab_info_;
  }
  tab_info_ = nullptr;
}
inline const ::vaelix::control::TabInfo& TabUpdatedEvent::_internal_tab_info() const {
  const ::vaelix::control::TabInfo* p = tab_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::control::TabInfo&>(
      ::vaelix::control::_TabInfo_default_instance_);
}
inline const ::vaelix::control::TabInfo& TabUpdatedEvent::tab_info() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabUpdatedEvent.tab_info)
  return _internal_tab_info();
}
inline void TabUpdatedEvent::unsafe_arena_set_allocated_tab_info(
    ::vaelix::control::TabInfo* tab_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tab_info_);
  }
  tab_info_ = tab_info;
  if (tab_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.control.TabUpdatedEvent.tab_info)
}
inline ::vaelix::control::TabInfo* TabUpdatedEvent::release_tab_info() {
  
  ::vaelix::control::TabInfo* temp = tab_info_;
  tab_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::control::TabInfo* TabUpdatedEvent::unsafe_arena_release_tab_info() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabUpdatedEvent.tab_info)
  
  ::vaelix::control::TabInfo* temp = tab_info_;
  tab_info_ = nullptr;
  return temp;
}
inline ::vaelix::control::TabInfo* TabUpdatedEvent::_internal_mutable_tab_info() {
  
  if (tab_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::control::TabInfo>(GetArenaForAllocation());
    tab_info_ = p;
  }
  return tab_info_;
}
inline ::vaelix::control::TabInfo* TabUpdatedEvent::mutable_tab_info() {
  ::vaelix::control::TabInfo* _msg = _internal_mutable_tab_info();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabUpdatedEvent.tab_info)
  return _msg;
}
inline void TabUpdatedEvent::set_allocated_tab_info(::vaelix::control::TabInfo* tab_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tab_info_;
  }
  if (tab_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::control::TabInfo>::GetOwningArena(tab_info);
    if (message_arena != submessage_arena) {
      tab_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tab_info, submessage_arena);
    }
    
  } else {
    
  }
  tab_info_ = tab_info;
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabUpdatedEvent.tab_info)
}

// string update_type = 3;
inline void TabUpdatedEvent::clear_update_type() {
  update_type_.ClearToEmpty();
}
inline const std::string& TabUpdatedEvent::update_type() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabUpdatedEvent.update_type)
  return _internal_update_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabUpdatedEvent::set_update_type(ArgT0&& arg0, ArgT... args) {
 
 update_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabUpdatedEvent.update_type)
}
inline std::string* TabUpdatedEvent::mutable_update_type() {
  std::string* _s = _internal_mutable_update_type();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabUpdatedEvent.update_type)
  return _s;
}
inline const std::string& TabUpdatedEvent::_internal_update_type() const {
  return update_type_.Get();
}
inline void TabUpdatedEvent::_internal_set_update_type(const std::string& value) {
  
  update_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabUpdatedEvent::_internal_mutable_update_type() {
  
  return update_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabUpdatedEvent::release_update_type() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabUpdatedEvent.update_type)
  return update_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabUpdatedEvent::set_allocated_update_type(std::string* update_type) {
  if (update_type != nullptr) {
    
  } else {
    
  }
  update_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), update_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (update_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    update_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabUpdatedEvent.update_type)
}

// -------------------------------------------------------------------

// BrowserShutdownRequest

// bool force_kill = 1;
inline void BrowserShutdownRequest::clear_force_kill() {
  force_kill_ = false;
}
inline bool BrowserShutdownRequest::_internal_force_kill() const {
  return force_kill_;
}
inline bool BrowserShutdownRequest::force_kill() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserShutdownRequest.force_kill)
  return _internal_force_kill();
}
inline void BrowserShutdownRequest::_internal_set_force_kill(bool value) {
  
  force_kill_ = value;
}
inline void BrowserShutdownRequest::set_force_kill(bool value) {
  _internal_set_force_kill(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserShutdownRequest.force_kill)
}

// string reason = 2;
inline void BrowserShutdownRequest::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& BrowserShutdownRequest::reason() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserShutdownRequest.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserShutdownRequest::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserShutdownRequest.reason)
}
inline std::string* BrowserShutdownRequest::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:vaelix.control.BrowserShutdownRequest.reason)
  return _s;
}
inline const std::string& BrowserShutdownRequest::_internal_reason() const {
  return reason_.Get();
}
inline void BrowserShutdownRequest::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BrowserShutdownRequest::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BrowserShutdownRequest::release_reason() {
  // @@protoc_insertion_point(field_release:vaelix.control.BrowserShutdownRequest.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BrowserShutdownRequest::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.BrowserShutdownRequest.reason)
}

// -------------------------------------------------------------------

// BrowserShutdownResponse

// bool success = 1;
inline void BrowserShutdownResponse::clear_success() {
  success_ = false;
}
inline bool BrowserShutdownResponse::_internal_success() const {
  return success_;
}
inline bool BrowserShutdownResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserShutdownResponse.success)
  return _internal_success();
}
inline void BrowserShutdownResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void BrowserShutdownResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserShutdownResponse.success)
}

// repeated int32 remaining_tabs = 2;
inline int BrowserShutdownResponse::_internal_remaining_tabs_size() const {
  return remaining_tabs_.size();
}
inline int BrowserShutdownResponse::remaining_tabs_size() const {
  return _internal_remaining_tabs_size();
}
inline void BrowserShutdownResponse::clear_remaining_tabs() {
  remaining_tabs_.Clear();
}
inline int32_t BrowserShutdownResponse::_internal_remaining_tabs(int index) const {
  return remaining_tabs_.Get(index);
}
inline int32_t BrowserShutdownResponse::remaining_tabs(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserShutdownResponse.remaining_tabs)
  return _internal_remaining_tabs(index);
}
inline void BrowserShutdownResponse::set_remaining_tabs(int index, int32_t value) {
  remaining_tabs_.Set(index, value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserShutdownResponse.remaining_tabs)
}
inline void BrowserShutdownResponse::_internal_add_remaining_tabs(int32_t value) {
  remaining_tabs_.Add(value);
}
inline void BrowserShutdownResponse::add_remaining_tabs(int32_t value) {
  _internal_add_remaining_tabs(value);
  // @@protoc_insertion_point(field_add:vaelix.control.BrowserShutdownResponse.remaining_tabs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BrowserShutdownResponse::_internal_remaining_tabs() const {
  return remaining_tabs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BrowserShutdownResponse::remaining_tabs() const {
  // @@protoc_insertion_point(field_list:vaelix.control.BrowserShutdownResponse.remaining_tabs)
  return _internal_remaining_tabs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BrowserShutdownResponse::_internal_mutable_remaining_tabs() {
  return &remaining_tabs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BrowserShutdownResponse::mutable_remaining_tabs() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.control.BrowserShutdownResponse.remaining_tabs)
  return _internal_mutable_remaining_tabs();
}

// int32 shutdown_delay_ms = 3;
inline void BrowserShutdownResponse::clear_shutdown_delay_ms() {
  shutdown_delay_ms_ = 0;
}
inline int32_t BrowserShutdownResponse::_internal_shutdown_delay_ms() const {
  return shutdown_delay_ms_;
}
inline int32_t BrowserShutdownResponse::shutdown_delay_ms() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserShutdownResponse.shutdown_delay_ms)
  return _internal_shutdown_delay_ms();
}
inline void BrowserShutdownResponse::_internal_set_shutdown_delay_ms(int32_t value) {
  
  shutdown_delay_ms_ = value;
}
inline void BrowserShutdownResponse::set_shutdown_delay_ms(int32_t value) {
  _internal_set_shutdown_delay_ms(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserShutdownResponse.shutdown_delay_ms)
}

// -------------------------------------------------------------------

// BrowserMetrics

// int32 active_tabs = 1;
inline void BrowserMetrics::clear_active_tabs() {
  active_tabs_ = 0;
}
inline int32_t BrowserMetrics::_internal_active_tabs() const {
  return active_tabs_;
}
inline int32_t BrowserMetrics::active_tabs() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.active_tabs)
  return _internal_active_tabs();
}
inline void BrowserMetrics::_internal_set_active_tabs(int32_t value) {
  
  active_tabs_ = value;
}
inline void BrowserMetrics::set_active_tabs(int32_t value) {
  _internal_set_active_tabs(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.active_tabs)
}

// int64 memory_usage_mb = 2;
inline void BrowserMetrics::clear_memory_usage_mb() {
  memory_usage_mb_ = int64_t{0};
}
inline int64_t BrowserMetrics::_internal_memory_usage_mb() const {
  return memory_usage_mb_;
}
inline int64_t BrowserMetrics::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void BrowserMetrics::_internal_set_memory_usage_mb(int64_t value) {
  
  memory_usage_mb_ = value;
}
inline void BrowserMetrics::set_memory_usage_mb(int64_t value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.memory_usage_mb)
}

// double cpu_usage_percent = 3;
inline void BrowserMetrics::clear_cpu_usage_percent() {
  cpu_usage_percent_ = 0;
}
inline double BrowserMetrics::_internal_cpu_usage_percent() const {
  return cpu_usage_percent_;
}
inline double BrowserMetrics::cpu_usage_percent() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.cpu_usage_percent)
  return _internal_cpu_usage_percent();
}
inline void BrowserMetrics::_internal_set_cpu_usage_percent(double value) {
  
  cpu_usage_percent_ = value;
}
inline void BrowserMetrics::set_cpu_usage_percent(double value) {
  _internal_set_cpu_usage_percent(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.cpu_usage_percent)
}

// int64 network_bytes_received = 4;
inline void BrowserMetrics::clear_network_bytes_received() {
  network_bytes_received_ = int64_t{0};
}
inline int64_t BrowserMetrics::_internal_network_bytes_received() const {
  return network_bytes_received_;
}
inline int64_t BrowserMetrics::network_bytes_received() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.network_bytes_received)
  return _internal_network_bytes_received();
}
inline void BrowserMetrics::_internal_set_network_bytes_received(int64_t value) {
  
  network_bytes_received_ = value;
}
inline void BrowserMetrics::set_network_bytes_received(int64_t value) {
  _internal_set_network_bytes_received(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.network_bytes_received)
}

// int64 network_bytes_sent = 5;
inline void BrowserMetrics::clear_network_bytes_sent() {
  network_bytes_sent_ = int64_t{0};
}
inline int64_t BrowserMetrics::_internal_network_bytes_sent() const {
  return network_bytes_sent_;
}
inline int64_t BrowserMetrics::network_bytes_sent() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.network_bytes_sent)
  return _internal_network_bytes_sent();
}
inline void BrowserMetrics::_internal_set_network_bytes_sent(int64_t value) {
  
  network_bytes_sent_ = value;
}
inline void BrowserMetrics::set_network_bytes_sent(int64_t value) {
  _internal_set_network_bytes_sent(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.network_bytes_sent)
}

// double render_time_ms = 6;
inline void BrowserMetrics::clear_render_time_ms() {
  render_time_ms_ = 0;
}
inline double BrowserMetrics::_internal_render_time_ms() const {
  return render_time_ms_;
}
inline double BrowserMetrics::render_time_ms() const {
  // @@protoc_insertion_point(field_get:vaelix.control.BrowserMetrics.render_time_ms)
  return _internal_render_time_ms();
}
inline void BrowserMetrics::_internal_set_render_time_ms(double value) {
  
  render_time_ms_ = value;
}
inline void BrowserMetrics::set_render_time_ms(double value) {
  _internal_set_render_time_ms(value);
  // @@protoc_insertion_point(field_set:vaelix.control.BrowserMetrics.render_time_ms)
}

// -------------------------------------------------------------------

// GetBrowserMetricsRequest

// bool include_detailed_stats = 1;
inline void GetBrowserMetricsRequest::clear_include_detailed_stats() {
  include_detailed_stats_ = false;
}
inline bool GetBrowserMetricsRequest::_internal_include_detailed_stats() const {
  return include_detailed_stats_;
}
inline bool GetBrowserMetricsRequest::include_detailed_stats() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetBrowserMetricsRequest.include_detailed_stats)
  return _internal_include_detailed_stats();
}
inline void GetBrowserMetricsRequest::_internal_set_include_detailed_stats(bool value) {
  
  include_detailed_stats_ = value;
}
inline void GetBrowserMetricsRequest::set_include_detailed_stats(bool value) {
  _internal_set_include_detailed_stats(value);
  // @@protoc_insertion_point(field_set:vaelix.control.GetBrowserMetricsRequest.include_detailed_stats)
}

// -------------------------------------------------------------------

// GetBrowserMetricsResponse

// .vaelix.control.BrowserMetrics metrics = 1;
inline bool GetBrowserMetricsResponse::_internal_has_metrics() const {
  return this != internal_default_instance() && metrics_ != nullptr;
}
inline bool GetBrowserMetricsResponse::has_metrics() const {
  return _internal_has_metrics();
}
inline void GetBrowserMetricsResponse::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && metrics_ != nullptr) {
    delete metrics_;
  }
  metrics_ = nullptr;
}
inline const ::vaelix::control::BrowserMetrics& GetBrowserMetricsResponse::_internal_metrics() const {
  const ::vaelix::control::BrowserMetrics* p = metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::control::BrowserMetrics&>(
      ::vaelix::control::_BrowserMetrics_default_instance_);
}
inline const ::vaelix::control::BrowserMetrics& GetBrowserMetricsResponse::metrics() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetBrowserMetricsResponse.metrics)
  return _internal_metrics();
}
inline void GetBrowserMetricsResponse::unsafe_arena_set_allocated_metrics(
    ::vaelix::control::BrowserMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metrics_);
  }
  metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.control.GetBrowserMetricsResponse.metrics)
}
inline ::vaelix::control::BrowserMetrics* GetBrowserMetricsResponse::release_metrics() {
  
  ::vaelix::control::BrowserMetrics* temp = metrics_;
  metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::control::BrowserMetrics* GetBrowserMetricsResponse::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:vaelix.control.GetBrowserMetricsResponse.metrics)
  
  ::vaelix::control::BrowserMetrics* temp = metrics_;
  metrics_ = nullptr;
  return temp;
}
inline ::vaelix::control::BrowserMetrics* GetBrowserMetricsResponse::_internal_mutable_metrics() {
  
  if (metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::control::BrowserMetrics>(GetArenaForAllocation());
    metrics_ = p;
  }
  return metrics_;
}
inline ::vaelix::control::BrowserMetrics* GetBrowserMetricsResponse::mutable_metrics() {
  ::vaelix::control::BrowserMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:vaelix.control.GetBrowserMetricsResponse.metrics)
  return _msg;
}
inline void GetBrowserMetricsResponse::set_allocated_metrics(::vaelix::control::BrowserMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::control::BrowserMetrics>::GetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.GetBrowserMetricsResponse.metrics)
}

// bool success = 2;
inline void GetBrowserMetricsResponse::clear_success() {
  success_ = false;
}
inline bool GetBrowserMetricsResponse::_internal_success() const {
  return success_;
}
inline bool GetBrowserMetricsResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetBrowserMetricsResponse.success)
  return _internal_success();
}
inline void GetBrowserMetricsResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetBrowserMetricsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.control.GetBrowserMetricsResponse.success)
}

// string timestamp = 3;
inline void GetBrowserMetricsResponse::clear_timestamp() {
  timestamp_.ClearToEmpty();
}
inline const std::string& GetBrowserMetricsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.control.GetBrowserMetricsResponse.timestamp)
  return _internal_timestamp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBrowserMetricsResponse::set_timestamp(ArgT0&& arg0, ArgT... args) {
 
 timestamp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.GetBrowserMetricsResponse.timestamp)
}
inline std::string* GetBrowserMetricsResponse::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:vaelix.control.GetBrowserMetricsResponse.timestamp)
  return _s;
}
inline const std::string& GetBrowserMetricsResponse::_internal_timestamp() const {
  return timestamp_.Get();
}
inline void GetBrowserMetricsResponse::_internal_set_timestamp(const std::string& value) {
  
  timestamp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBrowserMetricsResponse::_internal_mutable_timestamp() {
  
  return timestamp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBrowserMetricsResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:vaelix.control.GetBrowserMetricsResponse.timestamp)
  return timestamp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBrowserMetricsResponse::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timestamp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    timestamp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.GetBrowserMetricsResponse.timestamp)
}

// -------------------------------------------------------------------

// TabEvent

// .vaelix.control.TabClosedEvent closed = 1;
inline bool TabEvent::_internal_has_closed() const {
  return event_case() == kClosed;
}
inline bool TabEvent::has_closed() const {
  return _internal_has_closed();
}
inline void TabEvent::set_has_closed() {
  _oneof_case_[0] = kClosed;
}
inline void TabEvent::clear_closed() {
  if (_internal_has_closed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.closed_;
    }
    clear_has_event();
  }
}
inline ::vaelix::control::TabClosedEvent* TabEvent::release_closed() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabEvent.closed)
  if (_internal_has_closed()) {
    clear_has_event();
      ::vaelix::control::TabClosedEvent* temp = event_.closed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.closed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::control::TabClosedEvent& TabEvent::_internal_closed() const {
  return _internal_has_closed()
      ? *event_.closed_
      : reinterpret_cast< ::vaelix::control::TabClosedEvent&>(::vaelix::control::_TabClosedEvent_default_instance_);
}
inline const ::vaelix::control::TabClosedEvent& TabEvent::closed() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabEvent.closed)
  return _internal_closed();
}
inline ::vaelix::control::TabClosedEvent* TabEvent::unsafe_arena_release_closed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.control.TabEvent.closed)
  if (_internal_has_closed()) {
    clear_has_event();
    ::vaelix::control::TabClosedEvent* temp = event_.closed_;
    event_.closed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TabEvent::unsafe_arena_set_allocated_closed(::vaelix::control::TabClosedEvent* closed) {
  clear_event();
  if (closed) {
    set_has_closed();
    event_.closed_ = closed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.control.TabEvent.closed)
}
inline ::vaelix::control::TabClosedEvent* TabEvent::_internal_mutable_closed() {
  if (!_internal_has_closed()) {
    clear_event();
    set_has_closed();
    event_.closed_ = CreateMaybeMessage< ::vaelix::control::TabClosedEvent >(GetArenaForAllocation());
  }
  return event_.closed_;
}
inline ::vaelix::control::TabClosedEvent* TabEvent::mutable_closed() {
  ::vaelix::control::TabClosedEvent* _msg = _internal_mutable_closed();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabEvent.closed)
  return _msg;
}

// .vaelix.control.TabUpdatedEvent updated = 2;
inline bool TabEvent::_internal_has_updated() const {
  return event_case() == kUpdated;
}
inline bool TabEvent::has_updated() const {
  return _internal_has_updated();
}
inline void TabEvent::set_has_updated() {
  _oneof_case_[0] = kUpdated;
}
inline void TabEvent::clear_updated() {
  if (_internal_has_updated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.updated_;
    }
    clear_has_event();
  }
}
inline ::vaelix::control::TabUpdatedEvent* TabEvent::release_updated() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabEvent.updated)
  if (_internal_has_updated()) {
    clear_has_event();
      ::vaelix::control::TabUpdatedEvent* temp = event_.updated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::control::TabUpdatedEvent& TabEvent::_internal_updated() const {
  return _internal_has_updated()
      ? *event_.updated_
      : reinterpret_cast< ::vaelix::control::TabUpdatedEvent&>(::vaelix::control::_TabUpdatedEvent_default_instance_);
}
inline const ::vaelix::control::TabUpdatedEvent& TabEvent::updated() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabEvent.updated)
  return _internal_updated();
}
inline ::vaelix::control::TabUpdatedEvent* TabEvent::unsafe_arena_release_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.control.TabEvent.updated)
  if (_internal_has_updated()) {
    clear_has_event();
    ::vaelix::control::TabUpdatedEvent* temp = event_.updated_;
    event_.updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TabEvent::unsafe_arena_set_allocated_updated(::vaelix::control::TabUpdatedEvent* updated) {
  clear_event();
  if (updated) {
    set_has_updated();
    event_.updated_ = updated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.control.TabEvent.updated)
}
inline ::vaelix::control::TabUpdatedEvent* TabEvent::_internal_mutable_updated() {
  if (!_internal_has_updated()) {
    clear_event();
    set_has_updated();
    event_.updated_ = CreateMaybeMessage< ::vaelix::control::TabUpdatedEvent >(GetArenaForAllocation());
  }
  return event_.updated_;
}
inline ::vaelix::control::TabUpdatedEvent* TabEvent::mutable_updated() {
  ::vaelix::control::TabUpdatedEvent* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabEvent.updated)
  return _msg;
}

// string browser_event = 3;
inline bool TabEvent::_internal_has_browser_event() const {
  return event_case() == kBrowserEvent;
}
inline bool TabEvent::has_browser_event() const {
  return _internal_has_browser_event();
}
inline void TabEvent::set_has_browser_event() {
  _oneof_case_[0] = kBrowserEvent;
}
inline void TabEvent::clear_browser_event() {
  if (_internal_has_browser_event()) {
    event_.browser_event_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_event();
  }
}
inline const std::string& TabEvent::browser_event() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabEvent.browser_event)
  return _internal_browser_event();
}
template <typename ArgT0, typename... ArgT>
inline void TabEvent::set_browser_event(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_browser_event()) {
    clear_event();
    set_has_browser_event();
    event_.browser_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.browser_event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabEvent.browser_event)
}
inline std::string* TabEvent::mutable_browser_event() {
  std::string* _s = _internal_mutable_browser_event();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabEvent.browser_event)
  return _s;
}
inline const std::string& TabEvent::_internal_browser_event() const {
  if (_internal_has_browser_event()) {
    return event_.browser_event_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TabEvent::_internal_set_browser_event(const std::string& value) {
  if (!_internal_has_browser_event()) {
    clear_event();
    set_has_browser_event();
    event_.browser_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.browser_event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabEvent::_internal_mutable_browser_event() {
  if (!_internal_has_browser_event()) {
    clear_event();
    set_has_browser_event();
    event_.browser_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return event_.browser_event_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabEvent::release_browser_event() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabEvent.browser_event)
  if (_internal_has_browser_event()) {
    clear_has_event();
    return event_.browser_event_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TabEvent::set_allocated_browser_event(std::string* browser_event) {
  if (has_event()) {
    clear_event();
  }
  if (browser_event != nullptr) {
    set_has_browser_event();
    event_.browser_event_.UnsafeSetDefault(browser_event);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(browser_event);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabEvent.browser_event)
}

// string error_event = 4;
inline bool TabEvent::_internal_has_error_event() const {
  return event_case() == kErrorEvent;
}
inline bool TabEvent::has_error_event() const {
  return _internal_has_error_event();
}
inline void TabEvent::set_has_error_event() {
  _oneof_case_[0] = kErrorEvent;
}
inline void TabEvent::clear_error_event() {
  if (_internal_has_error_event()) {
    event_.error_event_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_event();
  }
}
inline const std::string& TabEvent::error_event() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabEvent.error_event)
  return _internal_error_event();
}
template <typename ArgT0, typename... ArgT>
inline void TabEvent::set_error_event(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error_event()) {
    clear_event();
    set_has_error_event();
    event_.error_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.error_event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.control.TabEvent.error_event)
}
inline std::string* TabEvent::mutable_error_event() {
  std::string* _s = _internal_mutable_error_event();
  // @@protoc_insertion_point(field_mutable:vaelix.control.TabEvent.error_event)
  return _s;
}
inline const std::string& TabEvent::_internal_error_event() const {
  if (_internal_has_error_event()) {
    return event_.error_event_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TabEvent::_internal_set_error_event(const std::string& value) {
  if (!_internal_has_error_event()) {
    clear_event();
    set_has_error_event();
    event_.error_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.error_event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabEvent::_internal_mutable_error_event() {
  if (!_internal_has_error_event()) {
    clear_event();
    set_has_error_event();
    event_.error_event_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return event_.error_event_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabEvent::release_error_event() {
  // @@protoc_insertion_point(field_release:vaelix.control.TabEvent.error_event)
  if (_internal_has_error_event()) {
    clear_has_event();
    return event_.error_event_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TabEvent::set_allocated_error_event(std::string* error_event) {
  if (has_event()) {
    clear_event();
  }
  if (error_event != nullptr) {
    set_has_error_event();
    event_.error_event_.UnsafeSetDefault(error_event);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(error_event);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vaelix.control.TabEvent.error_event)
}

// double performance_metric = 5;
inline bool TabEvent::_internal_has_performance_metric() const {
  return event_case() == kPerformanceMetric;
}
inline bool TabEvent::has_performance_metric() const {
  return _internal_has_performance_metric();
}
inline void TabEvent::set_has_performance_metric() {
  _oneof_case_[0] = kPerformanceMetric;
}
inline void TabEvent::clear_performance_metric() {
  if (_internal_has_performance_metric()) {
    event_.performance_metric_ = 0;
    clear_has_event();
  }
}
inline double TabEvent::_internal_performance_metric() const {
  if (_internal_has_performance_metric()) {
    return event_.performance_metric_;
  }
  return 0;
}
inline void TabEvent::_internal_set_performance_metric(double value) {
  if (!_internal_has_performance_metric()) {
    clear_event();
    set_has_performance_metric();
  }
  event_.performance_metric_ = value;
}
inline double TabEvent::performance_metric() const {
  // @@protoc_insertion_point(field_get:vaelix.control.TabEvent.performance_metric)
  return _internal_performance_metric();
}
inline void TabEvent::set_performance_metric(double value) {
  _internal_set_performance_metric(value);
  // @@protoc_insertion_point(field_set:vaelix.control.TabEvent.performance_metric)
}

inline bool TabEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void TabEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline TabEvent::EventCase TabEvent::event_case() const {
  return TabEvent::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace control
}  // namespace vaelix

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_control_2eproto
