// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ui_events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ui_5fevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ui_5fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ui_5fevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ui_5fevents_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ui_5fevents_2eproto;
namespace vaelix {
namespace ui {
class FileDownloadEvent;
struct FileDownloadEventDefaultTypeInternal;
extern FileDownloadEventDefaultTypeInternal _FileDownloadEvent_default_instance_;
class FocusChangeEvent;
struct FocusChangeEventDefaultTypeInternal;
extern FocusChangeEventDefaultTypeInternal _FocusChangeEvent_default_instance_;
class InputEvent;
struct InputEventDefaultTypeInternal;
extern InputEventDefaultTypeInternal _InputEvent_default_instance_;
class KeyboardEvent;
struct KeyboardEventDefaultTypeInternal;
extern KeyboardEventDefaultTypeInternal _KeyboardEvent_default_instance_;
class MouseEvent;
struct MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class NavigationRequest;
struct NavigationRequestDefaultTypeInternal;
extern NavigationRequestDefaultTypeInternal _NavigationRequest_default_instance_;
class PermissionRequest;
struct PermissionRequestDefaultTypeInternal;
extern PermissionRequestDefaultTypeInternal _PermissionRequest_default_instance_;
class ShortcutEvent;
struct ShortcutEventDefaultTypeInternal;
extern ShortcutEventDefaultTypeInternal _ShortcutEvent_default_instance_;
class TabEvent;
struct TabEventDefaultTypeInternal;
extern TabEventDefaultTypeInternal _TabEvent_default_instance_;
class TabOperationRequest;
struct TabOperationRequestDefaultTypeInternal;
extern TabOperationRequestDefaultTypeInternal _TabOperationRequest_default_instance_;
class TabOperationRequest_ParametersEntry_DoNotUse;
struct TabOperationRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern TabOperationRequest_ParametersEntry_DoNotUseDefaultTypeInternal _TabOperationRequest_ParametersEntry_DoNotUse_default_instance_;
class TabStateInfo;
struct TabStateInfoDefaultTypeInternal;
extern TabStateInfoDefaultTypeInternal _TabStateInfo_default_instance_;
class TabStatesRequest;
struct TabStatesRequestDefaultTypeInternal;
extern TabStatesRequestDefaultTypeInternal _TabStatesRequest_default_instance_;
class ThemeChangeEvent;
struct ThemeChangeEventDefaultTypeInternal;
extern ThemeChangeEventDefaultTypeInternal _ThemeChangeEvent_default_instance_;
class UIStateQuery;
struct UIStateQueryDefaultTypeInternal;
extern UIStateQueryDefaultTypeInternal _UIStateQuery_default_instance_;
class UIStateUpdate;
struct UIStateUpdateDefaultTypeInternal;
extern UIStateUpdateDefaultTypeInternal _UIStateUpdate_default_instance_;
class UIStateUpdate_UiStateEntry_DoNotUse;
struct UIStateUpdate_UiStateEntry_DoNotUseDefaultTypeInternal;
extern UIStateUpdate_UiStateEntry_DoNotUseDefaultTypeInternal _UIStateUpdate_UiStateEntry_DoNotUse_default_instance_;
class WindowEvent;
struct WindowEventDefaultTypeInternal;
extern WindowEventDefaultTypeInternal _WindowEvent_default_instance_;
class WindowInfo;
struct WindowInfoDefaultTypeInternal;
extern WindowInfoDefaultTypeInternal _WindowInfo_default_instance_;
class WindowInfoRequest;
struct WindowInfoRequestDefaultTypeInternal;
extern WindowInfoRequestDefaultTypeInternal _WindowInfoRequest_default_instance_;
class WindowMoveEvent;
struct WindowMoveEventDefaultTypeInternal;
extern WindowMoveEventDefaultTypeInternal _WindowMoveEvent_default_instance_;
class WindowOperationRequest;
struct WindowOperationRequestDefaultTypeInternal;
extern WindowOperationRequestDefaultTypeInternal _WindowOperationRequest_default_instance_;
class WindowOperationRequest_ParametersEntry_DoNotUse;
struct WindowOperationRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern WindowOperationRequest_ParametersEntry_DoNotUseDefaultTypeInternal _WindowOperationRequest_ParametersEntry_DoNotUse_default_instance_;
class WindowResizeEvent;
struct WindowResizeEventDefaultTypeInternal;
extern WindowResizeEventDefaultTypeInternal _WindowResizeEvent_default_instance_;
}  // namespace ui
}  // namespace vaelix
PROTOBUF_NAMESPACE_OPEN
template<> ::vaelix::ui::FileDownloadEvent* Arena::CreateMaybeMessage<::vaelix::ui::FileDownloadEvent>(Arena*);
template<> ::vaelix::ui::FocusChangeEvent* Arena::CreateMaybeMessage<::vaelix::ui::FocusChangeEvent>(Arena*);
template<> ::vaelix::ui::InputEvent* Arena::CreateMaybeMessage<::vaelix::ui::InputEvent>(Arena*);
template<> ::vaelix::ui::KeyboardEvent* Arena::CreateMaybeMessage<::vaelix::ui::KeyboardEvent>(Arena*);
template<> ::vaelix::ui::MouseEvent* Arena::CreateMaybeMessage<::vaelix::ui::MouseEvent>(Arena*);
template<> ::vaelix::ui::NavigationRequest* Arena::CreateMaybeMessage<::vaelix::ui::NavigationRequest>(Arena*);
template<> ::vaelix::ui::PermissionRequest* Arena::CreateMaybeMessage<::vaelix::ui::PermissionRequest>(Arena*);
template<> ::vaelix::ui::ShortcutEvent* Arena::CreateMaybeMessage<::vaelix::ui::ShortcutEvent>(Arena*);
template<> ::vaelix::ui::TabEvent* Arena::CreateMaybeMessage<::vaelix::ui::TabEvent>(Arena*);
template<> ::vaelix::ui::TabOperationRequest* Arena::CreateMaybeMessage<::vaelix::ui::TabOperationRequest>(Arena*);
template<> ::vaelix::ui::TabOperationRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::ui::TabOperationRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::vaelix::ui::TabStateInfo* Arena::CreateMaybeMessage<::vaelix::ui::TabStateInfo>(Arena*);
template<> ::vaelix::ui::TabStatesRequest* Arena::CreateMaybeMessage<::vaelix::ui::TabStatesRequest>(Arena*);
template<> ::vaelix::ui::ThemeChangeEvent* Arena::CreateMaybeMessage<::vaelix::ui::ThemeChangeEvent>(Arena*);
template<> ::vaelix::ui::UIStateQuery* Arena::CreateMaybeMessage<::vaelix::ui::UIStateQuery>(Arena*);
template<> ::vaelix::ui::UIStateUpdate* Arena::CreateMaybeMessage<::vaelix::ui::UIStateUpdate>(Arena*);
template<> ::vaelix::ui::UIStateUpdate_UiStateEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::ui::UIStateUpdate_UiStateEntry_DoNotUse>(Arena*);
template<> ::vaelix::ui::WindowEvent* Arena::CreateMaybeMessage<::vaelix::ui::WindowEvent>(Arena*);
template<> ::vaelix::ui::WindowInfo* Arena::CreateMaybeMessage<::vaelix::ui::WindowInfo>(Arena*);
template<> ::vaelix::ui::WindowInfoRequest* Arena::CreateMaybeMessage<::vaelix::ui::WindowInfoRequest>(Arena*);
template<> ::vaelix::ui::WindowMoveEvent* Arena::CreateMaybeMessage<::vaelix::ui::WindowMoveEvent>(Arena*);
template<> ::vaelix::ui::WindowOperationRequest* Arena::CreateMaybeMessage<::vaelix::ui::WindowOperationRequest>(Arena*);
template<> ::vaelix::ui::WindowOperationRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::ui::WindowOperationRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::vaelix::ui::WindowResizeEvent* Arena::CreateMaybeMessage<::vaelix::ui::WindowResizeEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vaelix {
namespace ui {

// ===================================================================

class WindowInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowInfo) */ {
 public:
  inline WindowInfo() : WindowInfo(nullptr) {}
  ~WindowInfo() override;
  explicit constexpr WindowInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowInfo(const WindowInfo& from);
  WindowInfo(WindowInfo&& from) noexcept
    : WindowInfo() {
    *this = ::std::move(from);
  }

  inline WindowInfo& operator=(const WindowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowInfo& operator=(WindowInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowInfo* internal_default_instance() {
    return reinterpret_cast<const WindowInfo*>(
               &_WindowInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WindowInfo& a, WindowInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowInfo";
  }
  protected:
  explicit WindowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 6,
    kWindowIdFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kIsFullscreenFieldNumber = 4,
    kIsMaximizedFieldNumber = 5,
    kAlwaysOnTopFieldNumber = 10,
    kScreenXFieldNumber = 7,
    kScreenYFieldNumber = 8,
    kOpacityFieldNumber = 9,
  };
  // string title = 6;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 width = 2;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // bool is_fullscreen = 4;
  void clear_is_fullscreen();
  bool is_fullscreen() const;
  void set_is_fullscreen(bool value);
  private:
  bool _internal_is_fullscreen() const;
  void _internal_set_is_fullscreen(bool value);
  public:

  // bool is_maximized = 5;
  void clear_is_maximized();
  bool is_maximized() const;
  void set_is_maximized(bool value);
  private:
  bool _internal_is_maximized() const;
  void _internal_set_is_maximized(bool value);
  public:

  // bool always_on_top = 10;
  void clear_always_on_top();
  bool always_on_top() const;
  void set_always_on_top(bool value);
  private:
  bool _internal_always_on_top() const;
  void _internal_set_always_on_top(bool value);
  public:

  // int32 screen_x = 7;
  void clear_screen_x();
  int32_t screen_x() const;
  void set_screen_x(int32_t value);
  private:
  int32_t _internal_screen_x() const;
  void _internal_set_screen_x(int32_t value);
  public:

  // int32 screen_y = 8;
  void clear_screen_y();
  int32_t screen_y() const;
  void set_screen_y(int32_t value);
  private:
  int32_t _internal_screen_y() const;
  void _internal_set_screen_y(int32_t value);
  public:

  // double opacity = 9;
  void clear_opacity();
  double opacity() const;
  void set_opacity(double value);
  private:
  double _internal_opacity() const;
  void _internal_set_opacity(double value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  int32_t window_id_;
  int32_t width_;
  int32_t height_;
  bool is_fullscreen_;
  bool is_maximized_;
  bool always_on_top_;
  int32_t screen_x_;
  int32_t screen_y_;
  double opacity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TabStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.TabStateInfo) */ {
 public:
  inline TabStateInfo() : TabStateInfo(nullptr) {}
  ~TabStateInfo() override;
  explicit constexpr TabStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabStateInfo(const TabStateInfo& from);
  TabStateInfo(TabStateInfo&& from) noexcept
    : TabStateInfo() {
    *this = ::std::move(from);
  }

  inline TabStateInfo& operator=(const TabStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabStateInfo& operator=(TabStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabStateInfo* internal_default_instance() {
    return reinterpret_cast<const TabStateInfo*>(
               &_TabStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TabStateInfo& a, TabStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TabStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.TabStateInfo";
  }
  protected:
  explicit TabStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kUrlFieldNumber = 3,
    kFaviconFieldNumber = 7,
    kStatusFieldNumber = 9,
    kTabIdFieldNumber = 1,
    kIsActiveFieldNumber = 4,
    kIsLoadingFieldNumber = 5,
    kIsPinnedFieldNumber = 6,
    kUnreadCountFieldNumber = 8,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes favicon = 7;
  void clear_favicon();
  const std::string& favicon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_favicon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_favicon();
  PROTOBUF_NODISCARD std::string* release_favicon();
  void set_allocated_favicon(std::string* favicon);
  private:
  const std::string& _internal_favicon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon(const std::string& value);
  std::string* _internal_mutable_favicon();
  public:

  // string status = 9;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool is_active = 4;
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // bool is_loading = 5;
  void clear_is_loading();
  bool is_loading() const;
  void set_is_loading(bool value);
  private:
  bool _internal_is_loading() const;
  void _internal_set_is_loading(bool value);
  public:

  // bool is_pinned = 6;
  void clear_is_pinned();
  bool is_pinned() const;
  void set_is_pinned(bool value);
  private:
  bool _internal_is_pinned() const;
  void _internal_set_is_pinned(bool value);
  public:

  // int32 unread_count = 8;
  void clear_unread_count();
  int32_t unread_count() const;
  void set_unread_count(int32_t value);
  private:
  int32_t _internal_unread_count() const;
  void _internal_set_unread_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.TabStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  int32_t tab_id_;
  bool is_active_;
  bool is_loading_;
  bool is_pinned_;
  int32_t unread_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WindowResizeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowResizeEvent) */ {
 public:
  inline WindowResizeEvent() : WindowResizeEvent(nullptr) {}
  ~WindowResizeEvent() override;
  explicit constexpr WindowResizeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowResizeEvent(const WindowResizeEvent& from);
  WindowResizeEvent(WindowResizeEvent&& from) noexcept
    : WindowResizeEvent() {
    *this = ::std::move(from);
  }

  inline WindowResizeEvent& operator=(const WindowResizeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowResizeEvent& operator=(WindowResizeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowResizeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowResizeEvent* internal_default_instance() {
    return reinterpret_cast<const WindowResizeEvent*>(
               &_WindowResizeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WindowResizeEvent& a, WindowResizeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowResizeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowResizeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowResizeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowResizeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowResizeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowResizeEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowResizeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowResizeEvent";
  }
  protected:
  explicit WindowResizeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 1,
    kNewWidthFieldNumber = 2,
    kNewHeightFieldNumber = 3,
    kOldWidthFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kOldHeightFieldNumber = 5,
  };
  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 new_width = 2;
  void clear_new_width();
  int32_t new_width() const;
  void set_new_width(int32_t value);
  private:
  int32_t _internal_new_width() const;
  void _internal_set_new_width(int32_t value);
  public:

  // int32 new_height = 3;
  void clear_new_height();
  int32_t new_height() const;
  void set_new_height(int32_t value);
  private:
  int32_t _internal_new_height() const;
  void _internal_set_new_height(int32_t value);
  public:

  // int32 old_width = 4;
  void clear_old_width();
  int32_t old_width() const;
  void set_old_width(int32_t value);
  private:
  int32_t _internal_old_width() const;
  void _internal_set_old_width(int32_t value);
  public:

  // int64 timestamp = 6;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 old_height = 5;
  void clear_old_height();
  int32_t old_height() const;
  void set_old_height(int32_t value);
  private:
  int32_t _internal_old_height() const;
  void _internal_set_old_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowResizeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  int32_t new_width_;
  int32_t new_height_;
  int32_t old_width_;
  int64_t timestamp_;
  int32_t old_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WindowMoveEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowMoveEvent) */ {
 public:
  inline WindowMoveEvent() : WindowMoveEvent(nullptr) {}
  ~WindowMoveEvent() override;
  explicit constexpr WindowMoveEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowMoveEvent(const WindowMoveEvent& from);
  WindowMoveEvent(WindowMoveEvent&& from) noexcept
    : WindowMoveEvent() {
    *this = ::std::move(from);
  }

  inline WindowMoveEvent& operator=(const WindowMoveEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowMoveEvent& operator=(WindowMoveEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowMoveEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowMoveEvent* internal_default_instance() {
    return reinterpret_cast<const WindowMoveEvent*>(
               &_WindowMoveEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WindowMoveEvent& a, WindowMoveEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowMoveEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowMoveEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowMoveEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowMoveEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowMoveEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowMoveEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowMoveEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowMoveEvent";
  }
  protected:
  explicit WindowMoveEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 1,
    kNewXFieldNumber = 2,
    kNewYFieldNumber = 3,
    kOldXFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kOldYFieldNumber = 5,
  };
  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 new_x = 2;
  void clear_new_x();
  int32_t new_x() const;
  void set_new_x(int32_t value);
  private:
  int32_t _internal_new_x() const;
  void _internal_set_new_x(int32_t value);
  public:

  // int32 new_y = 3;
  void clear_new_y();
  int32_t new_y() const;
  void set_new_y(int32_t value);
  private:
  int32_t _internal_new_y() const;
  void _internal_set_new_y(int32_t value);
  public:

  // int32 old_x = 4;
  void clear_old_x();
  int32_t old_x() const;
  void set_old_x(int32_t value);
  private:
  int32_t _internal_old_x() const;
  void _internal_set_old_x(int32_t value);
  public:

  // int64 timestamp = 6;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 old_y = 5;
  void clear_old_y();
  int32_t old_y() const;
  void set_old_y(int32_t value);
  private:
  int32_t _internal_old_y() const;
  void _internal_set_old_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowMoveEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  int32_t new_x_;
  int32_t new_y_;
  int32_t old_x_;
  int64_t timestamp_;
  int32_t old_y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class KeyboardEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.KeyboardEvent) */ {
 public:
  inline KeyboardEvent() : KeyboardEvent(nullptr) {}
  ~KeyboardEvent() override;
  explicit constexpr KeyboardEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyboardEvent(const KeyboardEvent& from);
  KeyboardEvent(KeyboardEvent&& from) noexcept
    : KeyboardEvent() {
    *this = ::std::move(from);
  }

  inline KeyboardEvent& operator=(const KeyboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardEvent& operator=(KeyboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyboardEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyboardEvent* internal_default_instance() {
    return reinterpret_cast<const KeyboardEvent*>(
               &_KeyboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeyboardEvent& a, KeyboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyboardEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyboardEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyboardEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyboardEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyboardEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.KeyboardEvent";
  }
  protected:
  explicit KeyboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyCodeFieldNumber = 3,
    kKeyNameFieldNumber = 4,
    kWindowIdFieldNumber = 1,
    kTabIdFieldNumber = 2,
    kIsPressedFieldNumber = 5,
    kIsCtrlFieldNumber = 6,
    kIsAltFieldNumber = 7,
    kIsShiftFieldNumber = 8,
    kIsMetaFieldNumber = 9,
    kRepeatCountFieldNumber = 10,
  };
  // string key_code = 3;
  void clear_key_code();
  const std::string& key_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_code();
  PROTOBUF_NODISCARD std::string* release_key_code();
  void set_allocated_key_code(std::string* key_code);
  private:
  const std::string& _internal_key_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_code(const std::string& value);
  std::string* _internal_mutable_key_code();
  public:

  // string key_name = 4;
  void clear_key_name();
  const std::string& key_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_name();
  PROTOBUF_NODISCARD std::string* release_key_name();
  void set_allocated_key_name(std::string* key_name);
  private:
  const std::string& _internal_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_name(const std::string& value);
  std::string* _internal_mutable_key_name();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool is_pressed = 5;
  void clear_is_pressed();
  bool is_pressed() const;
  void set_is_pressed(bool value);
  private:
  bool _internal_is_pressed() const;
  void _internal_set_is_pressed(bool value);
  public:

  // bool is_ctrl = 6;
  void clear_is_ctrl();
  bool is_ctrl() const;
  void set_is_ctrl(bool value);
  private:
  bool _internal_is_ctrl() const;
  void _internal_set_is_ctrl(bool value);
  public:

  // bool is_alt = 7;
  void clear_is_alt();
  bool is_alt() const;
  void set_is_alt(bool value);
  private:
  bool _internal_is_alt() const;
  void _internal_set_is_alt(bool value);
  public:

  // bool is_shift = 8;
  void clear_is_shift();
  bool is_shift() const;
  void set_is_shift(bool value);
  private:
  bool _internal_is_shift() const;
  void _internal_set_is_shift(bool value);
  public:

  // bool is_meta = 9;
  void clear_is_meta();
  bool is_meta() const;
  void set_is_meta(bool value);
  private:
  bool _internal_is_meta() const;
  void _internal_set_is_meta(bool value);
  public:

  // int32 repeat_count = 10;
  void clear_repeat_count();
  int32_t repeat_count() const;
  void set_repeat_count(int32_t value);
  private:
  int32_t _internal_repeat_count() const;
  void _internal_set_repeat_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.KeyboardEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
  int32_t window_id_;
  int32_t tab_id_;
  bool is_pressed_;
  bool is_ctrl_;
  bool is_alt_;
  bool is_shift_;
  bool is_meta_;
  int32_t repeat_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class MouseEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.MouseEvent) */ {
 public:
  inline MouseEvent() : MouseEvent(nullptr) {}
  ~MouseEvent() override;
  explicit constexpr MouseEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseEvent(const MouseEvent& from);
  MouseEvent(MouseEvent&& from) noexcept
    : MouseEvent() {
    *this = ::std::move(from);
  }

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEvent& operator=(MouseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseEvent* internal_default_instance() {
    return reinterpret_cast<const MouseEvent*>(
               &_MouseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MouseEvent& a, MouseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MouseEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MouseEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MouseEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.MouseEvent";
  }
  protected:
  explicit MouseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonFieldNumber = 5,
    kWindowIdFieldNumber = 1,
    kTabIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kIsPressedFieldNumber = 6,
    kClickCountFieldNumber = 7,
    kWheelDeltaFieldNumber = 8,
  };
  // string button = 5;
  void clear_button();
  const std::string& button() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_button(ArgT0&& arg0, ArgT... args);
  std::string* mutable_button();
  PROTOBUF_NODISCARD std::string* release_button();
  void set_allocated_button(std::string* button);
  private:
  const std::string& _internal_button() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_button(const std::string& value);
  std::string* _internal_mutable_button();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // double x = 3;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 4;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // bool is_pressed = 6;
  void clear_is_pressed();
  bool is_pressed() const;
  void set_is_pressed(bool value);
  private:
  bool _internal_is_pressed() const;
  void _internal_set_is_pressed(bool value);
  public:

  // int32 click_count = 7;
  void clear_click_count();
  int32_t click_count() const;
  void set_click_count(int32_t value);
  private:
  int32_t _internal_click_count() const;
  void _internal_set_click_count(int32_t value);
  public:

  // int32 wheel_delta = 8;
  void clear_wheel_delta();
  int32_t wheel_delta() const;
  void set_wheel_delta(int32_t value);
  private:
  int32_t _internal_wheel_delta() const;
  void _internal_set_wheel_delta(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.MouseEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr button_;
  int32_t window_id_;
  int32_t tab_id_;
  double x_;
  double y_;
  bool is_pressed_;
  int32_t click_count_;
  int32_t wheel_delta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class NavigationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.NavigationRequest) */ {
 public:
  inline NavigationRequest() : NavigationRequest(nullptr) {}
  ~NavigationRequest() override;
  explicit constexpr NavigationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationRequest(const NavigationRequest& from);
  NavigationRequest(NavigationRequest&& from) noexcept
    : NavigationRequest() {
    *this = ::std::move(from);
  }

  inline NavigationRequest& operator=(const NavigationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationRequest& operator=(NavigationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationRequest* internal_default_instance() {
    return reinterpret_cast<const NavigationRequest*>(
               &_NavigationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NavigationRequest& a, NavigationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NavigationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.NavigationRequest";
  }
  protected:
  explicit NavigationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 3,
    kWindowIdFieldNumber = 1,
    kTabIdFieldNumber = 2,
    kNewTabFieldNumber = 4,
    kBackgroundTabFieldNumber = 5,
    kForceReloadFieldNumber = 6,
  };
  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool new_tab = 4;
  void clear_new_tab();
  bool new_tab() const;
  void set_new_tab(bool value);
  private:
  bool _internal_new_tab() const;
  void _internal_set_new_tab(bool value);
  public:

  // bool background_tab = 5;
  void clear_background_tab();
  bool background_tab() const;
  void set_background_tab(bool value);
  private:
  bool _internal_background_tab() const;
  void _internal_set_background_tab(bool value);
  public:

  // bool force_reload = 6;
  void clear_force_reload();
  bool force_reload() const;
  void set_force_reload(bool value);
  private:
  bool _internal_force_reload() const;
  void _internal_set_force_reload(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.NavigationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int32_t window_id_;
  int32_t tab_id_;
  bool new_tab_;
  bool background_tab_;
  bool force_reload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TabOperationRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabOperationRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabOperationRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TabOperationRequest_ParametersEntry_DoNotUse();
  explicit constexpr TabOperationRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TabOperationRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TabOperationRequest_ParametersEntry_DoNotUse& other);
  static const TabOperationRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TabOperationRequest_ParametersEntry_DoNotUse*>(&_TabOperationRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.TabOperationRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.TabOperationRequest.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TabOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.TabOperationRequest) */ {
 public:
  inline TabOperationRequest() : TabOperationRequest(nullptr) {}
  ~TabOperationRequest() override;
  explicit constexpr TabOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabOperationRequest(const TabOperationRequest& from);
  TabOperationRequest(TabOperationRequest&& from) noexcept
    : TabOperationRequest() {
    *this = ::std::move(from);
  }

  inline TabOperationRequest& operator=(const TabOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabOperationRequest& operator=(TabOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabOperationRequest* internal_default_instance() {
    return reinterpret_cast<const TabOperationRequest*>(
               &_TabOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TabOperationRequest& a, TabOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TabOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabOperationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.TabOperationRequest";
  }
  protected:
  explicit TabOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kOperationFieldNumber = 3,
    kWindowIdFieldNumber = 1,
    kTabIdFieldNumber = 2,
  };
  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string operation = 3;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.TabOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TabOperationRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  int32_t window_id_;
  int32_t tab_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WindowOperationRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WindowOperationRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WindowOperationRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WindowOperationRequest_ParametersEntry_DoNotUse();
  explicit constexpr WindowOperationRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WindowOperationRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WindowOperationRequest_ParametersEntry_DoNotUse& other);
  static const WindowOperationRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WindowOperationRequest_ParametersEntry_DoNotUse*>(&_WindowOperationRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.WindowOperationRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.WindowOperationRequest.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WindowOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowOperationRequest) */ {
 public:
  inline WindowOperationRequest() : WindowOperationRequest(nullptr) {}
  ~WindowOperationRequest() override;
  explicit constexpr WindowOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowOperationRequest(const WindowOperationRequest& from);
  WindowOperationRequest(WindowOperationRequest&& from) noexcept
    : WindowOperationRequest() {
    *this = ::std::move(from);
  }

  inline WindowOperationRequest& operator=(const WindowOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowOperationRequest& operator=(WindowOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowOperationRequest* internal_default_instance() {
    return reinterpret_cast<const WindowOperationRequest*>(
               &_WindowOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WindowOperationRequest& a, WindowOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowOperationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowOperationRequest";
  }
  protected:
  explicit WindowOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kOperationFieldNumber = 2,
    kWindowIdFieldNumber = 1,
  };
  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string operation = 2;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WindowOperationRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  int32_t window_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ThemeChangeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.ThemeChangeEvent) */ {
 public:
  inline ThemeChangeEvent() : ThemeChangeEvent(nullptr) {}
  ~ThemeChangeEvent() override;
  explicit constexpr ThemeChangeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemeChangeEvent(const ThemeChangeEvent& from);
  ThemeChangeEvent(ThemeChangeEvent&& from) noexcept
    : ThemeChangeEvent() {
    *this = ::std::move(from);
  }

  inline ThemeChangeEvent& operator=(const ThemeChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeChangeEvent& operator=(ThemeChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemeChangeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemeChangeEvent* internal_default_instance() {
    return reinterpret_cast<const ThemeChangeEvent*>(
               &_ThemeChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ThemeChangeEvent& a, ThemeChangeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeChangeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeChangeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThemeChangeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThemeChangeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThemeChangeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ThemeChangeEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeChangeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.ThemeChangeEvent";
  }
  protected:
  explicit ThemeChangeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThemeNameFieldNumber = 4,
    kVariantFieldNumber = 5,
    kAnimationEnabledFieldNumber = 6,
    kAnimationSpeedFieldNumber = 7,
  };
  // string theme_name = 4;
  void clear_theme_name();
  const std::string& theme_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_theme_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_theme_name();
  PROTOBUF_NODISCARD std::string* release_theme_name();
  void set_allocated_theme_name(std::string* theme_name);
  private:
  const std::string& _internal_theme_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_theme_name(const std::string& value);
  std::string* _internal_mutable_theme_name();
  public:

  // string variant = 5;
  void clear_variant();
  const std::string& variant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variant();
  PROTOBUF_NODISCARD std::string* release_variant();
  void set_allocated_variant(std::string* variant);
  private:
  const std::string& _internal_variant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variant(const std::string& value);
  std::string* _internal_mutable_variant();
  public:

  // bool animation_enabled = 6;
  void clear_animation_enabled();
  bool animation_enabled() const;
  void set_animation_enabled(bool value);
  private:
  bool _internal_animation_enabled() const;
  void _internal_set_animation_enabled(bool value);
  public:

  // double animation_speed = 7;
  void clear_animation_speed();
  double animation_speed() const;
  void set_animation_speed(double value);
  private:
  double _internal_animation_speed() const;
  void _internal_set_animation_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.ThemeChangeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr theme_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variant_;
  bool animation_enabled_;
  double animation_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class FocusChangeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.FocusChangeEvent) */ {
 public:
  inline FocusChangeEvent() : FocusChangeEvent(nullptr) {}
  ~FocusChangeEvent() override;
  explicit constexpr FocusChangeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FocusChangeEvent(const FocusChangeEvent& from);
  FocusChangeEvent(FocusChangeEvent&& from) noexcept
    : FocusChangeEvent() {
    *this = ::std::move(from);
  }

  inline FocusChangeEvent& operator=(const FocusChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusChangeEvent& operator=(FocusChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusChangeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusChangeEvent* internal_default_instance() {
    return reinterpret_cast<const FocusChangeEvent*>(
               &_FocusChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FocusChangeEvent& a, FocusChangeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusChangeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusChangeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusChangeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusChangeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FocusChangeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FocusChangeEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FocusChangeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.FocusChangeEvent";
  }
  protected:
  explicit FocusChangeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 1,
    kOldTabIdFieldNumber = 2,
    kNewTabIdFieldNumber = 3,
    kWindowFocusFieldNumber = 4,
  };
  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 old_tab_id = 2;
  void clear_old_tab_id();
  int32_t old_tab_id() const;
  void set_old_tab_id(int32_t value);
  private:
  int32_t _internal_old_tab_id() const;
  void _internal_set_old_tab_id(int32_t value);
  public:

  // int32 new_tab_id = 3;
  void clear_new_tab_id();
  int32_t new_tab_id() const;
  void set_new_tab_id(int32_t value);
  private:
  int32_t _internal_new_tab_id() const;
  void _internal_set_new_tab_id(int32_t value);
  public:

  // bool window_focus = 4;
  void clear_window_focus();
  bool window_focus() const;
  void set_window_focus(bool value);
  private:
  bool _internal_window_focus() const;
  void _internal_set_window_focus(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.FocusChangeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  int32_t old_tab_id_;
  int32_t new_tab_id_;
  bool window_focus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class UIStateUpdate_UiStateEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UIStateUpdate_UiStateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UIStateUpdate_UiStateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UIStateUpdate_UiStateEntry_DoNotUse();
  explicit constexpr UIStateUpdate_UiStateEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UIStateUpdate_UiStateEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UIStateUpdate_UiStateEntry_DoNotUse& other);
  static const UIStateUpdate_UiStateEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UIStateUpdate_UiStateEntry_DoNotUse*>(&_UIStateUpdate_UiStateEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.UIStateUpdate.UiStateEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.ui.UIStateUpdate.UiStateEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class UIStateUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.UIStateUpdate) */ {
 public:
  inline UIStateUpdate() : UIStateUpdate(nullptr) {}
  ~UIStateUpdate() override;
  explicit constexpr UIStateUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIStateUpdate(const UIStateUpdate& from);
  UIStateUpdate(UIStateUpdate&& from) noexcept
    : UIStateUpdate() {
    *this = ::std::move(from);
  }

  inline UIStateUpdate& operator=(const UIStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIStateUpdate& operator=(UIStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIStateUpdate* internal_default_instance() {
    return reinterpret_cast<const UIStateUpdate*>(
               &_UIStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UIStateUpdate& a, UIStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(UIStateUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIStateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIStateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIStateUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIStateUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UIStateUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIStateUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.UIStateUpdate";
  }
  protected:
  explicit UIStateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTabsFieldNumber = 2,
    kUiStateFieldNumber = 7,
    kStatusMessageFieldNumber = 4,
    kWindowInfoFieldNumber = 3,
    kWindowIdFieldNumber = 1,
    kLoadingIndicatorFieldNumber = 5,
    kProgressIndicatorFieldNumber = 6,
  };
  // repeated .vaelix.ui.TabStateInfo tabs = 2;
  int tabs_size() const;
  private:
  int _internal_tabs_size() const;
  public:
  void clear_tabs();
  ::vaelix::ui::TabStateInfo* mutable_tabs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::ui::TabStateInfo >*
      mutable_tabs();
  private:
  const ::vaelix::ui::TabStateInfo& _internal_tabs(int index) const;
  ::vaelix::ui::TabStateInfo* _internal_add_tabs();
  public:
  const ::vaelix::ui::TabStateInfo& tabs(int index) const;
  ::vaelix::ui::TabStateInfo* add_tabs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::ui::TabStateInfo >&
      tabs() const;

  // map<string, string> ui_state = 7;
  int ui_state_size() const;
  private:
  int _internal_ui_state_size() const;
  public:
  void clear_ui_state();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_ui_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_ui_state();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      ui_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_ui_state();

  // string status_message = 4;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // .vaelix.ui.WindowInfo window_info = 3;
  bool has_window_info() const;
  private:
  bool _internal_has_window_info() const;
  public:
  void clear_window_info();
  const ::vaelix::ui::WindowInfo& window_info() const;
  PROTOBUF_NODISCARD ::vaelix::ui::WindowInfo* release_window_info();
  ::vaelix::ui::WindowInfo* mutable_window_info();
  void set_allocated_window_info(::vaelix::ui::WindowInfo* window_info);
  private:
  const ::vaelix::ui::WindowInfo& _internal_window_info() const;
  ::vaelix::ui::WindowInfo* _internal_mutable_window_info();
  public:
  void unsafe_arena_set_allocated_window_info(
      ::vaelix::ui::WindowInfo* window_info);
  ::vaelix::ui::WindowInfo* unsafe_arena_release_window_info();

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // bool loading_indicator = 5;
  void clear_loading_indicator();
  bool loading_indicator() const;
  void set_loading_indicator(bool value);
  private:
  bool _internal_loading_indicator() const;
  void _internal_set_loading_indicator(bool value);
  public:

  // double progress_indicator = 6;
  void clear_progress_indicator();
  double progress_indicator() const;
  void set_progress_indicator(double value);
  private:
  double _internal_progress_indicator() const;
  void _internal_set_progress_indicator(double value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.UIStateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::ui::TabStateInfo > tabs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      UIStateUpdate_UiStateEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> ui_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
  ::vaelix::ui::WindowInfo* window_info_;
  int32_t window_id_;
  bool loading_indicator_;
  double progress_indicator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ShortcutEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.ShortcutEvent) */ {
 public:
  inline ShortcutEvent() : ShortcutEvent(nullptr) {}
  ~ShortcutEvent() override;
  explicit constexpr ShortcutEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShortcutEvent(const ShortcutEvent& from);
  ShortcutEvent(ShortcutEvent&& from) noexcept
    : ShortcutEvent() {
    *this = ::std::move(from);
  }

  inline ShortcutEvent& operator=(const ShortcutEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShortcutEvent& operator=(ShortcutEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShortcutEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShortcutEvent* internal_default_instance() {
    return reinterpret_cast<const ShortcutEvent*>(
               &_ShortcutEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ShortcutEvent& a, ShortcutEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ShortcutEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShortcutEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShortcutEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShortcutEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShortcutEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShortcutEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShortcutEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.ShortcutEvent";
  }
  protected:
  explicit ShortcutEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShortcutFieldNumber = 1,
    kWindowIdFieldNumber = 2,
    kConsumeFieldNumber = 3,
  };
  // string shortcut = 1;
  void clear_shortcut();
  const std::string& shortcut() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shortcut(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shortcut();
  PROTOBUF_NODISCARD std::string* release_shortcut();
  void set_allocated_shortcut(std::string* shortcut);
  private:
  const std::string& _internal_shortcut() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shortcut(const std::string& value);
  std::string* _internal_mutable_shortcut();
  public:

  // int32 window_id = 2;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // bool consume = 3;
  void clear_consume();
  bool consume() const;
  void set_consume(bool value);
  private:
  bool _internal_consume() const;
  void _internal_set_consume(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.ShortcutEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shortcut_;
  int32_t window_id_;
  bool consume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class PermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.PermissionRequest) */ {
 public:
  inline PermissionRequest() : PermissionRequest(nullptr) {}
  ~PermissionRequest() override;
  explicit constexpr PermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionRequest(const PermissionRequest& from);
  PermissionRequest(PermissionRequest&& from) noexcept
    : PermissionRequest() {
    *this = ::std::move(from);
  }

  inline PermissionRequest& operator=(const PermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionRequest& operator=(PermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionRequest* internal_default_instance() {
    return reinterpret_cast<const PermissionRequest*>(
               &_PermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PermissionRequest& a, PermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.PermissionRequest";
  }
  protected:
  explicit PermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionTypeFieldNumber = 3,
    kOriginFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kWindowIdFieldNumber = 1,
    kTabIdFieldNumber = 2,
  };
  // string permission_type = 3;
  void clear_permission_type();
  const std::string& permission_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_type();
  PROTOBUF_NODISCARD std::string* release_permission_type();
  void set_allocated_permission_type(std::string* permission_type);
  private:
  const std::string& _internal_permission_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_type(const std::string& value);
  std::string* _internal_mutable_permission_type();
  public:

  // string origin = 4;
  void clear_origin();
  const std::string& origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin();
  PROTOBUF_NODISCARD std::string* release_origin();
  void set_allocated_origin(std::string* origin);
  private:
  const std::string& _internal_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
  std::string* _internal_mutable_origin();
  public:

  // string details = 5;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 2;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.PermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
  int32_t window_id_;
  int32_t tab_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class FileDownloadEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.FileDownloadEvent) */ {
 public:
  inline FileDownloadEvent() : FileDownloadEvent(nullptr) {}
  ~FileDownloadEvent() override;
  explicit constexpr FileDownloadEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileDownloadEvent(const FileDownloadEvent& from);
  FileDownloadEvent(FileDownloadEvent&& from) noexcept
    : FileDownloadEvent() {
    *this = ::std::move(from);
  }

  inline FileDownloadEvent& operator=(const FileDownloadEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileDownloadEvent& operator=(FileDownloadEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileDownloadEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileDownloadEvent* internal_default_instance() {
    return reinterpret_cast<const FileDownloadEvent*>(
               &_FileDownloadEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FileDownloadEvent& a, FileDownloadEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FileDownloadEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileDownloadEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileDownloadEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileDownloadEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileDownloadEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileDownloadEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileDownloadEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.FileDownloadEvent";
  }
  protected:
  explicit FileDownloadEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kFilenameFieldNumber = 3,
    kContentTypeFieldNumber = 5,
    kTabIdFieldNumber = 1,
    kIsAutoDownloadFieldNumber = 6,
    kContentLengthFieldNumber = 4,
  };
  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string filename = 3;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string content_type = 5;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // int32 tab_id = 1;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // bool is_auto_download = 6;
  void clear_is_auto_download();
  bool is_auto_download() const;
  void set_is_auto_download(bool value);
  private:
  bool _internal_is_auto_download() const;
  void _internal_set_is_auto_download(bool value);
  public:

  // int64 content_length = 4;
  void clear_content_length();
  int64_t content_length() const;
  void set_content_length(int64_t value);
  private:
  int64_t _internal_content_length() const;
  void _internal_set_content_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.FileDownloadEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
  int32_t tab_id_;
  bool is_auto_download_;
  int64_t content_length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WindowEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowEvent) */ {
 public:
  inline WindowEvent() : WindowEvent(nullptr) {}
  ~WindowEvent() override;
  explicit constexpr WindowEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowEvent(const WindowEvent& from);
  WindowEvent(WindowEvent&& from) noexcept
    : WindowEvent() {
    *this = ::std::move(from);
  }

  inline WindowEvent& operator=(const WindowEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowEvent& operator=(WindowEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kResize = 1,
    kMove = 2,
    kFocusChange = 3,
    kThemeChange = 4,
    kWindowError = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const WindowEvent* internal_default_instance() {
    return reinterpret_cast<const WindowEvent*>(
               &_WindowEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WindowEvent& a, WindowEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowEvent";
  }
  protected:
  explicit WindowEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 6,
    kTimestampFieldNumber = 7,
    kResizeFieldNumber = 1,
    kMoveFieldNumber = 2,
    kFocusChangeFieldNumber = 3,
    kThemeChangeFieldNumber = 4,
    kWindowErrorFieldNumber = 5,
  };
  // int32 window_id = 6;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int64 timestamp = 7;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .vaelix.ui.WindowResizeEvent resize = 1;
  bool has_resize() const;
  private:
  bool _internal_has_resize() const;
  public:
  void clear_resize();
  const ::vaelix::ui::WindowResizeEvent& resize() const;
  PROTOBUF_NODISCARD ::vaelix::ui::WindowResizeEvent* release_resize();
  ::vaelix::ui::WindowResizeEvent* mutable_resize();
  void set_allocated_resize(::vaelix::ui::WindowResizeEvent* resize);
  private:
  const ::vaelix::ui::WindowResizeEvent& _internal_resize() const;
  ::vaelix::ui::WindowResizeEvent* _internal_mutable_resize();
  public:
  void unsafe_arena_set_allocated_resize(
      ::vaelix::ui::WindowResizeEvent* resize);
  ::vaelix::ui::WindowResizeEvent* unsafe_arena_release_resize();

  // .vaelix.ui.WindowMoveEvent move = 2;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::vaelix::ui::WindowMoveEvent& move() const;
  PROTOBUF_NODISCARD ::vaelix::ui::WindowMoveEvent* release_move();
  ::vaelix::ui::WindowMoveEvent* mutable_move();
  void set_allocated_move(::vaelix::ui::WindowMoveEvent* move);
  private:
  const ::vaelix::ui::WindowMoveEvent& _internal_move() const;
  ::vaelix::ui::WindowMoveEvent* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::vaelix::ui::WindowMoveEvent* move);
  ::vaelix::ui::WindowMoveEvent* unsafe_arena_release_move();

  // .vaelix.ui.FocusChangeEvent focus_change = 3;
  bool has_focus_change() const;
  private:
  bool _internal_has_focus_change() const;
  public:
  void clear_focus_change();
  const ::vaelix::ui::FocusChangeEvent& focus_change() const;
  PROTOBUF_NODISCARD ::vaelix::ui::FocusChangeEvent* release_focus_change();
  ::vaelix::ui::FocusChangeEvent* mutable_focus_change();
  void set_allocated_focus_change(::vaelix::ui::FocusChangeEvent* focus_change);
  private:
  const ::vaelix::ui::FocusChangeEvent& _internal_focus_change() const;
  ::vaelix::ui::FocusChangeEvent* _internal_mutable_focus_change();
  public:
  void unsafe_arena_set_allocated_focus_change(
      ::vaelix::ui::FocusChangeEvent* focus_change);
  ::vaelix::ui::FocusChangeEvent* unsafe_arena_release_focus_change();

  // .vaelix.ui.ThemeChangeEvent theme_change = 4;
  bool has_theme_change() const;
  private:
  bool _internal_has_theme_change() const;
  public:
  void clear_theme_change();
  const ::vaelix::ui::ThemeChangeEvent& theme_change() const;
  PROTOBUF_NODISCARD ::vaelix::ui::ThemeChangeEvent* release_theme_change();
  ::vaelix::ui::ThemeChangeEvent* mutable_theme_change();
  void set_allocated_theme_change(::vaelix::ui::ThemeChangeEvent* theme_change);
  private:
  const ::vaelix::ui::ThemeChangeEvent& _internal_theme_change() const;
  ::vaelix::ui::ThemeChangeEvent* _internal_mutable_theme_change();
  public:
  void unsafe_arena_set_allocated_theme_change(
      ::vaelix::ui::ThemeChangeEvent* theme_change);
  ::vaelix::ui::ThemeChangeEvent* unsafe_arena_release_theme_change();

  // string window_error = 5;
  bool has_window_error() const;
  private:
  bool _internal_has_window_error() const;
  public:
  void clear_window_error();
  const std::string& window_error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_window_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_window_error();
  PROTOBUF_NODISCARD std::string* release_window_error();
  void set_allocated_window_error(std::string* window_error);
  private:
  const std::string& _internal_window_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_window_error(const std::string& value);
  std::string* _internal_mutable_window_error();
  public:

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowEvent)
 private:
  class _Internal;
  void set_has_resize();
  void set_has_move();
  void set_has_focus_change();
  void set_has_theme_change();
  void set_has_window_error();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  int64_t timestamp_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vaelix::ui::WindowResizeEvent* resize_;
    ::vaelix::ui::WindowMoveEvent* move_;
    ::vaelix::ui::FocusChangeEvent* focus_change_;
    ::vaelix::ui::ThemeChangeEvent* theme_change_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr window_error_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TabEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.TabEvent) */ {
 public:
  inline TabEvent() : TabEvent(nullptr) {}
  ~TabEvent() override;
  explicit constexpr TabEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabEvent(const TabEvent& from);
  TabEvent(TabEvent&& from) noexcept
    : TabEvent() {
    *this = ::std::move(from);
  }

  inline TabEvent& operator=(const TabEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabEvent& operator=(TabEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kNavigation = 1,
    kOperation = 2,
    kDownload = 3,
    kTabError = 4,
    EVENT_NOT_SET = 0,
  };

  static inline const TabEvent* internal_default_instance() {
    return reinterpret_cast<const TabEvent*>(
               &_TabEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TabEvent& a, TabEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TabEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.TabEvent";
  }
  protected:
  explicit TabEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabIdFieldNumber = 5,
    kWindowIdFieldNumber = 6,
    kTimestampFieldNumber = 7,
    kNavigationFieldNumber = 1,
    kOperationFieldNumber = 2,
    kDownloadFieldNumber = 3,
    kTabErrorFieldNumber = 4,
  };
  // int32 tab_id = 5;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // int32 window_id = 6;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int64 timestamp = 7;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .vaelix.ui.NavigationRequest navigation = 1;
  bool has_navigation() const;
  private:
  bool _internal_has_navigation() const;
  public:
  void clear_navigation();
  const ::vaelix::ui::NavigationRequest& navigation() const;
  PROTOBUF_NODISCARD ::vaelix::ui::NavigationRequest* release_navigation();
  ::vaelix::ui::NavigationRequest* mutable_navigation();
  void set_allocated_navigation(::vaelix::ui::NavigationRequest* navigation);
  private:
  const ::vaelix::ui::NavigationRequest& _internal_navigation() const;
  ::vaelix::ui::NavigationRequest* _internal_mutable_navigation();
  public:
  void unsafe_arena_set_allocated_navigation(
      ::vaelix::ui::NavigationRequest* navigation);
  ::vaelix::ui::NavigationRequest* unsafe_arena_release_navigation();

  // .vaelix.ui.TabOperationRequest operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const ::vaelix::ui::TabOperationRequest& operation() const;
  PROTOBUF_NODISCARD ::vaelix::ui::TabOperationRequest* release_operation();
  ::vaelix::ui::TabOperationRequest* mutable_operation();
  void set_allocated_operation(::vaelix::ui::TabOperationRequest* operation);
  private:
  const ::vaelix::ui::TabOperationRequest& _internal_operation() const;
  ::vaelix::ui::TabOperationRequest* _internal_mutable_operation();
  public:
  void unsafe_arena_set_allocated_operation(
      ::vaelix::ui::TabOperationRequest* operation);
  ::vaelix::ui::TabOperationRequest* unsafe_arena_release_operation();

  // .vaelix.ui.FileDownloadEvent download = 3;
  bool has_download() const;
  private:
  bool _internal_has_download() const;
  public:
  void clear_download();
  const ::vaelix::ui::FileDownloadEvent& download() const;
  PROTOBUF_NODISCARD ::vaelix::ui::FileDownloadEvent* release_download();
  ::vaelix::ui::FileDownloadEvent* mutable_download();
  void set_allocated_download(::vaelix::ui::FileDownloadEvent* download);
  private:
  const ::vaelix::ui::FileDownloadEvent& _internal_download() const;
  ::vaelix::ui::FileDownloadEvent* _internal_mutable_download();
  public:
  void unsafe_arena_set_allocated_download(
      ::vaelix::ui::FileDownloadEvent* download);
  ::vaelix::ui::FileDownloadEvent* unsafe_arena_release_download();

  // string tab_error = 4;
  bool has_tab_error() const;
  private:
  bool _internal_has_tab_error() const;
  public:
  void clear_tab_error();
  const std::string& tab_error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tab_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tab_error();
  PROTOBUF_NODISCARD std::string* release_tab_error();
  void set_allocated_tab_error(std::string* tab_error);
  private:
  const std::string& _internal_tab_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_error(const std::string& value);
  std::string* _internal_mutable_tab_error();
  public:

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vaelix.ui.TabEvent)
 private:
  class _Internal;
  void set_has_navigation();
  void set_has_operation();
  void set_has_download();
  void set_has_tab_error();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t tab_id_;
  int32_t window_id_;
  int64_t timestamp_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vaelix::ui::NavigationRequest* navigation_;
    ::vaelix::ui::TabOperationRequest* operation_;
    ::vaelix::ui::FileDownloadEvent* download_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_error_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class InputEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.InputEvent) */ {
 public:
  inline InputEvent() : InputEvent(nullptr) {}
  ~InputEvent() override;
  explicit constexpr InputEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputEvent(const InputEvent& from);
  InputEvent(InputEvent&& from) noexcept
    : InputEvent() {
    *this = ::std::move(from);
  }

  inline InputEvent& operator=(const InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputEvent& operator=(InputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kKeyboard = 1,
    kMouse = 2,
    kShortcut = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const InputEvent* internal_default_instance() {
    return reinterpret_cast<const InputEvent*>(
               &_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InputEvent& a, InputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.InputEvent";
  }
  protected:
  explicit InputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kKeyboardFieldNumber = 1,
    kMouseFieldNumber = 2,
    kShortcutFieldNumber = 3,
  };
  // int32 window_id = 4;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int64 timestamp = 5;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .vaelix.ui.KeyboardEvent keyboard = 1;
  bool has_keyboard() const;
  private:
  bool _internal_has_keyboard() const;
  public:
  void clear_keyboard();
  const ::vaelix::ui::KeyboardEvent& keyboard() const;
  PROTOBUF_NODISCARD ::vaelix::ui::KeyboardEvent* release_keyboard();
  ::vaelix::ui::KeyboardEvent* mutable_keyboard();
  void set_allocated_keyboard(::vaelix::ui::KeyboardEvent* keyboard);
  private:
  const ::vaelix::ui::KeyboardEvent& _internal_keyboard() const;
  ::vaelix::ui::KeyboardEvent* _internal_mutable_keyboard();
  public:
  void unsafe_arena_set_allocated_keyboard(
      ::vaelix::ui::KeyboardEvent* keyboard);
  ::vaelix::ui::KeyboardEvent* unsafe_arena_release_keyboard();

  // .vaelix.ui.MouseEvent mouse = 2;
  bool has_mouse() const;
  private:
  bool _internal_has_mouse() const;
  public:
  void clear_mouse();
  const ::vaelix::ui::MouseEvent& mouse() const;
  PROTOBUF_NODISCARD ::vaelix::ui::MouseEvent* release_mouse();
  ::vaelix::ui::MouseEvent* mutable_mouse();
  void set_allocated_mouse(::vaelix::ui::MouseEvent* mouse);
  private:
  const ::vaelix::ui::MouseEvent& _internal_mouse() const;
  ::vaelix::ui::MouseEvent* _internal_mutable_mouse();
  public:
  void unsafe_arena_set_allocated_mouse(
      ::vaelix::ui::MouseEvent* mouse);
  ::vaelix::ui::MouseEvent* unsafe_arena_release_mouse();

  // .vaelix.ui.ShortcutEvent shortcut = 3;
  bool has_shortcut() const;
  private:
  bool _internal_has_shortcut() const;
  public:
  void clear_shortcut();
  const ::vaelix::ui::ShortcutEvent& shortcut() const;
  PROTOBUF_NODISCARD ::vaelix::ui::ShortcutEvent* release_shortcut();
  ::vaelix::ui::ShortcutEvent* mutable_shortcut();
  void set_allocated_shortcut(::vaelix::ui::ShortcutEvent* shortcut);
  private:
  const ::vaelix::ui::ShortcutEvent& _internal_shortcut() const;
  ::vaelix::ui::ShortcutEvent* _internal_mutable_shortcut();
  public:
  void unsafe_arena_set_allocated_shortcut(
      ::vaelix::ui::ShortcutEvent* shortcut);
  ::vaelix::ui::ShortcutEvent* unsafe_arena_release_shortcut();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vaelix.ui.InputEvent)
 private:
  class _Internal;
  void set_has_keyboard();
  void set_has_mouse();
  void set_has_shortcut();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  int64_t timestamp_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::vaelix::ui::KeyboardEvent* keyboard_;
    ::vaelix::ui::MouseEvent* mouse_;
    ::vaelix::ui::ShortcutEvent* shortcut_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class UIStateQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.UIStateQuery) */ {
 public:
  inline UIStateQuery() : UIStateQuery(nullptr) {}
  ~UIStateQuery() override;
  explicit constexpr UIStateQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIStateQuery(const UIStateQuery& from);
  UIStateQuery(UIStateQuery&& from) noexcept
    : UIStateQuery() {
    *this = ::std::move(from);
  }

  inline UIStateQuery& operator=(const UIStateQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIStateQuery& operator=(UIStateQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIStateQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIStateQuery* internal_default_instance() {
    return reinterpret_cast<const UIStateQuery*>(
               &_UIStateQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UIStateQuery& a, UIStateQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(UIStateQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIStateQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIStateQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIStateQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIStateQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UIStateQuery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIStateQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.UIStateQuery";
  }
  protected:
  explicit UIStateQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kWindowIdFieldNumber = 1,
  };
  // repeated string fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  const std::string& fields(int index) const;
  std::string* mutable_fields(int index);
  void set_fields(int index, const std::string& value);
  void set_fields(int index, std::string&& value);
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  std::string* add_fields();
  void add_fields(const std::string& value);
  void add_fields(std::string&& value);
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fields();
  private:
  const std::string& _internal_fields(int index) const;
  std::string* _internal_add_fields();
  public:

  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.UIStateQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fields_;
  int32_t window_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WindowInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.WindowInfoRequest) */ {
 public:
  inline WindowInfoRequest() : WindowInfoRequest(nullptr) {}
  ~WindowInfoRequest() override;
  explicit constexpr WindowInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowInfoRequest(const WindowInfoRequest& from);
  WindowInfoRequest(WindowInfoRequest&& from) noexcept
    : WindowInfoRequest() {
    *this = ::std::move(from);
  }

  inline WindowInfoRequest& operator=(const WindowInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowInfoRequest& operator=(WindowInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowInfoRequest* internal_default_instance() {
    return reinterpret_cast<const WindowInfoRequest*>(
               &_WindowInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WindowInfoRequest& a, WindowInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.WindowInfoRequest";
  }
  protected:
  explicit WindowInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 1,
  };
  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.WindowInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TabStatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.ui.TabStatesRequest) */ {
 public:
  inline TabStatesRequest() : TabStatesRequest(nullptr) {}
  ~TabStatesRequest() override;
  explicit constexpr TabStatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabStatesRequest(const TabStatesRequest& from);
  TabStatesRequest(TabStatesRequest&& from) noexcept
    : TabStatesRequest() {
    *this = ::std::move(from);
  }

  inline TabStatesRequest& operator=(const TabStatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabStatesRequest& operator=(TabStatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabStatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabStatesRequest* internal_default_instance() {
    return reinterpret_cast<const TabStatesRequest*>(
               &_TabStatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TabStatesRequest& a, TabStatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TabStatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabStatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabStatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabStatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabStatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabStatesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabStatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.ui.TabStatesRequest";
  }
  protected:
  explicit TabStatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowIdFieldNumber = 1,
    kIncludeInactiveFieldNumber = 2,
  };
  // int32 window_id = 1;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // bool include_inactive = 2;
  void clear_include_inactive();
  bool include_inactive() const;
  void set_include_inactive(bool value);
  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.ui.TabStatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_id_;
  bool include_inactive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ui_5fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WindowInfo

// int32 window_id = 1;
inline void WindowInfo::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowInfo::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowInfo::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.window_id)
  return _internal_window_id();
}
inline void WindowInfo::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowInfo::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.window_id)
}

// int32 width = 2;
inline void WindowInfo::clear_width() {
  width_ = 0;
}
inline int32_t WindowInfo::_internal_width() const {
  return width_;
}
inline int32_t WindowInfo::width() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.width)
  return _internal_width();
}
inline void WindowInfo::_internal_set_width(int32_t value) {
  
  width_ = value;
}
inline void WindowInfo::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.width)
}

// int32 height = 3;
inline void WindowInfo::clear_height() {
  height_ = 0;
}
inline int32_t WindowInfo::_internal_height() const {
  return height_;
}
inline int32_t WindowInfo::height() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.height)
  return _internal_height();
}
inline void WindowInfo::_internal_set_height(int32_t value) {
  
  height_ = value;
}
inline void WindowInfo::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.height)
}

// bool is_fullscreen = 4;
inline void WindowInfo::clear_is_fullscreen() {
  is_fullscreen_ = false;
}
inline bool WindowInfo::_internal_is_fullscreen() const {
  return is_fullscreen_;
}
inline bool WindowInfo::is_fullscreen() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.is_fullscreen)
  return _internal_is_fullscreen();
}
inline void WindowInfo::_internal_set_is_fullscreen(bool value) {
  
  is_fullscreen_ = value;
}
inline void WindowInfo::set_is_fullscreen(bool value) {
  _internal_set_is_fullscreen(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.is_fullscreen)
}

// bool is_maximized = 5;
inline void WindowInfo::clear_is_maximized() {
  is_maximized_ = false;
}
inline bool WindowInfo::_internal_is_maximized() const {
  return is_maximized_;
}
inline bool WindowInfo::is_maximized() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.is_maximized)
  return _internal_is_maximized();
}
inline void WindowInfo::_internal_set_is_maximized(bool value) {
  
  is_maximized_ = value;
}
inline void WindowInfo::set_is_maximized(bool value) {
  _internal_set_is_maximized(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.is_maximized)
}

// string title = 6;
inline void WindowInfo::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& WindowInfo::title() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.title)
}
inline std::string* WindowInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowInfo.title)
  return _s;
}
inline const std::string& WindowInfo::_internal_title() const {
  return title_.Get();
}
inline void WindowInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WindowInfo::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WindowInfo::release_title() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowInfo.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WindowInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.WindowInfo.title)
}

// int32 screen_x = 7;
inline void WindowInfo::clear_screen_x() {
  screen_x_ = 0;
}
inline int32_t WindowInfo::_internal_screen_x() const {
  return screen_x_;
}
inline int32_t WindowInfo::screen_x() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.screen_x)
  return _internal_screen_x();
}
inline void WindowInfo::_internal_set_screen_x(int32_t value) {
  
  screen_x_ = value;
}
inline void WindowInfo::set_screen_x(int32_t value) {
  _internal_set_screen_x(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.screen_x)
}

// int32 screen_y = 8;
inline void WindowInfo::clear_screen_y() {
  screen_y_ = 0;
}
inline int32_t WindowInfo::_internal_screen_y() const {
  return screen_y_;
}
inline int32_t WindowInfo::screen_y() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.screen_y)
  return _internal_screen_y();
}
inline void WindowInfo::_internal_set_screen_y(int32_t value) {
  
  screen_y_ = value;
}
inline void WindowInfo::set_screen_y(int32_t value) {
  _internal_set_screen_y(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.screen_y)
}

// double opacity = 9;
inline void WindowInfo::clear_opacity() {
  opacity_ = 0;
}
inline double WindowInfo::_internal_opacity() const {
  return opacity_;
}
inline double WindowInfo::opacity() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.opacity)
  return _internal_opacity();
}
inline void WindowInfo::_internal_set_opacity(double value) {
  
  opacity_ = value;
}
inline void WindowInfo::set_opacity(double value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.opacity)
}

// bool always_on_top = 10;
inline void WindowInfo::clear_always_on_top() {
  always_on_top_ = false;
}
inline bool WindowInfo::_internal_always_on_top() const {
  return always_on_top_;
}
inline bool WindowInfo::always_on_top() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfo.always_on_top)
  return _internal_always_on_top();
}
inline void WindowInfo::_internal_set_always_on_top(bool value) {
  
  always_on_top_ = value;
}
inline void WindowInfo::set_always_on_top(bool value) {
  _internal_set_always_on_top(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfo.always_on_top)
}

// -------------------------------------------------------------------

// TabStateInfo

// int32 tab_id = 1;
inline void TabStateInfo::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabStateInfo::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabStateInfo::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.tab_id)
  return _internal_tab_id();
}
inline void TabStateInfo::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabStateInfo::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.tab_id)
}

// string title = 2;
inline void TabStateInfo::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& TabStateInfo::title() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabStateInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.title)
}
inline std::string* TabStateInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabStateInfo.title)
  return _s;
}
inline const std::string& TabStateInfo::_internal_title() const {
  return title_.Get();
}
inline void TabStateInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabStateInfo::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabStateInfo::release_title() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabStateInfo.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabStateInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabStateInfo.title)
}

// string url = 3;
inline void TabStateInfo::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& TabStateInfo::url() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabStateInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.url)
}
inline std::string* TabStateInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabStateInfo.url)
  return _s;
}
inline const std::string& TabStateInfo::_internal_url() const {
  return url_.Get();
}
inline void TabStateInfo::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabStateInfo::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabStateInfo::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabStateInfo.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabStateInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabStateInfo.url)
}

// bool is_active = 4;
inline void TabStateInfo::clear_is_active() {
  is_active_ = false;
}
inline bool TabStateInfo::_internal_is_active() const {
  return is_active_;
}
inline bool TabStateInfo::is_active() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.is_active)
  return _internal_is_active();
}
inline void TabStateInfo::_internal_set_is_active(bool value) {
  
  is_active_ = value;
}
inline void TabStateInfo::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.is_active)
}

// bool is_loading = 5;
inline void TabStateInfo::clear_is_loading() {
  is_loading_ = false;
}
inline bool TabStateInfo::_internal_is_loading() const {
  return is_loading_;
}
inline bool TabStateInfo::is_loading() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.is_loading)
  return _internal_is_loading();
}
inline void TabStateInfo::_internal_set_is_loading(bool value) {
  
  is_loading_ = value;
}
inline void TabStateInfo::set_is_loading(bool value) {
  _internal_set_is_loading(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.is_loading)
}

// bool is_pinned = 6;
inline void TabStateInfo::clear_is_pinned() {
  is_pinned_ = false;
}
inline bool TabStateInfo::_internal_is_pinned() const {
  return is_pinned_;
}
inline bool TabStateInfo::is_pinned() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.is_pinned)
  return _internal_is_pinned();
}
inline void TabStateInfo::_internal_set_is_pinned(bool value) {
  
  is_pinned_ = value;
}
inline void TabStateInfo::set_is_pinned(bool value) {
  _internal_set_is_pinned(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.is_pinned)
}

// bytes favicon = 7;
inline void TabStateInfo::clear_favicon() {
  favicon_.ClearToEmpty();
}
inline const std::string& TabStateInfo::favicon() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.favicon)
  return _internal_favicon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabStateInfo::set_favicon(ArgT0&& arg0, ArgT... args) {
 
 favicon_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.favicon)
}
inline std::string* TabStateInfo::mutable_favicon() {
  std::string* _s = _internal_mutable_favicon();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabStateInfo.favicon)
  return _s;
}
inline const std::string& TabStateInfo::_internal_favicon() const {
  return favicon_.Get();
}
inline void TabStateInfo::_internal_set_favicon(const std::string& value) {
  
  favicon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabStateInfo::_internal_mutable_favicon() {
  
  return favicon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabStateInfo::release_favicon() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabStateInfo.favicon)
  return favicon_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabStateInfo::set_allocated_favicon(std::string* favicon) {
  if (favicon != nullptr) {
    
  } else {
    
  }
  favicon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), favicon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    favicon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabStateInfo.favicon)
}

// int32 unread_count = 8;
inline void TabStateInfo::clear_unread_count() {
  unread_count_ = 0;
}
inline int32_t TabStateInfo::_internal_unread_count() const {
  return unread_count_;
}
inline int32_t TabStateInfo::unread_count() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.unread_count)
  return _internal_unread_count();
}
inline void TabStateInfo::_internal_set_unread_count(int32_t value) {
  
  unread_count_ = value;
}
inline void TabStateInfo::set_unread_count(int32_t value) {
  _internal_set_unread_count(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.unread_count)
}

// string status = 9;
inline void TabStateInfo::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& TabStateInfo::status() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStateInfo.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabStateInfo::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStateInfo.status)
}
inline std::string* TabStateInfo::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabStateInfo.status)
  return _s;
}
inline const std::string& TabStateInfo::_internal_status() const {
  return status_.Get();
}
inline void TabStateInfo::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabStateInfo::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabStateInfo::release_status() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabStateInfo.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabStateInfo::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabStateInfo.status)
}

// -------------------------------------------------------------------

// WindowResizeEvent

// int32 window_id = 1;
inline void WindowResizeEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowResizeEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowResizeEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.window_id)
  return _internal_window_id();
}
inline void WindowResizeEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowResizeEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.window_id)
}

// int32 new_width = 2;
inline void WindowResizeEvent::clear_new_width() {
  new_width_ = 0;
}
inline int32_t WindowResizeEvent::_internal_new_width() const {
  return new_width_;
}
inline int32_t WindowResizeEvent::new_width() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.new_width)
  return _internal_new_width();
}
inline void WindowResizeEvent::_internal_set_new_width(int32_t value) {
  
  new_width_ = value;
}
inline void WindowResizeEvent::set_new_width(int32_t value) {
  _internal_set_new_width(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.new_width)
}

// int32 new_height = 3;
inline void WindowResizeEvent::clear_new_height() {
  new_height_ = 0;
}
inline int32_t WindowResizeEvent::_internal_new_height() const {
  return new_height_;
}
inline int32_t WindowResizeEvent::new_height() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.new_height)
  return _internal_new_height();
}
inline void WindowResizeEvent::_internal_set_new_height(int32_t value) {
  
  new_height_ = value;
}
inline void WindowResizeEvent::set_new_height(int32_t value) {
  _internal_set_new_height(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.new_height)
}

// int32 old_width = 4;
inline void WindowResizeEvent::clear_old_width() {
  old_width_ = 0;
}
inline int32_t WindowResizeEvent::_internal_old_width() const {
  return old_width_;
}
inline int32_t WindowResizeEvent::old_width() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.old_width)
  return _internal_old_width();
}
inline void WindowResizeEvent::_internal_set_old_width(int32_t value) {
  
  old_width_ = value;
}
inline void WindowResizeEvent::set_old_width(int32_t value) {
  _internal_set_old_width(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.old_width)
}

// int32 old_height = 5;
inline void WindowResizeEvent::clear_old_height() {
  old_height_ = 0;
}
inline int32_t WindowResizeEvent::_internal_old_height() const {
  return old_height_;
}
inline int32_t WindowResizeEvent::old_height() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.old_height)
  return _internal_old_height();
}
inline void WindowResizeEvent::_internal_set_old_height(int32_t value) {
  
  old_height_ = value;
}
inline void WindowResizeEvent::set_old_height(int32_t value) {
  _internal_set_old_height(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.old_height)
}

// int64 timestamp = 6;
inline void WindowResizeEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t WindowResizeEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t WindowResizeEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowResizeEvent.timestamp)
  return _internal_timestamp();
}
inline void WindowResizeEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void WindowResizeEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowResizeEvent.timestamp)
}

// -------------------------------------------------------------------

// WindowMoveEvent

// int32 window_id = 1;
inline void WindowMoveEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowMoveEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowMoveEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.window_id)
  return _internal_window_id();
}
inline void WindowMoveEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowMoveEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.window_id)
}

// int32 new_x = 2;
inline void WindowMoveEvent::clear_new_x() {
  new_x_ = 0;
}
inline int32_t WindowMoveEvent::_internal_new_x() const {
  return new_x_;
}
inline int32_t WindowMoveEvent::new_x() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.new_x)
  return _internal_new_x();
}
inline void WindowMoveEvent::_internal_set_new_x(int32_t value) {
  
  new_x_ = value;
}
inline void WindowMoveEvent::set_new_x(int32_t value) {
  _internal_set_new_x(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.new_x)
}

// int32 new_y = 3;
inline void WindowMoveEvent::clear_new_y() {
  new_y_ = 0;
}
inline int32_t WindowMoveEvent::_internal_new_y() const {
  return new_y_;
}
inline int32_t WindowMoveEvent::new_y() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.new_y)
  return _internal_new_y();
}
inline void WindowMoveEvent::_internal_set_new_y(int32_t value) {
  
  new_y_ = value;
}
inline void WindowMoveEvent::set_new_y(int32_t value) {
  _internal_set_new_y(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.new_y)
}

// int32 old_x = 4;
inline void WindowMoveEvent::clear_old_x() {
  old_x_ = 0;
}
inline int32_t WindowMoveEvent::_internal_old_x() const {
  return old_x_;
}
inline int32_t WindowMoveEvent::old_x() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.old_x)
  return _internal_old_x();
}
inline void WindowMoveEvent::_internal_set_old_x(int32_t value) {
  
  old_x_ = value;
}
inline void WindowMoveEvent::set_old_x(int32_t value) {
  _internal_set_old_x(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.old_x)
}

// int32 old_y = 5;
inline void WindowMoveEvent::clear_old_y() {
  old_y_ = 0;
}
inline int32_t WindowMoveEvent::_internal_old_y() const {
  return old_y_;
}
inline int32_t WindowMoveEvent::old_y() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.old_y)
  return _internal_old_y();
}
inline void WindowMoveEvent::_internal_set_old_y(int32_t value) {
  
  old_y_ = value;
}
inline void WindowMoveEvent::set_old_y(int32_t value) {
  _internal_set_old_y(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.old_y)
}

// int64 timestamp = 6;
inline void WindowMoveEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t WindowMoveEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t WindowMoveEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowMoveEvent.timestamp)
  return _internal_timestamp();
}
inline void WindowMoveEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void WindowMoveEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowMoveEvent.timestamp)
}

// -------------------------------------------------------------------

// KeyboardEvent

// int32 window_id = 1;
inline void KeyboardEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t KeyboardEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t KeyboardEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.window_id)
  return _internal_window_id();
}
inline void KeyboardEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void KeyboardEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.window_id)
}

// int32 tab_id = 2;
inline void KeyboardEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t KeyboardEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t KeyboardEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.tab_id)
  return _internal_tab_id();
}
inline void KeyboardEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void KeyboardEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.tab_id)
}

// string key_code = 3;
inline void KeyboardEvent::clear_key_code() {
  key_code_.ClearToEmpty();
}
inline const std::string& KeyboardEvent::key_code() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.key_code)
  return _internal_key_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyboardEvent::set_key_code(ArgT0&& arg0, ArgT... args) {
 
 key_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.key_code)
}
inline std::string* KeyboardEvent::mutable_key_code() {
  std::string* _s = _internal_mutable_key_code();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.KeyboardEvent.key_code)
  return _s;
}
inline const std::string& KeyboardEvent::_internal_key_code() const {
  return key_code_.Get();
}
inline void KeyboardEvent::_internal_set_key_code(const std::string& value) {
  
  key_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyboardEvent::_internal_mutable_key_code() {
  
  return key_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyboardEvent::release_key_code() {
  // @@protoc_insertion_point(field_release:vaelix.ui.KeyboardEvent.key_code)
  return key_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyboardEvent::set_allocated_key_code(std::string* key_code) {
  if (key_code != nullptr) {
    
  } else {
    
  }
  key_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.KeyboardEvent.key_code)
}

// string key_name = 4;
inline void KeyboardEvent::clear_key_name() {
  key_name_.ClearToEmpty();
}
inline const std::string& KeyboardEvent::key_name() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.key_name)
  return _internal_key_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyboardEvent::set_key_name(ArgT0&& arg0, ArgT... args) {
 
 key_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.key_name)
}
inline std::string* KeyboardEvent::mutable_key_name() {
  std::string* _s = _internal_mutable_key_name();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.KeyboardEvent.key_name)
  return _s;
}
inline const std::string& KeyboardEvent::_internal_key_name() const {
  return key_name_.Get();
}
inline void KeyboardEvent::_internal_set_key_name(const std::string& value) {
  
  key_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyboardEvent::_internal_mutable_key_name() {
  
  return key_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyboardEvent::release_key_name() {
  // @@protoc_insertion_point(field_release:vaelix.ui.KeyboardEvent.key_name)
  return key_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyboardEvent::set_allocated_key_name(std::string* key_name) {
  if (key_name != nullptr) {
    
  } else {
    
  }
  key_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.KeyboardEvent.key_name)
}

// bool is_pressed = 5;
inline void KeyboardEvent::clear_is_pressed() {
  is_pressed_ = false;
}
inline bool KeyboardEvent::_internal_is_pressed() const {
  return is_pressed_;
}
inline bool KeyboardEvent::is_pressed() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.is_pressed)
  return _internal_is_pressed();
}
inline void KeyboardEvent::_internal_set_is_pressed(bool value) {
  
  is_pressed_ = value;
}
inline void KeyboardEvent::set_is_pressed(bool value) {
  _internal_set_is_pressed(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.is_pressed)
}

// bool is_ctrl = 6;
inline void KeyboardEvent::clear_is_ctrl() {
  is_ctrl_ = false;
}
inline bool KeyboardEvent::_internal_is_ctrl() const {
  return is_ctrl_;
}
inline bool KeyboardEvent::is_ctrl() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.is_ctrl)
  return _internal_is_ctrl();
}
inline void KeyboardEvent::_internal_set_is_ctrl(bool value) {
  
  is_ctrl_ = value;
}
inline void KeyboardEvent::set_is_ctrl(bool value) {
  _internal_set_is_ctrl(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.is_ctrl)
}

// bool is_alt = 7;
inline void KeyboardEvent::clear_is_alt() {
  is_alt_ = false;
}
inline bool KeyboardEvent::_internal_is_alt() const {
  return is_alt_;
}
inline bool KeyboardEvent::is_alt() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.is_alt)
  return _internal_is_alt();
}
inline void KeyboardEvent::_internal_set_is_alt(bool value) {
  
  is_alt_ = value;
}
inline void KeyboardEvent::set_is_alt(bool value) {
  _internal_set_is_alt(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.is_alt)
}

// bool is_shift = 8;
inline void KeyboardEvent::clear_is_shift() {
  is_shift_ = false;
}
inline bool KeyboardEvent::_internal_is_shift() const {
  return is_shift_;
}
inline bool KeyboardEvent::is_shift() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.is_shift)
  return _internal_is_shift();
}
inline void KeyboardEvent::_internal_set_is_shift(bool value) {
  
  is_shift_ = value;
}
inline void KeyboardEvent::set_is_shift(bool value) {
  _internal_set_is_shift(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.is_shift)
}

// bool is_meta = 9;
inline void KeyboardEvent::clear_is_meta() {
  is_meta_ = false;
}
inline bool KeyboardEvent::_internal_is_meta() const {
  return is_meta_;
}
inline bool KeyboardEvent::is_meta() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.is_meta)
  return _internal_is_meta();
}
inline void KeyboardEvent::_internal_set_is_meta(bool value) {
  
  is_meta_ = value;
}
inline void KeyboardEvent::set_is_meta(bool value) {
  _internal_set_is_meta(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.is_meta)
}

// int32 repeat_count = 10;
inline void KeyboardEvent::clear_repeat_count() {
  repeat_count_ = 0;
}
inline int32_t KeyboardEvent::_internal_repeat_count() const {
  return repeat_count_;
}
inline int32_t KeyboardEvent::repeat_count() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.KeyboardEvent.repeat_count)
  return _internal_repeat_count();
}
inline void KeyboardEvent::_internal_set_repeat_count(int32_t value) {
  
  repeat_count_ = value;
}
inline void KeyboardEvent::set_repeat_count(int32_t value) {
  _internal_set_repeat_count(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.KeyboardEvent.repeat_count)
}

// -------------------------------------------------------------------

// MouseEvent

// int32 window_id = 1;
inline void MouseEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t MouseEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t MouseEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.window_id)
  return _internal_window_id();
}
inline void MouseEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void MouseEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.window_id)
}

// int32 tab_id = 2;
inline void MouseEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t MouseEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t MouseEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.tab_id)
  return _internal_tab_id();
}
inline void MouseEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void MouseEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.tab_id)
}

// double x = 3;
inline void MouseEvent::clear_x() {
  x_ = 0;
}
inline double MouseEvent::_internal_x() const {
  return x_;
}
inline double MouseEvent::x() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.x)
  return _internal_x();
}
inline void MouseEvent::_internal_set_x(double value) {
  
  x_ = value;
}
inline void MouseEvent::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.x)
}

// double y = 4;
inline void MouseEvent::clear_y() {
  y_ = 0;
}
inline double MouseEvent::_internal_y() const {
  return y_;
}
inline double MouseEvent::y() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.y)
  return _internal_y();
}
inline void MouseEvent::_internal_set_y(double value) {
  
  y_ = value;
}
inline void MouseEvent::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.y)
}

// string button = 5;
inline void MouseEvent::clear_button() {
  button_.ClearToEmpty();
}
inline const std::string& MouseEvent::button() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.button)
  return _internal_button();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MouseEvent::set_button(ArgT0&& arg0, ArgT... args) {
 
 button_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.button)
}
inline std::string* MouseEvent::mutable_button() {
  std::string* _s = _internal_mutable_button();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.MouseEvent.button)
  return _s;
}
inline const std::string& MouseEvent::_internal_button() const {
  return button_.Get();
}
inline void MouseEvent::_internal_set_button(const std::string& value) {
  
  button_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MouseEvent::_internal_mutable_button() {
  
  return button_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MouseEvent::release_button() {
  // @@protoc_insertion_point(field_release:vaelix.ui.MouseEvent.button)
  return button_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MouseEvent::set_allocated_button(std::string* button) {
  if (button != nullptr) {
    
  } else {
    
  }
  button_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), button,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (button_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    button_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.MouseEvent.button)
}

// bool is_pressed = 6;
inline void MouseEvent::clear_is_pressed() {
  is_pressed_ = false;
}
inline bool MouseEvent::_internal_is_pressed() const {
  return is_pressed_;
}
inline bool MouseEvent::is_pressed() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.is_pressed)
  return _internal_is_pressed();
}
inline void MouseEvent::_internal_set_is_pressed(bool value) {
  
  is_pressed_ = value;
}
inline void MouseEvent::set_is_pressed(bool value) {
  _internal_set_is_pressed(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.is_pressed)
}

// int32 click_count = 7;
inline void MouseEvent::clear_click_count() {
  click_count_ = 0;
}
inline int32_t MouseEvent::_internal_click_count() const {
  return click_count_;
}
inline int32_t MouseEvent::click_count() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.click_count)
  return _internal_click_count();
}
inline void MouseEvent::_internal_set_click_count(int32_t value) {
  
  click_count_ = value;
}
inline void MouseEvent::set_click_count(int32_t value) {
  _internal_set_click_count(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.click_count)
}

// int32 wheel_delta = 8;
inline void MouseEvent::clear_wheel_delta() {
  wheel_delta_ = 0;
}
inline int32_t MouseEvent::_internal_wheel_delta() const {
  return wheel_delta_;
}
inline int32_t MouseEvent::wheel_delta() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.MouseEvent.wheel_delta)
  return _internal_wheel_delta();
}
inline void MouseEvent::_internal_set_wheel_delta(int32_t value) {
  
  wheel_delta_ = value;
}
inline void MouseEvent::set_wheel_delta(int32_t value) {
  _internal_set_wheel_delta(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.MouseEvent.wheel_delta)
}

// -------------------------------------------------------------------

// NavigationRequest

// int32 window_id = 1;
inline void NavigationRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t NavigationRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t NavigationRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.window_id)
  return _internal_window_id();
}
inline void NavigationRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void NavigationRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.window_id)
}

// int32 tab_id = 2;
inline void NavigationRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t NavigationRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t NavigationRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.tab_id)
  return _internal_tab_id();
}
inline void NavigationRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void NavigationRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.tab_id)
}

// string url = 3;
inline void NavigationRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& NavigationRequest::url() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigationRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.url)
}
inline std::string* NavigationRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.NavigationRequest.url)
  return _s;
}
inline const std::string& NavigationRequest::_internal_url() const {
  return url_.Get();
}
inline void NavigationRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NavigationRequest::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NavigationRequest::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.ui.NavigationRequest.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NavigationRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.NavigationRequest.url)
}

// bool new_tab = 4;
inline void NavigationRequest::clear_new_tab() {
  new_tab_ = false;
}
inline bool NavigationRequest::_internal_new_tab() const {
  return new_tab_;
}
inline bool NavigationRequest::new_tab() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.new_tab)
  return _internal_new_tab();
}
inline void NavigationRequest::_internal_set_new_tab(bool value) {
  
  new_tab_ = value;
}
inline void NavigationRequest::set_new_tab(bool value) {
  _internal_set_new_tab(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.new_tab)
}

// bool background_tab = 5;
inline void NavigationRequest::clear_background_tab() {
  background_tab_ = false;
}
inline bool NavigationRequest::_internal_background_tab() const {
  return background_tab_;
}
inline bool NavigationRequest::background_tab() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.background_tab)
  return _internal_background_tab();
}
inline void NavigationRequest::_internal_set_background_tab(bool value) {
  
  background_tab_ = value;
}
inline void NavigationRequest::set_background_tab(bool value) {
  _internal_set_background_tab(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.background_tab)
}

// bool force_reload = 6;
inline void NavigationRequest::clear_force_reload() {
  force_reload_ = false;
}
inline bool NavigationRequest::_internal_force_reload() const {
  return force_reload_;
}
inline bool NavigationRequest::force_reload() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.NavigationRequest.force_reload)
  return _internal_force_reload();
}
inline void NavigationRequest::_internal_set_force_reload(bool value) {
  
  force_reload_ = value;
}
inline void NavigationRequest::set_force_reload(bool value) {
  _internal_set_force_reload(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.NavigationRequest.force_reload)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TabOperationRequest

// int32 window_id = 1;
inline void TabOperationRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t TabOperationRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t TabOperationRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabOperationRequest.window_id)
  return _internal_window_id();
}
inline void TabOperationRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void TabOperationRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabOperationRequest.window_id)
}

// int32 tab_id = 2;
inline void TabOperationRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabOperationRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabOperationRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabOperationRequest.tab_id)
  return _internal_tab_id();
}
inline void TabOperationRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabOperationRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabOperationRequest.tab_id)
}

// string operation = 3;
inline void TabOperationRequest::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& TabOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabOperationRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabOperationRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabOperationRequest.operation)
}
inline std::string* TabOperationRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabOperationRequest.operation)
  return _s;
}
inline const std::string& TabOperationRequest::_internal_operation() const {
  return operation_.Get();
}
inline void TabOperationRequest::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabOperationRequest::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabOperationRequest::release_operation() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabOperationRequest.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TabOperationRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabOperationRequest.operation)
}

// map<string, string> parameters = 4;
inline int TabOperationRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int TabOperationRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void TabOperationRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TabOperationRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TabOperationRequest::parameters() const {
  // @@protoc_insertion_point(field_map:vaelix.ui.TabOperationRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TabOperationRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TabOperationRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.ui.TabOperationRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WindowOperationRequest

// int32 window_id = 1;
inline void WindowOperationRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowOperationRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowOperationRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowOperationRequest.window_id)
  return _internal_window_id();
}
inline void WindowOperationRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowOperationRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowOperationRequest.window_id)
}

// string operation = 2;
inline void WindowOperationRequest::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& WindowOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowOperationRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowOperationRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowOperationRequest.operation)
}
inline std::string* WindowOperationRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowOperationRequest.operation)
  return _s;
}
inline const std::string& WindowOperationRequest::_internal_operation() const {
  return operation_.Get();
}
inline void WindowOperationRequest::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WindowOperationRequest::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WindowOperationRequest::release_operation() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowOperationRequest.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WindowOperationRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.WindowOperationRequest.operation)
}

// map<string, string> parameters = 3;
inline int WindowOperationRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int WindowOperationRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void WindowOperationRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WindowOperationRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WindowOperationRequest::parameters() const {
  // @@protoc_insertion_point(field_map:vaelix.ui.WindowOperationRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WindowOperationRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WindowOperationRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.ui.WindowOperationRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ThemeChangeEvent

// string theme_name = 4;
inline void ThemeChangeEvent::clear_theme_name() {
  theme_name_.ClearToEmpty();
}
inline const std::string& ThemeChangeEvent::theme_name() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ThemeChangeEvent.theme_name)
  return _internal_theme_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeChangeEvent::set_theme_name(ArgT0&& arg0, ArgT... args) {
 
 theme_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.ThemeChangeEvent.theme_name)
}
inline std::string* ThemeChangeEvent::mutable_theme_name() {
  std::string* _s = _internal_mutable_theme_name();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.ThemeChangeEvent.theme_name)
  return _s;
}
inline const std::string& ThemeChangeEvent::_internal_theme_name() const {
  return theme_name_.Get();
}
inline void ThemeChangeEvent::_internal_set_theme_name(const std::string& value) {
  
  theme_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeChangeEvent::_internal_mutable_theme_name() {
  
  return theme_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeChangeEvent::release_theme_name() {
  // @@protoc_insertion_point(field_release:vaelix.ui.ThemeChangeEvent.theme_name)
  return theme_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeChangeEvent::set_allocated_theme_name(std::string* theme_name) {
  if (theme_name != nullptr) {
    
  } else {
    
  }
  theme_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), theme_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (theme_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    theme_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.ThemeChangeEvent.theme_name)
}

// string variant = 5;
inline void ThemeChangeEvent::clear_variant() {
  variant_.ClearToEmpty();
}
inline const std::string& ThemeChangeEvent::variant() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ThemeChangeEvent.variant)
  return _internal_variant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeChangeEvent::set_variant(ArgT0&& arg0, ArgT... args) {
 
 variant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.ThemeChangeEvent.variant)
}
inline std::string* ThemeChangeEvent::mutable_variant() {
  std::string* _s = _internal_mutable_variant();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.ThemeChangeEvent.variant)
  return _s;
}
inline const std::string& ThemeChangeEvent::_internal_variant() const {
  return variant_.Get();
}
inline void ThemeChangeEvent::_internal_set_variant(const std::string& value) {
  
  variant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeChangeEvent::_internal_mutable_variant() {
  
  return variant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeChangeEvent::release_variant() {
  // @@protoc_insertion_point(field_release:vaelix.ui.ThemeChangeEvent.variant)
  return variant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeChangeEvent::set_allocated_variant(std::string* variant) {
  if (variant != nullptr) {
    
  } else {
    
  }
  variant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variant,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variant_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variant_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.ThemeChangeEvent.variant)
}

// bool animation_enabled = 6;
inline void ThemeChangeEvent::clear_animation_enabled() {
  animation_enabled_ = false;
}
inline bool ThemeChangeEvent::_internal_animation_enabled() const {
  return animation_enabled_;
}
inline bool ThemeChangeEvent::animation_enabled() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ThemeChangeEvent.animation_enabled)
  return _internal_animation_enabled();
}
inline void ThemeChangeEvent::_internal_set_animation_enabled(bool value) {
  
  animation_enabled_ = value;
}
inline void ThemeChangeEvent::set_animation_enabled(bool value) {
  _internal_set_animation_enabled(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.ThemeChangeEvent.animation_enabled)
}

// double animation_speed = 7;
inline void ThemeChangeEvent::clear_animation_speed() {
  animation_speed_ = 0;
}
inline double ThemeChangeEvent::_internal_animation_speed() const {
  return animation_speed_;
}
inline double ThemeChangeEvent::animation_speed() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ThemeChangeEvent.animation_speed)
  return _internal_animation_speed();
}
inline void ThemeChangeEvent::_internal_set_animation_speed(double value) {
  
  animation_speed_ = value;
}
inline void ThemeChangeEvent::set_animation_speed(double value) {
  _internal_set_animation_speed(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.ThemeChangeEvent.animation_speed)
}

// -------------------------------------------------------------------

// FocusChangeEvent

// int32 window_id = 1;
inline void FocusChangeEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t FocusChangeEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t FocusChangeEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FocusChangeEvent.window_id)
  return _internal_window_id();
}
inline void FocusChangeEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void FocusChangeEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FocusChangeEvent.window_id)
}

// int32 old_tab_id = 2;
inline void FocusChangeEvent::clear_old_tab_id() {
  old_tab_id_ = 0;
}
inline int32_t FocusChangeEvent::_internal_old_tab_id() const {
  return old_tab_id_;
}
inline int32_t FocusChangeEvent::old_tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FocusChangeEvent.old_tab_id)
  return _internal_old_tab_id();
}
inline void FocusChangeEvent::_internal_set_old_tab_id(int32_t value) {
  
  old_tab_id_ = value;
}
inline void FocusChangeEvent::set_old_tab_id(int32_t value) {
  _internal_set_old_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FocusChangeEvent.old_tab_id)
}

// int32 new_tab_id = 3;
inline void FocusChangeEvent::clear_new_tab_id() {
  new_tab_id_ = 0;
}
inline int32_t FocusChangeEvent::_internal_new_tab_id() const {
  return new_tab_id_;
}
inline int32_t FocusChangeEvent::new_tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FocusChangeEvent.new_tab_id)
  return _internal_new_tab_id();
}
inline void FocusChangeEvent::_internal_set_new_tab_id(int32_t value) {
  
  new_tab_id_ = value;
}
inline void FocusChangeEvent::set_new_tab_id(int32_t value) {
  _internal_set_new_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FocusChangeEvent.new_tab_id)
}

// bool window_focus = 4;
inline void FocusChangeEvent::clear_window_focus() {
  window_focus_ = false;
}
inline bool FocusChangeEvent::_internal_window_focus() const {
  return window_focus_;
}
inline bool FocusChangeEvent::window_focus() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FocusChangeEvent.window_focus)
  return _internal_window_focus();
}
inline void FocusChangeEvent::_internal_set_window_focus(bool value) {
  
  window_focus_ = value;
}
inline void FocusChangeEvent::set_window_focus(bool value) {
  _internal_set_window_focus(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FocusChangeEvent.window_focus)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UIStateUpdate

// int32 window_id = 1;
inline void UIStateUpdate::clear_window_id() {
  window_id_ = 0;
}
inline int32_t UIStateUpdate::_internal_window_id() const {
  return window_id_;
}
inline int32_t UIStateUpdate::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.window_id)
  return _internal_window_id();
}
inline void UIStateUpdate::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void UIStateUpdate::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateUpdate.window_id)
}

// repeated .vaelix.ui.TabStateInfo tabs = 2;
inline int UIStateUpdate::_internal_tabs_size() const {
  return tabs_.size();
}
inline int UIStateUpdate::tabs_size() const {
  return _internal_tabs_size();
}
inline void UIStateUpdate::clear_tabs() {
  tabs_.Clear();
}
inline ::vaelix::ui::TabStateInfo* UIStateUpdate::mutable_tabs(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.ui.UIStateUpdate.tabs)
  return tabs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::ui::TabStateInfo >*
UIStateUpdate::mutable_tabs() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.ui.UIStateUpdate.tabs)
  return &tabs_;
}
inline const ::vaelix::ui::TabStateInfo& UIStateUpdate::_internal_tabs(int index) const {
  return tabs_.Get(index);
}
inline const ::vaelix::ui::TabStateInfo& UIStateUpdate::tabs(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.tabs)
  return _internal_tabs(index);
}
inline ::vaelix::ui::TabStateInfo* UIStateUpdate::_internal_add_tabs() {
  return tabs_.Add();
}
inline ::vaelix::ui::TabStateInfo* UIStateUpdate::add_tabs() {
  ::vaelix::ui::TabStateInfo* _add = _internal_add_tabs();
  // @@protoc_insertion_point(field_add:vaelix.ui.UIStateUpdate.tabs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::ui::TabStateInfo >&
UIStateUpdate::tabs() const {
  // @@protoc_insertion_point(field_list:vaelix.ui.UIStateUpdate.tabs)
  return tabs_;
}

// .vaelix.ui.WindowInfo window_info = 3;
inline bool UIStateUpdate::_internal_has_window_info() const {
  return this != internal_default_instance() && window_info_ != nullptr;
}
inline bool UIStateUpdate::has_window_info() const {
  return _internal_has_window_info();
}
inline void UIStateUpdate::clear_window_info() {
  if (GetArenaForAllocation() == nullptr && window_info_ != nullptr) {
    delete window_info_;
  }
  window_info_ = nullptr;
}
inline const ::vaelix::ui::WindowInfo& UIStateUpdate::_internal_window_info() const {
  const ::vaelix::ui::WindowInfo* p = window_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::ui::WindowInfo&>(
      ::vaelix::ui::_WindowInfo_default_instance_);
}
inline const ::vaelix::ui::WindowInfo& UIStateUpdate::window_info() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.window_info)
  return _internal_window_info();
}
inline void UIStateUpdate::unsafe_arena_set_allocated_window_info(
    ::vaelix::ui::WindowInfo* window_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_info_);
  }
  window_info_ = window_info;
  if (window_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.UIStateUpdate.window_info)
}
inline ::vaelix::ui::WindowInfo* UIStateUpdate::release_window_info() {
  
  ::vaelix::ui::WindowInfo* temp = window_info_;
  window_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::ui::WindowInfo* UIStateUpdate::unsafe_arena_release_window_info() {
  // @@protoc_insertion_point(field_release:vaelix.ui.UIStateUpdate.window_info)
  
  ::vaelix::ui::WindowInfo* temp = window_info_;
  window_info_ = nullptr;
  return temp;
}
inline ::vaelix::ui::WindowInfo* UIStateUpdate::_internal_mutable_window_info() {
  
  if (window_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::ui::WindowInfo>(GetArenaForAllocation());
    window_info_ = p;
  }
  return window_info_;
}
inline ::vaelix::ui::WindowInfo* UIStateUpdate::mutable_window_info() {
  ::vaelix::ui::WindowInfo* _msg = _internal_mutable_window_info();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.UIStateUpdate.window_info)
  return _msg;
}
inline void UIStateUpdate::set_allocated_window_info(::vaelix::ui::WindowInfo* window_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_info_;
  }
  if (window_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::ui::WindowInfo>::GetOwningArena(window_info);
    if (message_arena != submessage_arena) {
      window_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_info, submessage_arena);
    }
    
  } else {
    
  }
  window_info_ = window_info;
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.UIStateUpdate.window_info)
}

// string status_message = 4;
inline void UIStateUpdate::clear_status_message() {
  status_message_.ClearToEmpty();
}
inline const std::string& UIStateUpdate::status_message() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UIStateUpdate::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 status_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateUpdate.status_message)
}
inline std::string* UIStateUpdate::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.UIStateUpdate.status_message)
  return _s;
}
inline const std::string& UIStateUpdate::_internal_status_message() const {
  return status_message_.Get();
}
inline void UIStateUpdate::_internal_set_status_message(const std::string& value) {
  
  status_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UIStateUpdate::_internal_mutable_status_message() {
  
  return status_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UIStateUpdate::release_status_message() {
  // @@protoc_insertion_point(field_release:vaelix.ui.UIStateUpdate.status_message)
  return status_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UIStateUpdate::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  status_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.UIStateUpdate.status_message)
}

// bool loading_indicator = 5;
inline void UIStateUpdate::clear_loading_indicator() {
  loading_indicator_ = false;
}
inline bool UIStateUpdate::_internal_loading_indicator() const {
  return loading_indicator_;
}
inline bool UIStateUpdate::loading_indicator() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.loading_indicator)
  return _internal_loading_indicator();
}
inline void UIStateUpdate::_internal_set_loading_indicator(bool value) {
  
  loading_indicator_ = value;
}
inline void UIStateUpdate::set_loading_indicator(bool value) {
  _internal_set_loading_indicator(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateUpdate.loading_indicator)
}

// double progress_indicator = 6;
inline void UIStateUpdate::clear_progress_indicator() {
  progress_indicator_ = 0;
}
inline double UIStateUpdate::_internal_progress_indicator() const {
  return progress_indicator_;
}
inline double UIStateUpdate::progress_indicator() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateUpdate.progress_indicator)
  return _internal_progress_indicator();
}
inline void UIStateUpdate::_internal_set_progress_indicator(double value) {
  
  progress_indicator_ = value;
}
inline void UIStateUpdate::set_progress_indicator(double value) {
  _internal_set_progress_indicator(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateUpdate.progress_indicator)
}

// map<string, string> ui_state = 7;
inline int UIStateUpdate::_internal_ui_state_size() const {
  return ui_state_.size();
}
inline int UIStateUpdate::ui_state_size() const {
  return _internal_ui_state_size();
}
inline void UIStateUpdate::clear_ui_state() {
  ui_state_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UIStateUpdate::_internal_ui_state() const {
  return ui_state_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UIStateUpdate::ui_state() const {
  // @@protoc_insertion_point(field_map:vaelix.ui.UIStateUpdate.ui_state)
  return _internal_ui_state();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UIStateUpdate::_internal_mutable_ui_state() {
  return ui_state_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UIStateUpdate::mutable_ui_state() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.ui.UIStateUpdate.ui_state)
  return _internal_mutable_ui_state();
}

// -------------------------------------------------------------------

// ShortcutEvent

// string shortcut = 1;
inline void ShortcutEvent::clear_shortcut() {
  shortcut_.ClearToEmpty();
}
inline const std::string& ShortcutEvent::shortcut() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ShortcutEvent.shortcut)
  return _internal_shortcut();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShortcutEvent::set_shortcut(ArgT0&& arg0, ArgT... args) {
 
 shortcut_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.ShortcutEvent.shortcut)
}
inline std::string* ShortcutEvent::mutable_shortcut() {
  std::string* _s = _internal_mutable_shortcut();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.ShortcutEvent.shortcut)
  return _s;
}
inline const std::string& ShortcutEvent::_internal_shortcut() const {
  return shortcut_.Get();
}
inline void ShortcutEvent::_internal_set_shortcut(const std::string& value) {
  
  shortcut_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShortcutEvent::_internal_mutable_shortcut() {
  
  return shortcut_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShortcutEvent::release_shortcut() {
  // @@protoc_insertion_point(field_release:vaelix.ui.ShortcutEvent.shortcut)
  return shortcut_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShortcutEvent::set_allocated_shortcut(std::string* shortcut) {
  if (shortcut != nullptr) {
    
  } else {
    
  }
  shortcut_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shortcut,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shortcut_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shortcut_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.ShortcutEvent.shortcut)
}

// int32 window_id = 2;
inline void ShortcutEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t ShortcutEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t ShortcutEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ShortcutEvent.window_id)
  return _internal_window_id();
}
inline void ShortcutEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void ShortcutEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.ShortcutEvent.window_id)
}

// bool consume = 3;
inline void ShortcutEvent::clear_consume() {
  consume_ = false;
}
inline bool ShortcutEvent::_internal_consume() const {
  return consume_;
}
inline bool ShortcutEvent::consume() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.ShortcutEvent.consume)
  return _internal_consume();
}
inline void ShortcutEvent::_internal_set_consume(bool value) {
  
  consume_ = value;
}
inline void ShortcutEvent::set_consume(bool value) {
  _internal_set_consume(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.ShortcutEvent.consume)
}

// -------------------------------------------------------------------

// PermissionRequest

// int32 window_id = 1;
inline void PermissionRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t PermissionRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t PermissionRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.PermissionRequest.window_id)
  return _internal_window_id();
}
inline void PermissionRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void PermissionRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.PermissionRequest.window_id)
}

// int32 tab_id = 2;
inline void PermissionRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t PermissionRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t PermissionRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.PermissionRequest.tab_id)
  return _internal_tab_id();
}
inline void PermissionRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void PermissionRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.PermissionRequest.tab_id)
}

// string permission_type = 3;
inline void PermissionRequest::clear_permission_type() {
  permission_type_.ClearToEmpty();
}
inline const std::string& PermissionRequest::permission_type() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.PermissionRequest.permission_type)
  return _internal_permission_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionRequest::set_permission_type(ArgT0&& arg0, ArgT... args) {
 
 permission_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.PermissionRequest.permission_type)
}
inline std::string* PermissionRequest::mutable_permission_type() {
  std::string* _s = _internal_mutable_permission_type();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.PermissionRequest.permission_type)
  return _s;
}
inline const std::string& PermissionRequest::_internal_permission_type() const {
  return permission_type_.Get();
}
inline void PermissionRequest::_internal_set_permission_type(const std::string& value) {
  
  permission_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_permission_type() {
  
  return permission_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_permission_type() {
  // @@protoc_insertion_point(field_release:vaelix.ui.PermissionRequest.permission_type)
  return permission_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionRequest::set_allocated_permission_type(std::string* permission_type) {
  if (permission_type != nullptr) {
    
  } else {
    
  }
  permission_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), permission_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    permission_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.PermissionRequest.permission_type)
}

// string origin = 4;
inline void PermissionRequest::clear_origin() {
  origin_.ClearToEmpty();
}
inline const std::string& PermissionRequest::origin() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.PermissionRequest.origin)
  return _internal_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionRequest::set_origin(ArgT0&& arg0, ArgT... args) {
 
 origin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.PermissionRequest.origin)
}
inline std::string* PermissionRequest::mutable_origin() {
  std::string* _s = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.PermissionRequest.origin)
  return _s;
}
inline const std::string& PermissionRequest::_internal_origin() const {
  return origin_.Get();
}
inline void PermissionRequest::_internal_set_origin(const std::string& value) {
  
  origin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_origin() {
  
  return origin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_origin() {
  // @@protoc_insertion_point(field_release:vaelix.ui.PermissionRequest.origin)
  return origin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionRequest::set_allocated_origin(std::string* origin) {
  if (origin != nullptr) {
    
  } else {
    
  }
  origin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), origin,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (origin_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    origin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.PermissionRequest.origin)
}

// string details = 5;
inline void PermissionRequest::clear_details() {
  details_.ClearToEmpty();
}
inline const std::string& PermissionRequest::details() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.PermissionRequest.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionRequest::set_details(ArgT0&& arg0, ArgT... args) {
 
 details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.PermissionRequest.details)
}
inline std::string* PermissionRequest::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.PermissionRequest.details)
  return _s;
}
inline const std::string& PermissionRequest::_internal_details() const {
  return details_.Get();
}
inline void PermissionRequest::_internal_set_details(const std::string& value) {
  
  details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_details() {
  
  return details_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_details() {
  // @@protoc_insertion_point(field_release:vaelix.ui.PermissionRequest.details)
  return details_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionRequest::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  details_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), details,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (details_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.PermissionRequest.details)
}

// -------------------------------------------------------------------

// FileDownloadEvent

// int32 tab_id = 1;
inline void FileDownloadEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t FileDownloadEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t FileDownloadEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.tab_id)
  return _internal_tab_id();
}
inline void FileDownloadEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void FileDownloadEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.tab_id)
}

// string url = 2;
inline void FileDownloadEvent::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& FileDownloadEvent::url() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileDownloadEvent::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.url)
}
inline std::string* FileDownloadEvent::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.FileDownloadEvent.url)
  return _s;
}
inline const std::string& FileDownloadEvent::_internal_url() const {
  return url_.Get();
}
inline void FileDownloadEvent::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.ui.FileDownloadEvent.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileDownloadEvent::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.FileDownloadEvent.url)
}

// string filename = 3;
inline void FileDownloadEvent::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& FileDownloadEvent::filename() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileDownloadEvent::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.filename)
}
inline std::string* FileDownloadEvent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.FileDownloadEvent.filename)
  return _s;
}
inline const std::string& FileDownloadEvent::_internal_filename() const {
  return filename_.Get();
}
inline void FileDownloadEvent::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::release_filename() {
  // @@protoc_insertion_point(field_release:vaelix.ui.FileDownloadEvent.filename)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileDownloadEvent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.FileDownloadEvent.filename)
}

// int64 content_length = 4;
inline void FileDownloadEvent::clear_content_length() {
  content_length_ = int64_t{0};
}
inline int64_t FileDownloadEvent::_internal_content_length() const {
  return content_length_;
}
inline int64_t FileDownloadEvent::content_length() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.content_length)
  return _internal_content_length();
}
inline void FileDownloadEvent::_internal_set_content_length(int64_t value) {
  
  content_length_ = value;
}
inline void FileDownloadEvent::set_content_length(int64_t value) {
  _internal_set_content_length(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.content_length)
}

// string content_type = 5;
inline void FileDownloadEvent::clear_content_type() {
  content_type_.ClearToEmpty();
}
inline const std::string& FileDownloadEvent::content_type() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileDownloadEvent::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.content_type)
}
inline std::string* FileDownloadEvent::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.FileDownloadEvent.content_type)
  return _s;
}
inline const std::string& FileDownloadEvent::_internal_content_type() const {
  return content_type_.Get();
}
inline void FileDownloadEvent::_internal_set_content_type(const std::string& value) {
  
  content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::_internal_mutable_content_type() {
  
  return content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileDownloadEvent::release_content_type() {
  // @@protoc_insertion_point(field_release:vaelix.ui.FileDownloadEvent.content_type)
  return content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileDownloadEvent::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.FileDownloadEvent.content_type)
}

// bool is_auto_download = 6;
inline void FileDownloadEvent::clear_is_auto_download() {
  is_auto_download_ = false;
}
inline bool FileDownloadEvent::_internal_is_auto_download() const {
  return is_auto_download_;
}
inline bool FileDownloadEvent::is_auto_download() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.FileDownloadEvent.is_auto_download)
  return _internal_is_auto_download();
}
inline void FileDownloadEvent::_internal_set_is_auto_download(bool value) {
  
  is_auto_download_ = value;
}
inline void FileDownloadEvent::set_is_auto_download(bool value) {
  _internal_set_is_auto_download(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.FileDownloadEvent.is_auto_download)
}

// -------------------------------------------------------------------

// WindowEvent

// .vaelix.ui.WindowResizeEvent resize = 1;
inline bool WindowEvent::_internal_has_resize() const {
  return event_case() == kResize;
}
inline bool WindowEvent::has_resize() const {
  return _internal_has_resize();
}
inline void WindowEvent::set_has_resize() {
  _oneof_case_[0] = kResize;
}
inline void WindowEvent::clear_resize() {
  if (_internal_has_resize()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.resize_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::WindowResizeEvent* WindowEvent::release_resize() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowEvent.resize)
  if (_internal_has_resize()) {
    clear_has_event();
      ::vaelix::ui::WindowResizeEvent* temp = event_.resize_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.resize_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::WindowResizeEvent& WindowEvent::_internal_resize() const {
  return _internal_has_resize()
      ? *event_.resize_
      : reinterpret_cast< ::vaelix::ui::WindowResizeEvent&>(::vaelix::ui::_WindowResizeEvent_default_instance_);
}
inline const ::vaelix::ui::WindowResizeEvent& WindowEvent::resize() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.resize)
  return _internal_resize();
}
inline ::vaelix::ui::WindowResizeEvent* WindowEvent::unsafe_arena_release_resize() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.WindowEvent.resize)
  if (_internal_has_resize()) {
    clear_has_event();
    ::vaelix::ui::WindowResizeEvent* temp = event_.resize_;
    event_.resize_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowEvent::unsafe_arena_set_allocated_resize(::vaelix::ui::WindowResizeEvent* resize) {
  clear_event();
  if (resize) {
    set_has_resize();
    event_.resize_ = resize;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.WindowEvent.resize)
}
inline ::vaelix::ui::WindowResizeEvent* WindowEvent::_internal_mutable_resize() {
  if (!_internal_has_resize()) {
    clear_event();
    set_has_resize();
    event_.resize_ = CreateMaybeMessage< ::vaelix::ui::WindowResizeEvent >(GetArenaForAllocation());
  }
  return event_.resize_;
}
inline ::vaelix::ui::WindowResizeEvent* WindowEvent::mutable_resize() {
  ::vaelix::ui::WindowResizeEvent* _msg = _internal_mutable_resize();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowEvent.resize)
  return _msg;
}

// .vaelix.ui.WindowMoveEvent move = 2;
inline bool WindowEvent::_internal_has_move() const {
  return event_case() == kMove;
}
inline bool WindowEvent::has_move() const {
  return _internal_has_move();
}
inline void WindowEvent::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void WindowEvent::clear_move() {
  if (_internal_has_move()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.move_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::WindowMoveEvent* WindowEvent::release_move() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowEvent.move)
  if (_internal_has_move()) {
    clear_has_event();
      ::vaelix::ui::WindowMoveEvent* temp = event_.move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::WindowMoveEvent& WindowEvent::_internal_move() const {
  return _internal_has_move()
      ? *event_.move_
      : reinterpret_cast< ::vaelix::ui::WindowMoveEvent&>(::vaelix::ui::_WindowMoveEvent_default_instance_);
}
inline const ::vaelix::ui::WindowMoveEvent& WindowEvent::move() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.move)
  return _internal_move();
}
inline ::vaelix::ui::WindowMoveEvent* WindowEvent::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.WindowEvent.move)
  if (_internal_has_move()) {
    clear_has_event();
    ::vaelix::ui::WindowMoveEvent* temp = event_.move_;
    event_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowEvent::unsafe_arena_set_allocated_move(::vaelix::ui::WindowMoveEvent* move) {
  clear_event();
  if (move) {
    set_has_move();
    event_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.WindowEvent.move)
}
inline ::vaelix::ui::WindowMoveEvent* WindowEvent::_internal_mutable_move() {
  if (!_internal_has_move()) {
    clear_event();
    set_has_move();
    event_.move_ = CreateMaybeMessage< ::vaelix::ui::WindowMoveEvent >(GetArenaForAllocation());
  }
  return event_.move_;
}
inline ::vaelix::ui::WindowMoveEvent* WindowEvent::mutable_move() {
  ::vaelix::ui::WindowMoveEvent* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowEvent.move)
  return _msg;
}

// .vaelix.ui.FocusChangeEvent focus_change = 3;
inline bool WindowEvent::_internal_has_focus_change() const {
  return event_case() == kFocusChange;
}
inline bool WindowEvent::has_focus_change() const {
  return _internal_has_focus_change();
}
inline void WindowEvent::set_has_focus_change() {
  _oneof_case_[0] = kFocusChange;
}
inline void WindowEvent::clear_focus_change() {
  if (_internal_has_focus_change()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.focus_change_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::FocusChangeEvent* WindowEvent::release_focus_change() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowEvent.focus_change)
  if (_internal_has_focus_change()) {
    clear_has_event();
      ::vaelix::ui::FocusChangeEvent* temp = event_.focus_change_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.focus_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::FocusChangeEvent& WindowEvent::_internal_focus_change() const {
  return _internal_has_focus_change()
      ? *event_.focus_change_
      : reinterpret_cast< ::vaelix::ui::FocusChangeEvent&>(::vaelix::ui::_FocusChangeEvent_default_instance_);
}
inline const ::vaelix::ui::FocusChangeEvent& WindowEvent::focus_change() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.focus_change)
  return _internal_focus_change();
}
inline ::vaelix::ui::FocusChangeEvent* WindowEvent::unsafe_arena_release_focus_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.WindowEvent.focus_change)
  if (_internal_has_focus_change()) {
    clear_has_event();
    ::vaelix::ui::FocusChangeEvent* temp = event_.focus_change_;
    event_.focus_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowEvent::unsafe_arena_set_allocated_focus_change(::vaelix::ui::FocusChangeEvent* focus_change) {
  clear_event();
  if (focus_change) {
    set_has_focus_change();
    event_.focus_change_ = focus_change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.WindowEvent.focus_change)
}
inline ::vaelix::ui::FocusChangeEvent* WindowEvent::_internal_mutable_focus_change() {
  if (!_internal_has_focus_change()) {
    clear_event();
    set_has_focus_change();
    event_.focus_change_ = CreateMaybeMessage< ::vaelix::ui::FocusChangeEvent >(GetArenaForAllocation());
  }
  return event_.focus_change_;
}
inline ::vaelix::ui::FocusChangeEvent* WindowEvent::mutable_focus_change() {
  ::vaelix::ui::FocusChangeEvent* _msg = _internal_mutable_focus_change();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowEvent.focus_change)
  return _msg;
}

// .vaelix.ui.ThemeChangeEvent theme_change = 4;
inline bool WindowEvent::_internal_has_theme_change() const {
  return event_case() == kThemeChange;
}
inline bool WindowEvent::has_theme_change() const {
  return _internal_has_theme_change();
}
inline void WindowEvent::set_has_theme_change() {
  _oneof_case_[0] = kThemeChange;
}
inline void WindowEvent::clear_theme_change() {
  if (_internal_has_theme_change()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.theme_change_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::ThemeChangeEvent* WindowEvent::release_theme_change() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowEvent.theme_change)
  if (_internal_has_theme_change()) {
    clear_has_event();
      ::vaelix::ui::ThemeChangeEvent* temp = event_.theme_change_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.theme_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::ThemeChangeEvent& WindowEvent::_internal_theme_change() const {
  return _internal_has_theme_change()
      ? *event_.theme_change_
      : reinterpret_cast< ::vaelix::ui::ThemeChangeEvent&>(::vaelix::ui::_ThemeChangeEvent_default_instance_);
}
inline const ::vaelix::ui::ThemeChangeEvent& WindowEvent::theme_change() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.theme_change)
  return _internal_theme_change();
}
inline ::vaelix::ui::ThemeChangeEvent* WindowEvent::unsafe_arena_release_theme_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.WindowEvent.theme_change)
  if (_internal_has_theme_change()) {
    clear_has_event();
    ::vaelix::ui::ThemeChangeEvent* temp = event_.theme_change_;
    event_.theme_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowEvent::unsafe_arena_set_allocated_theme_change(::vaelix::ui::ThemeChangeEvent* theme_change) {
  clear_event();
  if (theme_change) {
    set_has_theme_change();
    event_.theme_change_ = theme_change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.WindowEvent.theme_change)
}
inline ::vaelix::ui::ThemeChangeEvent* WindowEvent::_internal_mutable_theme_change() {
  if (!_internal_has_theme_change()) {
    clear_event();
    set_has_theme_change();
    event_.theme_change_ = CreateMaybeMessage< ::vaelix::ui::ThemeChangeEvent >(GetArenaForAllocation());
  }
  return event_.theme_change_;
}
inline ::vaelix::ui::ThemeChangeEvent* WindowEvent::mutable_theme_change() {
  ::vaelix::ui::ThemeChangeEvent* _msg = _internal_mutable_theme_change();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowEvent.theme_change)
  return _msg;
}

// string window_error = 5;
inline bool WindowEvent::_internal_has_window_error() const {
  return event_case() == kWindowError;
}
inline bool WindowEvent::has_window_error() const {
  return _internal_has_window_error();
}
inline void WindowEvent::set_has_window_error() {
  _oneof_case_[0] = kWindowError;
}
inline void WindowEvent::clear_window_error() {
  if (_internal_has_window_error()) {
    event_.window_error_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_event();
  }
}
inline const std::string& WindowEvent::window_error() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.window_error)
  return _internal_window_error();
}
template <typename ArgT0, typename... ArgT>
inline void WindowEvent::set_window_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_window_error()) {
    clear_event();
    set_has_window_error();
    event_.window_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.window_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowEvent.window_error)
}
inline std::string* WindowEvent::mutable_window_error() {
  std::string* _s = _internal_mutable_window_error();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.WindowEvent.window_error)
  return _s;
}
inline const std::string& WindowEvent::_internal_window_error() const {
  if (_internal_has_window_error()) {
    return event_.window_error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void WindowEvent::_internal_set_window_error(const std::string& value) {
  if (!_internal_has_window_error()) {
    clear_event();
    set_has_window_error();
    event_.window_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.window_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WindowEvent::_internal_mutable_window_error() {
  if (!_internal_has_window_error()) {
    clear_event();
    set_has_window_error();
    event_.window_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return event_.window_error_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WindowEvent::release_window_error() {
  // @@protoc_insertion_point(field_release:vaelix.ui.WindowEvent.window_error)
  if (_internal_has_window_error()) {
    clear_has_event();
    return event_.window_error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void WindowEvent::set_allocated_window_error(std::string* window_error) {
  if (has_event()) {
    clear_event();
  }
  if (window_error != nullptr) {
    set_has_window_error();
    event_.window_error_.UnsafeSetDefault(window_error);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(window_error);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.WindowEvent.window_error)
}

// int32 window_id = 6;
inline void WindowEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.window_id)
  return _internal_window_id();
}
inline void WindowEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowEvent.window_id)
}

// int64 timestamp = 7;
inline void WindowEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t WindowEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t WindowEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowEvent.timestamp)
  return _internal_timestamp();
}
inline void WindowEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void WindowEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowEvent.timestamp)
}

inline bool WindowEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void WindowEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline WindowEvent::EventCase WindowEvent::event_case() const {
  return WindowEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TabEvent

// .vaelix.ui.NavigationRequest navigation = 1;
inline bool TabEvent::_internal_has_navigation() const {
  return event_case() == kNavigation;
}
inline bool TabEvent::has_navigation() const {
  return _internal_has_navigation();
}
inline void TabEvent::set_has_navigation() {
  _oneof_case_[0] = kNavigation;
}
inline void TabEvent::clear_navigation() {
  if (_internal_has_navigation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.navigation_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::NavigationRequest* TabEvent::release_navigation() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabEvent.navigation)
  if (_internal_has_navigation()) {
    clear_has_event();
      ::vaelix::ui::NavigationRequest* temp = event_.navigation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::NavigationRequest& TabEvent::_internal_navigation() const {
  return _internal_has_navigation()
      ? *event_.navigation_
      : reinterpret_cast< ::vaelix::ui::NavigationRequest&>(::vaelix::ui::_NavigationRequest_default_instance_);
}
inline const ::vaelix::ui::NavigationRequest& TabEvent::navigation() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.navigation)
  return _internal_navigation();
}
inline ::vaelix::ui::NavigationRequest* TabEvent::unsafe_arena_release_navigation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.TabEvent.navigation)
  if (_internal_has_navigation()) {
    clear_has_event();
    ::vaelix::ui::NavigationRequest* temp = event_.navigation_;
    event_.navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TabEvent::unsafe_arena_set_allocated_navigation(::vaelix::ui::NavigationRequest* navigation) {
  clear_event();
  if (navigation) {
    set_has_navigation();
    event_.navigation_ = navigation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.TabEvent.navigation)
}
inline ::vaelix::ui::NavigationRequest* TabEvent::_internal_mutable_navigation() {
  if (!_internal_has_navigation()) {
    clear_event();
    set_has_navigation();
    event_.navigation_ = CreateMaybeMessage< ::vaelix::ui::NavigationRequest >(GetArenaForAllocation());
  }
  return event_.navigation_;
}
inline ::vaelix::ui::NavigationRequest* TabEvent::mutable_navigation() {
  ::vaelix::ui::NavigationRequest* _msg = _internal_mutable_navigation();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabEvent.navigation)
  return _msg;
}

// .vaelix.ui.TabOperationRequest operation = 2;
inline bool TabEvent::_internal_has_operation() const {
  return event_case() == kOperation;
}
inline bool TabEvent::has_operation() const {
  return _internal_has_operation();
}
inline void TabEvent::set_has_operation() {
  _oneof_case_[0] = kOperation;
}
inline void TabEvent::clear_operation() {
  if (_internal_has_operation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.operation_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::TabOperationRequest* TabEvent::release_operation() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabEvent.operation)
  if (_internal_has_operation()) {
    clear_has_event();
      ::vaelix::ui::TabOperationRequest* temp = event_.operation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::TabOperationRequest& TabEvent::_internal_operation() const {
  return _internal_has_operation()
      ? *event_.operation_
      : reinterpret_cast< ::vaelix::ui::TabOperationRequest&>(::vaelix::ui::_TabOperationRequest_default_instance_);
}
inline const ::vaelix::ui::TabOperationRequest& TabEvent::operation() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.operation)
  return _internal_operation();
}
inline ::vaelix::ui::TabOperationRequest* TabEvent::unsafe_arena_release_operation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.TabEvent.operation)
  if (_internal_has_operation()) {
    clear_has_event();
    ::vaelix::ui::TabOperationRequest* temp = event_.operation_;
    event_.operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TabEvent::unsafe_arena_set_allocated_operation(::vaelix::ui::TabOperationRequest* operation) {
  clear_event();
  if (operation) {
    set_has_operation();
    event_.operation_ = operation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.TabEvent.operation)
}
inline ::vaelix::ui::TabOperationRequest* TabEvent::_internal_mutable_operation() {
  if (!_internal_has_operation()) {
    clear_event();
    set_has_operation();
    event_.operation_ = CreateMaybeMessage< ::vaelix::ui::TabOperationRequest >(GetArenaForAllocation());
  }
  return event_.operation_;
}
inline ::vaelix::ui::TabOperationRequest* TabEvent::mutable_operation() {
  ::vaelix::ui::TabOperationRequest* _msg = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabEvent.operation)
  return _msg;
}

// .vaelix.ui.FileDownloadEvent download = 3;
inline bool TabEvent::_internal_has_download() const {
  return event_case() == kDownload;
}
inline bool TabEvent::has_download() const {
  return _internal_has_download();
}
inline void TabEvent::set_has_download() {
  _oneof_case_[0] = kDownload;
}
inline void TabEvent::clear_download() {
  if (_internal_has_download()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.download_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::FileDownloadEvent* TabEvent::release_download() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabEvent.download)
  if (_internal_has_download()) {
    clear_has_event();
      ::vaelix::ui::FileDownloadEvent* temp = event_.download_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::FileDownloadEvent& TabEvent::_internal_download() const {
  return _internal_has_download()
      ? *event_.download_
      : reinterpret_cast< ::vaelix::ui::FileDownloadEvent&>(::vaelix::ui::_FileDownloadEvent_default_instance_);
}
inline const ::vaelix::ui::FileDownloadEvent& TabEvent::download() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.download)
  return _internal_download();
}
inline ::vaelix::ui::FileDownloadEvent* TabEvent::unsafe_arena_release_download() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.TabEvent.download)
  if (_internal_has_download()) {
    clear_has_event();
    ::vaelix::ui::FileDownloadEvent* temp = event_.download_;
    event_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TabEvent::unsafe_arena_set_allocated_download(::vaelix::ui::FileDownloadEvent* download) {
  clear_event();
  if (download) {
    set_has_download();
    event_.download_ = download;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.TabEvent.download)
}
inline ::vaelix::ui::FileDownloadEvent* TabEvent::_internal_mutable_download() {
  if (!_internal_has_download()) {
    clear_event();
    set_has_download();
    event_.download_ = CreateMaybeMessage< ::vaelix::ui::FileDownloadEvent >(GetArenaForAllocation());
  }
  return event_.download_;
}
inline ::vaelix::ui::FileDownloadEvent* TabEvent::mutable_download() {
  ::vaelix::ui::FileDownloadEvent* _msg = _internal_mutable_download();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabEvent.download)
  return _msg;
}

// string tab_error = 4;
inline bool TabEvent::_internal_has_tab_error() const {
  return event_case() == kTabError;
}
inline bool TabEvent::has_tab_error() const {
  return _internal_has_tab_error();
}
inline void TabEvent::set_has_tab_error() {
  _oneof_case_[0] = kTabError;
}
inline void TabEvent::clear_tab_error() {
  if (_internal_has_tab_error()) {
    event_.tab_error_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_event();
  }
}
inline const std::string& TabEvent::tab_error() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.tab_error)
  return _internal_tab_error();
}
template <typename ArgT0, typename... ArgT>
inline void TabEvent::set_tab_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tab_error()) {
    clear_event();
    set_has_tab_error();
    event_.tab_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.tab_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.ui.TabEvent.tab_error)
}
inline std::string* TabEvent::mutable_tab_error() {
  std::string* _s = _internal_mutable_tab_error();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.TabEvent.tab_error)
  return _s;
}
inline const std::string& TabEvent::_internal_tab_error() const {
  if (_internal_has_tab_error()) {
    return event_.tab_error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TabEvent::_internal_set_tab_error(const std::string& value) {
  if (!_internal_has_tab_error()) {
    clear_event();
    set_has_tab_error();
    event_.tab_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  event_.tab_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TabEvent::_internal_mutable_tab_error() {
  if (!_internal_has_tab_error()) {
    clear_event();
    set_has_tab_error();
    event_.tab_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return event_.tab_error_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TabEvent::release_tab_error() {
  // @@protoc_insertion_point(field_release:vaelix.ui.TabEvent.tab_error)
  if (_internal_has_tab_error()) {
    clear_has_event();
    return event_.tab_error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TabEvent::set_allocated_tab_error(std::string* tab_error) {
  if (has_event()) {
    clear_event();
  }
  if (tab_error != nullptr) {
    set_has_tab_error();
    event_.tab_error_.UnsafeSetDefault(tab_error);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(tab_error);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:vaelix.ui.TabEvent.tab_error)
}

// int32 tab_id = 5;
inline void TabEvent::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t TabEvent::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t TabEvent::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.tab_id)
  return _internal_tab_id();
}
inline void TabEvent::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void TabEvent::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabEvent.tab_id)
}

// int32 window_id = 6;
inline void TabEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t TabEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t TabEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.window_id)
  return _internal_window_id();
}
inline void TabEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void TabEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabEvent.window_id)
}

// int64 timestamp = 7;
inline void TabEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t TabEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t TabEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabEvent.timestamp)
  return _internal_timestamp();
}
inline void TabEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void TabEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabEvent.timestamp)
}

inline bool TabEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void TabEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline TabEvent::EventCase TabEvent::event_case() const {
  return TabEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InputEvent

// .vaelix.ui.KeyboardEvent keyboard = 1;
inline bool InputEvent::_internal_has_keyboard() const {
  return event_case() == kKeyboard;
}
inline bool InputEvent::has_keyboard() const {
  return _internal_has_keyboard();
}
inline void InputEvent::set_has_keyboard() {
  _oneof_case_[0] = kKeyboard;
}
inline void InputEvent::clear_keyboard() {
  if (_internal_has_keyboard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.keyboard_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::KeyboardEvent* InputEvent::release_keyboard() {
  // @@protoc_insertion_point(field_release:vaelix.ui.InputEvent.keyboard)
  if (_internal_has_keyboard()) {
    clear_has_event();
      ::vaelix::ui::KeyboardEvent* temp = event_.keyboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.keyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::KeyboardEvent& InputEvent::_internal_keyboard() const {
  return _internal_has_keyboard()
      ? *event_.keyboard_
      : reinterpret_cast< ::vaelix::ui::KeyboardEvent&>(::vaelix::ui::_KeyboardEvent_default_instance_);
}
inline const ::vaelix::ui::KeyboardEvent& InputEvent::keyboard() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.InputEvent.keyboard)
  return _internal_keyboard();
}
inline ::vaelix::ui::KeyboardEvent* InputEvent::unsafe_arena_release_keyboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.InputEvent.keyboard)
  if (_internal_has_keyboard()) {
    clear_has_event();
    ::vaelix::ui::KeyboardEvent* temp = event_.keyboard_;
    event_.keyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputEvent::unsafe_arena_set_allocated_keyboard(::vaelix::ui::KeyboardEvent* keyboard) {
  clear_event();
  if (keyboard) {
    set_has_keyboard();
    event_.keyboard_ = keyboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.InputEvent.keyboard)
}
inline ::vaelix::ui::KeyboardEvent* InputEvent::_internal_mutable_keyboard() {
  if (!_internal_has_keyboard()) {
    clear_event();
    set_has_keyboard();
    event_.keyboard_ = CreateMaybeMessage< ::vaelix::ui::KeyboardEvent >(GetArenaForAllocation());
  }
  return event_.keyboard_;
}
inline ::vaelix::ui::KeyboardEvent* InputEvent::mutable_keyboard() {
  ::vaelix::ui::KeyboardEvent* _msg = _internal_mutable_keyboard();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.InputEvent.keyboard)
  return _msg;
}

// .vaelix.ui.MouseEvent mouse = 2;
inline bool InputEvent::_internal_has_mouse() const {
  return event_case() == kMouse;
}
inline bool InputEvent::has_mouse() const {
  return _internal_has_mouse();
}
inline void InputEvent::set_has_mouse() {
  _oneof_case_[0] = kMouse;
}
inline void InputEvent::clear_mouse() {
  if (_internal_has_mouse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.mouse_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::MouseEvent* InputEvent::release_mouse() {
  // @@protoc_insertion_point(field_release:vaelix.ui.InputEvent.mouse)
  if (_internal_has_mouse()) {
    clear_has_event();
      ::vaelix::ui::MouseEvent* temp = event_.mouse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.mouse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::MouseEvent& InputEvent::_internal_mouse() const {
  return _internal_has_mouse()
      ? *event_.mouse_
      : reinterpret_cast< ::vaelix::ui::MouseEvent&>(::vaelix::ui::_MouseEvent_default_instance_);
}
inline const ::vaelix::ui::MouseEvent& InputEvent::mouse() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.InputEvent.mouse)
  return _internal_mouse();
}
inline ::vaelix::ui::MouseEvent* InputEvent::unsafe_arena_release_mouse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.InputEvent.mouse)
  if (_internal_has_mouse()) {
    clear_has_event();
    ::vaelix::ui::MouseEvent* temp = event_.mouse_;
    event_.mouse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputEvent::unsafe_arena_set_allocated_mouse(::vaelix::ui::MouseEvent* mouse) {
  clear_event();
  if (mouse) {
    set_has_mouse();
    event_.mouse_ = mouse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.InputEvent.mouse)
}
inline ::vaelix::ui::MouseEvent* InputEvent::_internal_mutable_mouse() {
  if (!_internal_has_mouse()) {
    clear_event();
    set_has_mouse();
    event_.mouse_ = CreateMaybeMessage< ::vaelix::ui::MouseEvent >(GetArenaForAllocation());
  }
  return event_.mouse_;
}
inline ::vaelix::ui::MouseEvent* InputEvent::mutable_mouse() {
  ::vaelix::ui::MouseEvent* _msg = _internal_mutable_mouse();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.InputEvent.mouse)
  return _msg;
}

// .vaelix.ui.ShortcutEvent shortcut = 3;
inline bool InputEvent::_internal_has_shortcut() const {
  return event_case() == kShortcut;
}
inline bool InputEvent::has_shortcut() const {
  return _internal_has_shortcut();
}
inline void InputEvent::set_has_shortcut() {
  _oneof_case_[0] = kShortcut;
}
inline void InputEvent::clear_shortcut() {
  if (_internal_has_shortcut()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.shortcut_;
    }
    clear_has_event();
  }
}
inline ::vaelix::ui::ShortcutEvent* InputEvent::release_shortcut() {
  // @@protoc_insertion_point(field_release:vaelix.ui.InputEvent.shortcut)
  if (_internal_has_shortcut()) {
    clear_has_event();
      ::vaelix::ui::ShortcutEvent* temp = event_.shortcut_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.shortcut_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vaelix::ui::ShortcutEvent& InputEvent::_internal_shortcut() const {
  return _internal_has_shortcut()
      ? *event_.shortcut_
      : reinterpret_cast< ::vaelix::ui::ShortcutEvent&>(::vaelix::ui::_ShortcutEvent_default_instance_);
}
inline const ::vaelix::ui::ShortcutEvent& InputEvent::shortcut() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.InputEvent.shortcut)
  return _internal_shortcut();
}
inline ::vaelix::ui::ShortcutEvent* InputEvent::unsafe_arena_release_shortcut() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vaelix.ui.InputEvent.shortcut)
  if (_internal_has_shortcut()) {
    clear_has_event();
    ::vaelix::ui::ShortcutEvent* temp = event_.shortcut_;
    event_.shortcut_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputEvent::unsafe_arena_set_allocated_shortcut(::vaelix::ui::ShortcutEvent* shortcut) {
  clear_event();
  if (shortcut) {
    set_has_shortcut();
    event_.shortcut_ = shortcut;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.ui.InputEvent.shortcut)
}
inline ::vaelix::ui::ShortcutEvent* InputEvent::_internal_mutable_shortcut() {
  if (!_internal_has_shortcut()) {
    clear_event();
    set_has_shortcut();
    event_.shortcut_ = CreateMaybeMessage< ::vaelix::ui::ShortcutEvent >(GetArenaForAllocation());
  }
  return event_.shortcut_;
}
inline ::vaelix::ui::ShortcutEvent* InputEvent::mutable_shortcut() {
  ::vaelix::ui::ShortcutEvent* _msg = _internal_mutable_shortcut();
  // @@protoc_insertion_point(field_mutable:vaelix.ui.InputEvent.shortcut)
  return _msg;
}

// int32 window_id = 4;
inline void InputEvent::clear_window_id() {
  window_id_ = 0;
}
inline int32_t InputEvent::_internal_window_id() const {
  return window_id_;
}
inline int32_t InputEvent::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.InputEvent.window_id)
  return _internal_window_id();
}
inline void InputEvent::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void InputEvent::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.InputEvent.window_id)
}

// int64 timestamp = 5;
inline void InputEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t InputEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t InputEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.InputEvent.timestamp)
  return _internal_timestamp();
}
inline void InputEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void InputEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.InputEvent.timestamp)
}

inline bool InputEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void InputEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline InputEvent::EventCase InputEvent::event_case() const {
  return InputEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UIStateQuery

// int32 window_id = 1;
inline void UIStateQuery::clear_window_id() {
  window_id_ = 0;
}
inline int32_t UIStateQuery::_internal_window_id() const {
  return window_id_;
}
inline int32_t UIStateQuery::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateQuery.window_id)
  return _internal_window_id();
}
inline void UIStateQuery::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void UIStateQuery::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateQuery.window_id)
}

// repeated string fields = 2;
inline int UIStateQuery::_internal_fields_size() const {
  return fields_.size();
}
inline int UIStateQuery::fields_size() const {
  return _internal_fields_size();
}
inline void UIStateQuery::clear_fields() {
  fields_.Clear();
}
inline std::string* UIStateQuery::add_fields() {
  std::string* _s = _internal_add_fields();
  // @@protoc_insertion_point(field_add_mutable:vaelix.ui.UIStateQuery.fields)
  return _s;
}
inline const std::string& UIStateQuery::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const std::string& UIStateQuery::fields(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.ui.UIStateQuery.fields)
  return _internal_fields(index);
}
inline std::string* UIStateQuery::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.ui.UIStateQuery.fields)
  return fields_.Mutable(index);
}
inline void UIStateQuery::set_fields(int index, const std::string& value) {
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::set_fields(int index, std::string&& value) {
  fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.ui.UIStateQuery.fields)
}
inline std::string* UIStateQuery::_internal_add_fields() {
  return fields_.Add();
}
inline void UIStateQuery::add_fields(const std::string& value) {
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::add_fields(std::string&& value) {
  fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::add_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.ui.UIStateQuery.fields)
}
inline void UIStateQuery::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.ui.UIStateQuery.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UIStateQuery::fields() const {
  // @@protoc_insertion_point(field_list:vaelix.ui.UIStateQuery.fields)
  return fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UIStateQuery::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.ui.UIStateQuery.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// WindowInfoRequest

// int32 window_id = 1;
inline void WindowInfoRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WindowInfoRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t WindowInfoRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.WindowInfoRequest.window_id)
  return _internal_window_id();
}
inline void WindowInfoRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WindowInfoRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.WindowInfoRequest.window_id)
}

// -------------------------------------------------------------------

// TabStatesRequest

// int32 window_id = 1;
inline void TabStatesRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t TabStatesRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t TabStatesRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStatesRequest.window_id)
  return _internal_window_id();
}
inline void TabStatesRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void TabStatesRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStatesRequest.window_id)
}

// bool include_inactive = 2;
inline void TabStatesRequest::clear_include_inactive() {
  include_inactive_ = false;
}
inline bool TabStatesRequest::_internal_include_inactive() const {
  return include_inactive_;
}
inline bool TabStatesRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:vaelix.ui.TabStatesRequest.include_inactive)
  return _internal_include_inactive();
}
inline void TabStatesRequest::_internal_set_include_inactive(bool value) {
  
  include_inactive_ = value;
}
inline void TabStatesRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:vaelix.ui.TabStatesRequest.include_inactive)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ui
}  // namespace vaelix

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ui_5fevents_2eproto
