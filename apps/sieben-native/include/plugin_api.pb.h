// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plugin_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_plugin_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_plugin_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_plugin_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_plugin_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[47]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plugin_5fapi_2eproto;
namespace vaelix {
namespace plugin {
class ApplyThemeRequest;
struct ApplyThemeRequestDefaultTypeInternal;
extern ApplyThemeRequestDefaultTypeInternal _ApplyThemeRequest_default_instance_;
class ApplyThemeResponse;
struct ApplyThemeResponseDefaultTypeInternal;
extern ApplyThemeResponseDefaultTypeInternal _ApplyThemeResponse_default_instance_;
class GetPluginConfigRequest;
struct GetPluginConfigRequestDefaultTypeInternal;
extern GetPluginConfigRequestDefaultTypeInternal _GetPluginConfigRequest_default_instance_;
class GetPluginConfigResponse;
struct GetPluginConfigResponseDefaultTypeInternal;
extern GetPluginConfigResponseDefaultTypeInternal _GetPluginConfigResponse_default_instance_;
class GetPluginConfigResponse_ConfigEntry_DoNotUse;
struct GetPluginConfigResponse_ConfigEntry_DoNotUseDefaultTypeInternal;
extern GetPluginConfigResponse_ConfigEntry_DoNotUseDefaultTypeInternal _GetPluginConfigResponse_ConfigEntry_DoNotUse_default_instance_;
class GetThemesRequest;
struct GetThemesRequestDefaultTypeInternal;
extern GetThemesRequestDefaultTypeInternal _GetThemesRequest_default_instance_;
class GetThemesResponse;
struct GetThemesResponseDefaultTypeInternal;
extern GetThemesResponseDefaultTypeInternal _GetThemesResponse_default_instance_;
class InstallThemeRequest;
struct InstallThemeRequestDefaultTypeInternal;
extern InstallThemeRequestDefaultTypeInternal _InstallThemeRequest_default_instance_;
class InstallThemeResponse;
struct InstallThemeResponseDefaultTypeInternal;
extern InstallThemeResponseDefaultTypeInternal _InstallThemeResponse_default_instance_;
class MakeNetworkRequestRequest;
struct MakeNetworkRequestRequestDefaultTypeInternal;
extern MakeNetworkRequestRequestDefaultTypeInternal _MakeNetworkRequestRequest_default_instance_;
class MakeNetworkRequestResponse;
struct MakeNetworkRequestResponseDefaultTypeInternal;
extern MakeNetworkRequestResponseDefaultTypeInternal _MakeNetworkRequestResponse_default_instance_;
class NetworkRequest;
struct NetworkRequestDefaultTypeInternal;
extern NetworkRequestDefaultTypeInternal _NetworkRequest_default_instance_;
class NetworkRequest_HeadersEntry_DoNotUse;
struct NetworkRequest_HeadersEntry_DoNotUseDefaultTypeInternal;
extern NetworkRequest_HeadersEntry_DoNotUseDefaultTypeInternal _NetworkRequest_HeadersEntry_DoNotUse_default_instance_;
class NetworkResponse;
struct NetworkResponseDefaultTypeInternal;
extern NetworkResponseDefaultTypeInternal _NetworkResponse_default_instance_;
class NetworkResponse_HeadersEntry_DoNotUse;
struct NetworkResponse_HeadersEntry_DoNotUseDefaultTypeInternal;
extern NetworkResponse_HeadersEntry_DoNotUseDefaultTypeInternal _NetworkResponse_HeadersEntry_DoNotUse_default_instance_;
class PluginConfigUpdate;
struct PluginConfigUpdateDefaultTypeInternal;
extern PluginConfigUpdateDefaultTypeInternal _PluginConfigUpdate_default_instance_;
class PluginConfigUpdate_ConfigEntry_DoNotUse;
struct PluginConfigUpdate_ConfigEntry_DoNotUseDefaultTypeInternal;
extern PluginConfigUpdate_ConfigEntry_DoNotUseDefaultTypeInternal _PluginConfigUpdate_ConfigEntry_DoNotUse_default_instance_;
class PluginEvent;
struct PluginEventDefaultTypeInternal;
extern PluginEventDefaultTypeInternal _PluginEvent_default_instance_;
class PluginEventHook;
struct PluginEventHookDefaultTypeInternal;
extern PluginEventHookDefaultTypeInternal _PluginEventHook_default_instance_;
class PluginEventHooksResponse;
struct PluginEventHooksResponseDefaultTypeInternal;
extern PluginEventHooksResponseDefaultTypeInternal _PluginEventHooksResponse_default_instance_;
class PluginEvent_DataEntry_DoNotUse;
struct PluginEvent_DataEntry_DoNotUseDefaultTypeInternal;
extern PluginEvent_DataEntry_DoNotUseDefaultTypeInternal _PluginEvent_DataEntry_DoNotUse_default_instance_;
class PluginInfo;
struct PluginInfoDefaultTypeInternal;
extern PluginInfoDefaultTypeInternal _PluginInfo_default_instance_;
class PluginListRequest;
struct PluginListRequestDefaultTypeInternal;
extern PluginListRequestDefaultTypeInternal _PluginListRequest_default_instance_;
class PluginListResponse;
struct PluginListResponseDefaultTypeInternal;
extern PluginListResponseDefaultTypeInternal _PluginListResponse_default_instance_;
class PluginLoadRequest;
struct PluginLoadRequestDefaultTypeInternal;
extern PluginLoadRequestDefaultTypeInternal _PluginLoadRequest_default_instance_;
class PluginLoadRequest_ConfigEntry_DoNotUse;
struct PluginLoadRequest_ConfigEntry_DoNotUseDefaultTypeInternal;
extern PluginLoadRequest_ConfigEntry_DoNotUseDefaultTypeInternal _PluginLoadRequest_ConfigEntry_DoNotUse_default_instance_;
class PluginLoadResponse;
struct PluginLoadResponseDefaultTypeInternal;
extern PluginLoadResponseDefaultTypeInternal _PluginLoadResponse_default_instance_;
class PluginUnloadRequest;
struct PluginUnloadRequestDefaultTypeInternal;
extern PluginUnloadRequestDefaultTypeInternal _PluginUnloadRequest_default_instance_;
class PluginUnloadResponse;
struct PluginUnloadResponseDefaultTypeInternal;
extern PluginUnloadResponseDefaultTypeInternal _PluginUnloadResponse_default_instance_;
class RegisterEventHookRequest;
struct RegisterEventHookRequestDefaultTypeInternal;
extern RegisterEventHookRequestDefaultTypeInternal _RegisterEventHookRequest_default_instance_;
class RegisterEventHookResponse;
struct RegisterEventHookResponseDefaultTypeInternal;
extern RegisterEventHookResponseDefaultTypeInternal _RegisterEventHookResponse_default_instance_;
class SetPluginConfigRequest;
struct SetPluginConfigRequestDefaultTypeInternal;
extern SetPluginConfigRequestDefaultTypeInternal _SetPluginConfigRequest_default_instance_;
class SetPluginConfigRequest_ConfigEntry_DoNotUse;
struct SetPluginConfigRequest_ConfigEntry_DoNotUseDefaultTypeInternal;
extern SetPluginConfigRequest_ConfigEntry_DoNotUseDefaultTypeInternal _SetPluginConfigRequest_ConfigEntry_DoNotUse_default_instance_;
class SetPluginConfigResponse;
struct SetPluginConfigResponseDefaultTypeInternal;
extern SetPluginConfigResponseDefaultTypeInternal _SetPluginConfigResponse_default_instance_;
class SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse;
struct SetPluginConfigResponse_ValidatedConfigEntry_DoNotUseDefaultTypeInternal;
extern SetPluginConfigResponse_ValidatedConfigEntry_DoNotUseDefaultTypeInternal _SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse_default_instance_;
class ThemeInfo;
struct ThemeInfoDefaultTypeInternal;
extern ThemeInfoDefaultTypeInternal _ThemeInfo_default_instance_;
class ThemeInfo_PropertiesEntry_DoNotUse;
struct ThemeInfo_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern ThemeInfo_PropertiesEntry_DoNotUseDefaultTypeInternal _ThemeInfo_PropertiesEntry_DoNotUse_default_instance_;
class UnregisterEventHookRequest;
struct UnregisterEventHookRequestDefaultTypeInternal;
extern UnregisterEventHookRequestDefaultTypeInternal _UnregisterEventHookRequest_default_instance_;
class UnregisterEventHookResponse;
struct UnregisterEventHookResponseDefaultTypeInternal;
extern UnregisterEventHookResponseDefaultTypeInternal _UnregisterEventHookResponse_default_instance_;
class WidgetCreateRequest;
struct WidgetCreateRequestDefaultTypeInternal;
extern WidgetCreateRequestDefaultTypeInternal _WidgetCreateRequest_default_instance_;
class WidgetCreateRequest_PropertiesEntry_DoNotUse;
struct WidgetCreateRequest_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern WidgetCreateRequest_PropertiesEntry_DoNotUseDefaultTypeInternal _WidgetCreateRequest_PropertiesEntry_DoNotUse_default_instance_;
class WidgetCreateResponse;
struct WidgetCreateResponseDefaultTypeInternal;
extern WidgetCreateResponseDefaultTypeInternal _WidgetCreateResponse_default_instance_;
class WidgetCreateResponse_WidgetDataEntry_DoNotUse;
struct WidgetCreateResponse_WidgetDataEntry_DoNotUseDefaultTypeInternal;
extern WidgetCreateResponse_WidgetDataEntry_DoNotUseDefaultTypeInternal _WidgetCreateResponse_WidgetDataEntry_DoNotUse_default_instance_;
class WidgetModifyRequest;
struct WidgetModifyRequestDefaultTypeInternal;
extern WidgetModifyRequestDefaultTypeInternal _WidgetModifyRequest_default_instance_;
class WidgetModifyRequest_PropertiesEntry_DoNotUse;
struct WidgetModifyRequest_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern WidgetModifyRequest_PropertiesEntry_DoNotUseDefaultTypeInternal _WidgetModifyRequest_PropertiesEntry_DoNotUse_default_instance_;
class WidgetModifyResponse;
struct WidgetModifyResponseDefaultTypeInternal;
extern WidgetModifyResponseDefaultTypeInternal _WidgetModifyResponse_default_instance_;
class WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse;
struct WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUseDefaultTypeInternal;
extern WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUseDefaultTypeInternal _WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse_default_instance_;
}  // namespace plugin
}  // namespace vaelix
PROTOBUF_NAMESPACE_OPEN
template<> ::vaelix::plugin::ApplyThemeRequest* Arena::CreateMaybeMessage<::vaelix::plugin::ApplyThemeRequest>(Arena*);
template<> ::vaelix::plugin::ApplyThemeResponse* Arena::CreateMaybeMessage<::vaelix::plugin::ApplyThemeResponse>(Arena*);
template<> ::vaelix::plugin::GetPluginConfigRequest* Arena::CreateMaybeMessage<::vaelix::plugin::GetPluginConfigRequest>(Arena*);
template<> ::vaelix::plugin::GetPluginConfigResponse* Arena::CreateMaybeMessage<::vaelix::plugin::GetPluginConfigResponse>(Arena*);
template<> ::vaelix::plugin::GetPluginConfigResponse_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::GetPluginConfigResponse_ConfigEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::GetThemesRequest* Arena::CreateMaybeMessage<::vaelix::plugin::GetThemesRequest>(Arena*);
template<> ::vaelix::plugin::GetThemesResponse* Arena::CreateMaybeMessage<::vaelix::plugin::GetThemesResponse>(Arena*);
template<> ::vaelix::plugin::InstallThemeRequest* Arena::CreateMaybeMessage<::vaelix::plugin::InstallThemeRequest>(Arena*);
template<> ::vaelix::plugin::InstallThemeResponse* Arena::CreateMaybeMessage<::vaelix::plugin::InstallThemeResponse>(Arena*);
template<> ::vaelix::plugin::MakeNetworkRequestRequest* Arena::CreateMaybeMessage<::vaelix::plugin::MakeNetworkRequestRequest>(Arena*);
template<> ::vaelix::plugin::MakeNetworkRequestResponse* Arena::CreateMaybeMessage<::vaelix::plugin::MakeNetworkRequestResponse>(Arena*);
template<> ::vaelix::plugin::NetworkRequest* Arena::CreateMaybeMessage<::vaelix::plugin::NetworkRequest>(Arena*);
template<> ::vaelix::plugin::NetworkRequest_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::NetworkRequest_HeadersEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::NetworkResponse* Arena::CreateMaybeMessage<::vaelix::plugin::NetworkResponse>(Arena*);
template<> ::vaelix::plugin::NetworkResponse_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::NetworkResponse_HeadersEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::PluginConfigUpdate* Arena::CreateMaybeMessage<::vaelix::plugin::PluginConfigUpdate>(Arena*);
template<> ::vaelix::plugin::PluginConfigUpdate_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginConfigUpdate_ConfigEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::PluginEvent* Arena::CreateMaybeMessage<::vaelix::plugin::PluginEvent>(Arena*);
template<> ::vaelix::plugin::PluginEventHook* Arena::CreateMaybeMessage<::vaelix::plugin::PluginEventHook>(Arena*);
template<> ::vaelix::plugin::PluginEventHooksResponse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginEventHooksResponse>(Arena*);
template<> ::vaelix::plugin::PluginEvent_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginEvent_DataEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::PluginInfo* Arena::CreateMaybeMessage<::vaelix::plugin::PluginInfo>(Arena*);
template<> ::vaelix::plugin::PluginListRequest* Arena::CreateMaybeMessage<::vaelix::plugin::PluginListRequest>(Arena*);
template<> ::vaelix::plugin::PluginListResponse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginListResponse>(Arena*);
template<> ::vaelix::plugin::PluginLoadRequest* Arena::CreateMaybeMessage<::vaelix::plugin::PluginLoadRequest>(Arena*);
template<> ::vaelix::plugin::PluginLoadRequest_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginLoadRequest_ConfigEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::PluginLoadResponse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginLoadResponse>(Arena*);
template<> ::vaelix::plugin::PluginUnloadRequest* Arena::CreateMaybeMessage<::vaelix::plugin::PluginUnloadRequest>(Arena*);
template<> ::vaelix::plugin::PluginUnloadResponse* Arena::CreateMaybeMessage<::vaelix::plugin::PluginUnloadResponse>(Arena*);
template<> ::vaelix::plugin::RegisterEventHookRequest* Arena::CreateMaybeMessage<::vaelix::plugin::RegisterEventHookRequest>(Arena*);
template<> ::vaelix::plugin::RegisterEventHookResponse* Arena::CreateMaybeMessage<::vaelix::plugin::RegisterEventHookResponse>(Arena*);
template<> ::vaelix::plugin::SetPluginConfigRequest* Arena::CreateMaybeMessage<::vaelix::plugin::SetPluginConfigRequest>(Arena*);
template<> ::vaelix::plugin::SetPluginConfigRequest_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::SetPluginConfigRequest_ConfigEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::SetPluginConfigResponse* Arena::CreateMaybeMessage<::vaelix::plugin::SetPluginConfigResponse>(Arena*);
template<> ::vaelix::plugin::SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::ThemeInfo* Arena::CreateMaybeMessage<::vaelix::plugin::ThemeInfo>(Arena*);
template<> ::vaelix::plugin::ThemeInfo_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::ThemeInfo_PropertiesEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::UnregisterEventHookRequest* Arena::CreateMaybeMessage<::vaelix::plugin::UnregisterEventHookRequest>(Arena*);
template<> ::vaelix::plugin::UnregisterEventHookResponse* Arena::CreateMaybeMessage<::vaelix::plugin::UnregisterEventHookResponse>(Arena*);
template<> ::vaelix::plugin::WidgetCreateRequest* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetCreateRequest>(Arena*);
template<> ::vaelix::plugin::WidgetCreateRequest_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetCreateRequest_PropertiesEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::WidgetCreateResponse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetCreateResponse>(Arena*);
template<> ::vaelix::plugin::WidgetCreateResponse_WidgetDataEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetCreateResponse_WidgetDataEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::WidgetModifyRequest* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetModifyRequest>(Arena*);
template<> ::vaelix::plugin::WidgetModifyRequest_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetModifyRequest_PropertiesEntry_DoNotUse>(Arena*);
template<> ::vaelix::plugin::WidgetModifyResponse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetModifyResponse>(Arena*);
template<> ::vaelix::plugin::WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::vaelix::plugin::WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vaelix {
namespace plugin {

// ===================================================================

class PluginInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginInfo) */ {
 public:
  inline PluginInfo() : PluginInfo(nullptr) {}
  ~PluginInfo() override;
  explicit constexpr PluginInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginInfo(const PluginInfo& from);
  PluginInfo(PluginInfo&& from) noexcept
    : PluginInfo() {
    *this = ::std::move(from);
  }

  inline PluginInfo& operator=(const PluginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginInfo& operator=(PluginInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginInfo* internal_default_instance() {
    return reinterpret_cast<const PluginInfo*>(
               &_PluginInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PluginInfo& a, PluginInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginInfo";
  }
  protected:
  explicit PluginInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 6,
    kDependenciesFieldNumber = 7,
    kPluginIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kAuthorFieldNumber = 5,
    kCpuUsageFieldNumber = 10,
    kMemoryUsageFieldNumber = 11,
    kIsEnabledFieldNumber = 8,
    kIsLoadedFieldNumber = 9,
  };
  // repeated string permissions = 6;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();
  private:
  const std::string& _internal_permissions(int index) const;
  std::string* _internal_add_permissions();
  public:

  // repeated string dependencies = 7;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;
  public:
  void clear_dependencies();
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  void set_dependencies(int index, const std::string& value);
  void set_dependencies(int index, std::string&& value);
  void set_dependencies(int index, const char* value);
  void set_dependencies(int index, const char* value, size_t size);
  std::string* add_dependencies();
  void add_dependencies(const std::string& value);
  void add_dependencies(std::string&& value);
  void add_dependencies(const char* value);
  void add_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dependencies();
  private:
  const std::string& _internal_dependencies(int index) const;
  std::string* _internal_add_dependencies();
  public:

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string author = 5;
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // double cpu_usage = 10;
  void clear_cpu_usage();
  double cpu_usage() const;
  void set_cpu_usage(double value);
  private:
  double _internal_cpu_usage() const;
  void _internal_set_cpu_usage(double value);
  public:

  // int64 memory_usage = 11;
  void clear_memory_usage();
  int64_t memory_usage() const;
  void set_memory_usage(int64_t value);
  private:
  int64_t _internal_memory_usage() const;
  void _internal_set_memory_usage(int64_t value);
  public:

  // bool is_enabled = 8;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // bool is_loaded = 9;
  void clear_is_loaded();
  bool is_loaded() const;
  void set_is_loaded(bool value);
  private:
  bool _internal_is_loaded() const;
  void _internal_set_is_loaded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dependencies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
  double cpu_usage_;
  int64_t memory_usage_;
  bool is_enabled_;
  bool is_loaded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginLoadRequest_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginLoadRequest_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginLoadRequest_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PluginLoadRequest_ConfigEntry_DoNotUse();
  explicit constexpr PluginLoadRequest_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PluginLoadRequest_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PluginLoadRequest_ConfigEntry_DoNotUse& other);
  static const PluginLoadRequest_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PluginLoadRequest_ConfigEntry_DoNotUse*>(&_PluginLoadRequest_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginLoadRequest.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginLoadRequest.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class PluginLoadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginLoadRequest) */ {
 public:
  inline PluginLoadRequest() : PluginLoadRequest(nullptr) {}
  ~PluginLoadRequest() override;
  explicit constexpr PluginLoadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginLoadRequest(const PluginLoadRequest& from);
  PluginLoadRequest(PluginLoadRequest&& from) noexcept
    : PluginLoadRequest() {
    *this = ::std::move(from);
  }

  inline PluginLoadRequest& operator=(const PluginLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginLoadRequest& operator=(PluginLoadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginLoadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginLoadRequest* internal_default_instance() {
    return reinterpret_cast<const PluginLoadRequest*>(
               &_PluginLoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PluginLoadRequest& a, PluginLoadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginLoadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginLoadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginLoadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginLoadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginLoadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginLoadRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginLoadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginLoadRequest";
  }
  protected:
  explicit PluginLoadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 4,
    kPluginPathFieldNumber = 1,
    kPluginIdFieldNumber = 2,
    kEnableImmediatelyFieldNumber = 3,
  };
  // map<string, string> config = 4;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string plugin_path = 1;
  void clear_plugin_path();
  const std::string& plugin_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_path();
  PROTOBUF_NODISCARD std::string* release_plugin_path();
  void set_allocated_plugin_path(std::string* plugin_path);
  private:
  const std::string& _internal_plugin_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_path(const std::string& value);
  std::string* _internal_mutable_plugin_path();
  public:

  // string plugin_id = 2;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // bool enable_immediately = 3;
  void clear_enable_immediately();
  bool enable_immediately() const;
  void set_enable_immediately(bool value);
  private:
  bool _internal_enable_immediately() const;
  void _internal_set_enable_immediately(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginLoadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PluginLoadRequest_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  bool enable_immediately_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginLoadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginLoadResponse) */ {
 public:
  inline PluginLoadResponse() : PluginLoadResponse(nullptr) {}
  ~PluginLoadResponse() override;
  explicit constexpr PluginLoadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginLoadResponse(const PluginLoadResponse& from);
  PluginLoadResponse(PluginLoadResponse&& from) noexcept
    : PluginLoadResponse() {
    *this = ::std::move(from);
  }

  inline PluginLoadResponse& operator=(const PluginLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginLoadResponse& operator=(PluginLoadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginLoadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginLoadResponse* internal_default_instance() {
    return reinterpret_cast<const PluginLoadResponse*>(
               &_PluginLoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PluginLoadResponse& a, PluginLoadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginLoadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginLoadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginLoadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginLoadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginLoadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginLoadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginLoadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginLoadResponse";
  }
  protected:
  explicit PluginLoadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 4,
    kErrorMessageFieldNumber = 2,
    kPluginInfoFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated string warnings = 4;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .vaelix.plugin.PluginInfo plugin_info = 3;
  bool has_plugin_info() const;
  private:
  bool _internal_has_plugin_info() const;
  public:
  void clear_plugin_info();
  const ::vaelix::plugin::PluginInfo& plugin_info() const;
  PROTOBUF_NODISCARD ::vaelix::plugin::PluginInfo* release_plugin_info();
  ::vaelix::plugin::PluginInfo* mutable_plugin_info();
  void set_allocated_plugin_info(::vaelix::plugin::PluginInfo* plugin_info);
  private:
  const ::vaelix::plugin::PluginInfo& _internal_plugin_info() const;
  ::vaelix::plugin::PluginInfo* _internal_mutable_plugin_info();
  public:
  void unsafe_arena_set_allocated_plugin_info(
      ::vaelix::plugin::PluginInfo* plugin_info);
  ::vaelix::plugin::PluginInfo* unsafe_arena_release_plugin_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginLoadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::vaelix::plugin::PluginInfo* plugin_info_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginUnloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginUnloadRequest) */ {
 public:
  inline PluginUnloadRequest() : PluginUnloadRequest(nullptr) {}
  ~PluginUnloadRequest() override;
  explicit constexpr PluginUnloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginUnloadRequest(const PluginUnloadRequest& from);
  PluginUnloadRequest(PluginUnloadRequest&& from) noexcept
    : PluginUnloadRequest() {
    *this = ::std::move(from);
  }

  inline PluginUnloadRequest& operator=(const PluginUnloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginUnloadRequest& operator=(PluginUnloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginUnloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginUnloadRequest* internal_default_instance() {
    return reinterpret_cast<const PluginUnloadRequest*>(
               &_PluginUnloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PluginUnloadRequest& a, PluginUnloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginUnloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginUnloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginUnloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginUnloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginUnloadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginUnloadRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginUnloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginUnloadRequest";
  }
  protected:
  explicit PluginUnloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginIdFieldNumber = 1,
    kForceUnloadFieldNumber = 2,
  };
  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // bool force_unload = 2;
  void clear_force_unload();
  bool force_unload() const;
  void set_force_unload(bool value);
  private:
  bool _internal_force_unload() const;
  void _internal_set_force_unload(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginUnloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  bool force_unload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginUnloadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginUnloadResponse) */ {
 public:
  inline PluginUnloadResponse() : PluginUnloadResponse(nullptr) {}
  ~PluginUnloadResponse() override;
  explicit constexpr PluginUnloadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginUnloadResponse(const PluginUnloadResponse& from);
  PluginUnloadResponse(PluginUnloadResponse&& from) noexcept
    : PluginUnloadResponse() {
    *this = ::std::move(from);
  }

  inline PluginUnloadResponse& operator=(const PluginUnloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginUnloadResponse& operator=(PluginUnloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginUnloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginUnloadResponse* internal_default_instance() {
    return reinterpret_cast<const PluginUnloadResponse*>(
               &_PluginUnloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PluginUnloadResponse& a, PluginUnloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginUnloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginUnloadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginUnloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginUnloadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginUnloadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginUnloadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginUnloadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginUnloadResponse";
  }
  protected:
  explicit PluginUnloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCleanupTasksFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated string cleanup_tasks = 3;
  int cleanup_tasks_size() const;
  private:
  int _internal_cleanup_tasks_size() const;
  public:
  void clear_cleanup_tasks();
  const std::string& cleanup_tasks(int index) const;
  std::string* mutable_cleanup_tasks(int index);
  void set_cleanup_tasks(int index, const std::string& value);
  void set_cleanup_tasks(int index, std::string&& value);
  void set_cleanup_tasks(int index, const char* value);
  void set_cleanup_tasks(int index, const char* value, size_t size);
  std::string* add_cleanup_tasks();
  void add_cleanup_tasks(const std::string& value);
  void add_cleanup_tasks(std::string&& value);
  void add_cleanup_tasks(const char* value);
  void add_cleanup_tasks(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cleanup_tasks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cleanup_tasks();
  private:
  const std::string& _internal_cleanup_tasks(int index) const;
  std::string* _internal_add_cleanup_tasks();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginUnloadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cleanup_tasks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginEvent_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginEvent_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginEvent_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PluginEvent_DataEntry_DoNotUse();
  explicit constexpr PluginEvent_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PluginEvent_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PluginEvent_DataEntry_DoNotUse& other);
  static const PluginEvent_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PluginEvent_DataEntry_DoNotUse*>(&_PluginEvent_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginEvent.DataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginEvent.DataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class PluginEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginEvent) */ {
 public:
  inline PluginEvent() : PluginEvent(nullptr) {}
  ~PluginEvent() override;
  explicit constexpr PluginEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginEvent(const PluginEvent& from);
  PluginEvent(PluginEvent&& from) noexcept
    : PluginEvent() {
    *this = ::std::move(from);
  }

  inline PluginEvent& operator=(const PluginEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginEvent& operator=(PluginEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginEvent* internal_default_instance() {
    return reinterpret_cast<const PluginEvent*>(
               &_PluginEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PluginEvent& a, PluginEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginEvent";
  }
  protected:
  explicit PluginEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kEventTypeFieldNumber = 1,
    kPluginIdFieldNumber = 2,
    kTimestampFieldNumber = 4,
  };
  // map<string, string> data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data();

  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string plugin_id = 2;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PluginEvent_DataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginEventHook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginEventHook) */ {
 public:
  inline PluginEventHook() : PluginEventHook(nullptr) {}
  ~PluginEventHook() override;
  explicit constexpr PluginEventHook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginEventHook(const PluginEventHook& from);
  PluginEventHook(PluginEventHook&& from) noexcept
    : PluginEventHook() {
    *this = ::std::move(from);
  }

  inline PluginEventHook& operator=(const PluginEventHook& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginEventHook& operator=(PluginEventHook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginEventHook& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginEventHook* internal_default_instance() {
    return reinterpret_cast<const PluginEventHook*>(
               &_PluginEventHook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PluginEventHook& a, PluginEventHook& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginEventHook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginEventHook* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginEventHook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginEventHook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginEventHook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginEventHook& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginEventHook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginEventHook";
  }
  protected:
  explicit PluginEventHook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kPluginIdFieldNumber = 2,
    kHandlerNameFieldNumber = 3,
    kIsActiveFieldNumber = 4,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string plugin_id = 2;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string handler_name = 3;
  void clear_handler_name();
  const std::string& handler_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handler_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handler_name();
  PROTOBUF_NODISCARD std::string* release_handler_name();
  void set_allocated_handler_name(std::string* handler_name);
  private:
  const std::string& _internal_handler_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handler_name(const std::string& value);
  std::string* _internal_mutable_handler_name();
  public:

  // bool is_active = 4;
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginEventHook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handler_name_;
  bool is_active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class RegisterEventHookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.RegisterEventHookRequest) */ {
 public:
  inline RegisterEventHookRequest() : RegisterEventHookRequest(nullptr) {}
  ~RegisterEventHookRequest() override;
  explicit constexpr RegisterEventHookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEventHookRequest(const RegisterEventHookRequest& from);
  RegisterEventHookRequest(RegisterEventHookRequest&& from) noexcept
    : RegisterEventHookRequest() {
    *this = ::std::move(from);
  }

  inline RegisterEventHookRequest& operator=(const RegisterEventHookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEventHookRequest& operator=(RegisterEventHookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEventHookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEventHookRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterEventHookRequest*>(
               &_RegisterEventHookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegisterEventHookRequest& a, RegisterEventHookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEventHookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEventHookRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEventHookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEventHookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEventHookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterEventHookRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEventHookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.RegisterEventHookRequest";
  }
  protected:
  explicit RegisterEventHookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kHandlerNameFieldNumber = 3,
  };
  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string handler_name = 3;
  void clear_handler_name();
  const std::string& handler_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handler_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handler_name();
  PROTOBUF_NODISCARD std::string* release_handler_name();
  void set_allocated_handler_name(std::string* handler_name);
  private:
  const std::string& _internal_handler_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handler_name(const std::string& value);
  std::string* _internal_mutable_handler_name();
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.RegisterEventHookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handler_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class RegisterEventHookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.RegisterEventHookResponse) */ {
 public:
  inline RegisterEventHookResponse() : RegisterEventHookResponse(nullptr) {}
  ~RegisterEventHookResponse() override;
  explicit constexpr RegisterEventHookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEventHookResponse(const RegisterEventHookResponse& from);
  RegisterEventHookResponse(RegisterEventHookResponse&& from) noexcept
    : RegisterEventHookResponse() {
    *this = ::std::move(from);
  }

  inline RegisterEventHookResponse& operator=(const RegisterEventHookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEventHookResponse& operator=(RegisterEventHookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEventHookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEventHookResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterEventHookResponse*>(
               &_RegisterEventHookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RegisterEventHookResponse& a, RegisterEventHookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEventHookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEventHookResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEventHookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEventHookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEventHookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterEventHookResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEventHookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.RegisterEventHookResponse";
  }
  protected:
  explicit RegisterEventHookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kHookIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string hook_id = 3;
  void clear_hook_id();
  const std::string& hook_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hook_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hook_id();
  PROTOBUF_NODISCARD std::string* release_hook_id();
  void set_allocated_hook_id(std::string* hook_id);
  private:
  const std::string& _internal_hook_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hook_id(const std::string& value);
  std::string* _internal_mutable_hook_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.RegisterEventHookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hook_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UnregisterEventHookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.UnregisterEventHookRequest) */ {
 public:
  inline UnregisterEventHookRequest() : UnregisterEventHookRequest(nullptr) {}
  ~UnregisterEventHookRequest() override;
  explicit constexpr UnregisterEventHookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterEventHookRequest(const UnregisterEventHookRequest& from);
  UnregisterEventHookRequest(UnregisterEventHookRequest&& from) noexcept
    : UnregisterEventHookRequest() {
    *this = ::std::move(from);
  }

  inline UnregisterEventHookRequest& operator=(const UnregisterEventHookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterEventHookRequest& operator=(UnregisterEventHookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterEventHookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterEventHookRequest* internal_default_instance() {
    return reinterpret_cast<const UnregisterEventHookRequest*>(
               &_UnregisterEventHookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UnregisterEventHookRequest& a, UnregisterEventHookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterEventHookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterEventHookRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterEventHookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterEventHookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterEventHookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnregisterEventHookRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterEventHookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.UnregisterEventHookRequest";
  }
  protected:
  explicit UnregisterEventHookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kHookIdFieldNumber = 3,
  };
  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string hook_id = 3;
  void clear_hook_id();
  const std::string& hook_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hook_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hook_id();
  PROTOBUF_NODISCARD std::string* release_hook_id();
  void set_allocated_hook_id(std::string* hook_id);
  private:
  const std::string& _internal_hook_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hook_id(const std::string& value);
  std::string* _internal_mutable_hook_id();
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.UnregisterEventHookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hook_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UnregisterEventHookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.UnregisterEventHookResponse) */ {
 public:
  inline UnregisterEventHookResponse() : UnregisterEventHookResponse(nullptr) {}
  ~UnregisterEventHookResponse() override;
  explicit constexpr UnregisterEventHookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterEventHookResponse(const UnregisterEventHookResponse& from);
  UnregisterEventHookResponse(UnregisterEventHookResponse&& from) noexcept
    : UnregisterEventHookResponse() {
    *this = ::std::move(from);
  }

  inline UnregisterEventHookResponse& operator=(const UnregisterEventHookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterEventHookResponse& operator=(UnregisterEventHookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterEventHookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterEventHookResponse* internal_default_instance() {
    return reinterpret_cast<const UnregisterEventHookResponse*>(
               &_UnregisterEventHookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UnregisterEventHookResponse& a, UnregisterEventHookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterEventHookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterEventHookResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterEventHookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterEventHookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterEventHookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnregisterEventHookResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterEventHookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.UnregisterEventHookResponse";
  }
  protected:
  explicit UnregisterEventHookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.UnregisterEventHookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ThemeInfo_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ThemeInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ThemeInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ThemeInfo_PropertiesEntry_DoNotUse();
  explicit constexpr ThemeInfo_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ThemeInfo_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ThemeInfo_PropertiesEntry_DoNotUse& other);
  static const ThemeInfo_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ThemeInfo_PropertiesEntry_DoNotUse*>(&_ThemeInfo_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.ThemeInfo.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.ThemeInfo.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ThemeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.ThemeInfo) */ {
 public:
  inline ThemeInfo() : ThemeInfo(nullptr) {}
  ~ThemeInfo() override;
  explicit constexpr ThemeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemeInfo(const ThemeInfo& from);
  ThemeInfo(ThemeInfo&& from) noexcept
    : ThemeInfo() {
    *this = ::std::move(from);
  }

  inline ThemeInfo& operator=(const ThemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeInfo& operator=(ThemeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemeInfo* internal_default_instance() {
    return reinterpret_cast<const ThemeInfo*>(
               &_ThemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ThemeInfo& a, ThemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThemeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThemeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThemeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ThemeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.ThemeInfo";
  }
  protected:
  explicit ThemeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariantsFieldNumber = 6,
    kPropertiesFieldNumber = 8,
    kThemeIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kAuthorFieldNumber = 3,
    kVersionFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kPreviewImageFieldNumber = 7,
  };
  // repeated string variants = 6;
  int variants_size() const;
  private:
  int _internal_variants_size() const;
  public:
  void clear_variants();
  const std::string& variants(int index) const;
  std::string* mutable_variants(int index);
  void set_variants(int index, const std::string& value);
  void set_variants(int index, std::string&& value);
  void set_variants(int index, const char* value);
  void set_variants(int index, const char* value, size_t size);
  std::string* add_variants();
  void add_variants(const std::string& value);
  void add_variants(std::string&& value);
  void add_variants(const char* value);
  void add_variants(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& variants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_variants();
  private:
  const std::string& _internal_variants(int index) const;
  std::string* _internal_add_variants();
  public:

  // map<string, string> properties = 8;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string theme_id = 1;
  void clear_theme_id();
  const std::string& theme_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_theme_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_theme_id();
  PROTOBUF_NODISCARD std::string* release_theme_id();
  void set_allocated_theme_id(std::string* theme_id);
  private:
  const std::string& _internal_theme_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_theme_id(const std::string& value);
  std::string* _internal_mutable_theme_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string author = 3;
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // string version = 4;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes preview_image = 7;
  void clear_preview_image();
  const std::string& preview_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preview_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preview_image();
  PROTOBUF_NODISCARD std::string* release_preview_image();
  void set_allocated_preview_image(std::string* preview_image);
  private:
  const std::string& _internal_preview_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preview_image(const std::string& value);
  std::string* _internal_mutable_preview_image();
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.ThemeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> variants_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ThemeInfo_PropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr theme_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preview_image_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApplyThemeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.ApplyThemeRequest) */ {
 public:
  inline ApplyThemeRequest() : ApplyThemeRequest(nullptr) {}
  ~ApplyThemeRequest() override;
  explicit constexpr ApplyThemeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyThemeRequest(const ApplyThemeRequest& from);
  ApplyThemeRequest(ApplyThemeRequest&& from) noexcept
    : ApplyThemeRequest() {
    *this = ::std::move(from);
  }

  inline ApplyThemeRequest& operator=(const ApplyThemeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyThemeRequest& operator=(ApplyThemeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyThemeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyThemeRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyThemeRequest*>(
               &_ApplyThemeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ApplyThemeRequest& a, ApplyThemeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyThemeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyThemeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyThemeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyThemeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyThemeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyThemeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyThemeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.ApplyThemeRequest";
  }
  protected:
  explicit ApplyThemeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThemeIdFieldNumber = 1,
    kVariantFieldNumber = 2,
    kRestartRequiredFieldNumber = 3,
  };
  // string theme_id = 1;
  void clear_theme_id();
  const std::string& theme_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_theme_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_theme_id();
  PROTOBUF_NODISCARD std::string* release_theme_id();
  void set_allocated_theme_id(std::string* theme_id);
  private:
  const std::string& _internal_theme_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_theme_id(const std::string& value);
  std::string* _internal_mutable_theme_id();
  public:

  // string variant = 2;
  void clear_variant();
  const std::string& variant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variant();
  PROTOBUF_NODISCARD std::string* release_variant();
  void set_allocated_variant(std::string* variant);
  private:
  const std::string& _internal_variant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variant(const std::string& value);
  std::string* _internal_mutable_variant();
  public:

  // bool restart_required = 3;
  void clear_restart_required();
  bool restart_required() const;
  void set_restart_required(bool value);
  private:
  bool _internal_restart_required() const;
  void _internal_set_restart_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.ApplyThemeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr theme_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variant_;
  bool restart_required_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApplyThemeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.ApplyThemeResponse) */ {
 public:
  inline ApplyThemeResponse() : ApplyThemeResponse(nullptr) {}
  ~ApplyThemeResponse() override;
  explicit constexpr ApplyThemeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyThemeResponse(const ApplyThemeResponse& from);
  ApplyThemeResponse(ApplyThemeResponse&& from) noexcept
    : ApplyThemeResponse() {
    *this = ::std::move(from);
  }

  inline ApplyThemeResponse& operator=(const ApplyThemeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyThemeResponse& operator=(ApplyThemeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyThemeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyThemeResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyThemeResponse*>(
               &_ApplyThemeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ApplyThemeResponse& a, ApplyThemeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyThemeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyThemeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyThemeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyThemeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyThemeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyThemeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyThemeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.ApplyThemeResponse";
  }
  protected:
  explicit ApplyThemeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedComponentsFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated string affected_components = 3;
  int affected_components_size() const;
  private:
  int _internal_affected_components_size() const;
  public:
  void clear_affected_components();
  const std::string& affected_components(int index) const;
  std::string* mutable_affected_components(int index);
  void set_affected_components(int index, const std::string& value);
  void set_affected_components(int index, std::string&& value);
  void set_affected_components(int index, const char* value);
  void set_affected_components(int index, const char* value, size_t size);
  std::string* add_affected_components();
  void add_affected_components(const std::string& value);
  void add_affected_components(std::string&& value);
  void add_affected_components(const char* value);
  void add_affected_components(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& affected_components() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_affected_components();
  private:
  const std::string& _internal_affected_components(int index) const;
  std::string* _internal_add_affected_components();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.ApplyThemeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> affected_components_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetThemesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.GetThemesRequest) */ {
 public:
  inline GetThemesRequest() : GetThemesRequest(nullptr) {}
  ~GetThemesRequest() override;
  explicit constexpr GetThemesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetThemesRequest(const GetThemesRequest& from);
  GetThemesRequest(GetThemesRequest&& from) noexcept
    : GetThemesRequest() {
    *this = ::std::move(from);
  }

  inline GetThemesRequest& operator=(const GetThemesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetThemesRequest& operator=(GetThemesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetThemesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetThemesRequest* internal_default_instance() {
    return reinterpret_cast<const GetThemesRequest*>(
               &_GetThemesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetThemesRequest& a, GetThemesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetThemesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetThemesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetThemesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetThemesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetThemesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetThemesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetThemesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.GetThemesRequest";
  }
  protected:
  explicit GetThemesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 5,
    kIncludePreviewImagesFieldNumber = 4,
  };
  // string category = 5;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // bool include_preview_images = 4;
  void clear_include_preview_images();
  bool include_preview_images() const;
  void set_include_preview_images(bool value);
  private:
  bool _internal_include_preview_images() const;
  void _internal_set_include_preview_images(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.GetThemesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  bool include_preview_images_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetThemesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.GetThemesResponse) */ {
 public:
  inline GetThemesResponse() : GetThemesResponse(nullptr) {}
  ~GetThemesResponse() override;
  explicit constexpr GetThemesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetThemesResponse(const GetThemesResponse& from);
  GetThemesResponse(GetThemesResponse&& from) noexcept
    : GetThemesResponse() {
    *this = ::std::move(from);
  }

  inline GetThemesResponse& operator=(const GetThemesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetThemesResponse& operator=(GetThemesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetThemesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetThemesResponse* internal_default_instance() {
    return reinterpret_cast<const GetThemesResponse*>(
               &_GetThemesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetThemesResponse& a, GetThemesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetThemesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetThemesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetThemesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetThemesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetThemesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetThemesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetThemesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.GetThemesResponse";
  }
  protected:
  explicit GetThemesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThemesFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // repeated .vaelix.plugin.ThemeInfo themes = 1;
  int themes_size() const;
  private:
  int _internal_themes_size() const;
  public:
  void clear_themes();
  ::vaelix::plugin::ThemeInfo* mutable_themes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::ThemeInfo >*
      mutable_themes();
  private:
  const ::vaelix::plugin::ThemeInfo& _internal_themes(int index) const;
  ::vaelix::plugin::ThemeInfo* _internal_add_themes();
  public:
  const ::vaelix::plugin::ThemeInfo& themes(int index) const;
  ::vaelix::plugin::ThemeInfo* add_themes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::ThemeInfo >&
      themes() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.GetThemesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::ThemeInfo > themes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginConfigUpdate_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginConfigUpdate_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PluginConfigUpdate_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PluginConfigUpdate_ConfigEntry_DoNotUse();
  explicit constexpr PluginConfigUpdate_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PluginConfigUpdate_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PluginConfigUpdate_ConfigEntry_DoNotUse& other);
  static const PluginConfigUpdate_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PluginConfigUpdate_ConfigEntry_DoNotUse*>(&_PluginConfigUpdate_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginConfigUpdate.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.PluginConfigUpdate.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class PluginConfigUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginConfigUpdate) */ {
 public:
  inline PluginConfigUpdate() : PluginConfigUpdate(nullptr) {}
  ~PluginConfigUpdate() override;
  explicit constexpr PluginConfigUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginConfigUpdate(const PluginConfigUpdate& from);
  PluginConfigUpdate(PluginConfigUpdate&& from) noexcept
    : PluginConfigUpdate() {
    *this = ::std::move(from);
  }

  inline PluginConfigUpdate& operator=(const PluginConfigUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginConfigUpdate& operator=(PluginConfigUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginConfigUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginConfigUpdate* internal_default_instance() {
    return reinterpret_cast<const PluginConfigUpdate*>(
               &_PluginConfigUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PluginConfigUpdate& a, PluginConfigUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginConfigUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginConfigUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginConfigUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginConfigUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginConfigUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginConfigUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginConfigUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginConfigUpdate";
  }
  protected:
  explicit PluginConfigUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kPluginIdFieldNumber = 1,
    kUpdatedByFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // map<string, string> config = 2;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string updated_by = 3;
  void clear_updated_by();
  const std::string& updated_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by();
  PROTOBUF_NODISCARD std::string* release_updated_by();
  void set_allocated_updated_by(std::string* updated_by);
  private:
  const std::string& _internal_updated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by(const std::string& value);
  std::string* _internal_mutable_updated_by();
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginConfigUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PluginConfigUpdate_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.GetPluginConfigRequest) */ {
 public:
  inline GetPluginConfigRequest() : GetPluginConfigRequest(nullptr) {}
  ~GetPluginConfigRequest() override;
  explicit constexpr GetPluginConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPluginConfigRequest(const GetPluginConfigRequest& from);
  GetPluginConfigRequest(GetPluginConfigRequest&& from) noexcept
    : GetPluginConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetPluginConfigRequest& operator=(const GetPluginConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginConfigRequest& operator=(GetPluginConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetPluginConfigRequest*>(
               &_GetPluginConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetPluginConfigRequest& a, GetPluginConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPluginConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPluginConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.GetPluginConfigRequest";
  }
  protected:
  explicit GetPluginConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigKeysFieldNumber = 2,
    kPluginIdFieldNumber = 1,
  };
  // repeated string config_keys = 2;
  int config_keys_size() const;
  private:
  int _internal_config_keys_size() const;
  public:
  void clear_config_keys();
  const std::string& config_keys(int index) const;
  std::string* mutable_config_keys(int index);
  void set_config_keys(int index, const std::string& value);
  void set_config_keys(int index, std::string&& value);
  void set_config_keys(int index, const char* value);
  void set_config_keys(int index, const char* value, size_t size);
  std::string* add_config_keys();
  void add_config_keys(const std::string& value);
  void add_config_keys(std::string&& value);
  void add_config_keys(const char* value);
  void add_config_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& config_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_config_keys();
  private:
  const std::string& _internal_config_keys(int index) const;
  std::string* _internal_add_config_keys();
  public:

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.GetPluginConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> config_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginConfigResponse_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetPluginConfigResponse_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetPluginConfigResponse_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetPluginConfigResponse_ConfigEntry_DoNotUse();
  explicit constexpr GetPluginConfigResponse_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetPluginConfigResponse_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetPluginConfigResponse_ConfigEntry_DoNotUse& other);
  static const GetPluginConfigResponse_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetPluginConfigResponse_ConfigEntry_DoNotUse*>(&_GetPluginConfigResponse_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.GetPluginConfigResponse.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.GetPluginConfigResponse.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetPluginConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.GetPluginConfigResponse) */ {
 public:
  inline GetPluginConfigResponse() : GetPluginConfigResponse(nullptr) {}
  ~GetPluginConfigResponse() override;
  explicit constexpr GetPluginConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPluginConfigResponse(const GetPluginConfigResponse& from);
  GetPluginConfigResponse(GetPluginConfigResponse&& from) noexcept
    : GetPluginConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetPluginConfigResponse& operator=(const GetPluginConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginConfigResponse& operator=(GetPluginConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetPluginConfigResponse*>(
               &_GetPluginConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetPluginConfigResponse& a, GetPluginConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPluginConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPluginConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.GetPluginConfigResponse";
  }
  protected:
  explicit GetPluginConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // map<string, string> config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.GetPluginConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetPluginConfigResponse_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetPluginConfigRequest_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetPluginConfigRequest_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetPluginConfigRequest_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SetPluginConfigRequest_ConfigEntry_DoNotUse();
  explicit constexpr SetPluginConfigRequest_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetPluginConfigRequest_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetPluginConfigRequest_ConfigEntry_DoNotUse& other);
  static const SetPluginConfigRequest_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetPluginConfigRequest_ConfigEntry_DoNotUse*>(&_SetPluginConfigRequest_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.SetPluginConfigRequest.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.SetPluginConfigRequest.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SetPluginConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.SetPluginConfigRequest) */ {
 public:
  inline SetPluginConfigRequest() : SetPluginConfigRequest(nullptr) {}
  ~SetPluginConfigRequest() override;
  explicit constexpr SetPluginConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPluginConfigRequest(const SetPluginConfigRequest& from);
  SetPluginConfigRequest(SetPluginConfigRequest&& from) noexcept
    : SetPluginConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetPluginConfigRequest& operator=(const SetPluginConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPluginConfigRequest& operator=(SetPluginConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPluginConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPluginConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetPluginConfigRequest*>(
               &_SetPluginConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetPluginConfigRequest& a, SetPluginConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPluginConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPluginConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPluginConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPluginConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPluginConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetPluginConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPluginConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.SetPluginConfigRequest";
  }
  protected:
  explicit SetPluginConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kPluginIdFieldNumber = 1,
    kValidateFieldNumber = 3,
  };
  // map<string, string> config = 2;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // bool validate = 3;
  void clear_validate();
  bool validate() const;
  void set_validate(bool value);
  private:
  bool _internal_validate() const;
  void _internal_set_validate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.SetPluginConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetPluginConfigRequest_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  bool validate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse();
  explicit constexpr SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse& other);
  static const SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse*>(&_SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.SetPluginConfigResponse.ValidatedConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.SetPluginConfigResponse.ValidatedConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SetPluginConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.SetPluginConfigResponse) */ {
 public:
  inline SetPluginConfigResponse() : SetPluginConfigResponse(nullptr) {}
  ~SetPluginConfigResponse() override;
  explicit constexpr SetPluginConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPluginConfigResponse(const SetPluginConfigResponse& from);
  SetPluginConfigResponse(SetPluginConfigResponse&& from) noexcept
    : SetPluginConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetPluginConfigResponse& operator=(const SetPluginConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPluginConfigResponse& operator=(SetPluginConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPluginConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPluginConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetPluginConfigResponse*>(
               &_SetPluginConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetPluginConfigResponse& a, SetPluginConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPluginConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPluginConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPluginConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPluginConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPluginConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetPluginConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPluginConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.SetPluginConfigResponse";
  }
  protected:
  explicit SetPluginConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValidatedConfigFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> validated_config = 3;
  int validated_config_size() const;
  private:
  int _internal_validated_config_size() const;
  public:
  void clear_validated_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_validated_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_validated_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      validated_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_validated_config();

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.SetPluginConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SetPluginConfigResponse_ValidatedConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> validated_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class NetworkRequest_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkRequest_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkRequest_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  NetworkRequest_HeadersEntry_DoNotUse();
  explicit constexpr NetworkRequest_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkRequest_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkRequest_HeadersEntry_DoNotUse& other);
  static const NetworkRequest_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkRequest_HeadersEntry_DoNotUse*>(&_NetworkRequest_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.NetworkRequest.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.NetworkRequest.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class NetworkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.NetworkRequest) */ {
 public:
  inline NetworkRequest() : NetworkRequest(nullptr) {}
  ~NetworkRequest() override;
  explicit constexpr NetworkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkRequest(const NetworkRequest& from);
  NetworkRequest(NetworkRequest&& from) noexcept
    : NetworkRequest() {
    *this = ::std::move(from);
  }

  inline NetworkRequest& operator=(const NetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkRequest& operator=(NetworkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkRequest* internal_default_instance() {
    return reinterpret_cast<const NetworkRequest*>(
               &_NetworkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(NetworkRequest& a, NetworkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.NetworkRequest";
  }
  protected:
  explicit NetworkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kUrlFieldNumber = 2,
    kMethodFieldNumber = 3,
    kBodyFieldNumber = 5,
    kAllowRedirectsFieldNumber = 6,
    kTimeoutMsFieldNumber = 7,
  };
  // map<string, string> headers = 4;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // bytes body = 5;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // bool allow_redirects = 6;
  void clear_allow_redirects();
  bool allow_redirects() const;
  void set_allow_redirects(bool value);
  private:
  bool _internal_allow_redirects() const;
  void _internal_set_allow_redirects(bool value);
  public:

  // int32 timeout_ms = 7;
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.NetworkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NetworkRequest_HeadersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  bool allow_redirects_;
  int32_t timeout_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class NetworkResponse_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkResponse_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkResponse_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  NetworkResponse_HeadersEntry_DoNotUse();
  explicit constexpr NetworkResponse_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkResponse_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkResponse_HeadersEntry_DoNotUse& other);
  static const NetworkResponse_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkResponse_HeadersEntry_DoNotUse*>(&_NetworkResponse_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.NetworkResponse.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.NetworkResponse.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class NetworkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.NetworkResponse) */ {
 public:
  inline NetworkResponse() : NetworkResponse(nullptr) {}
  ~NetworkResponse() override;
  explicit constexpr NetworkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkResponse(const NetworkResponse& from);
  NetworkResponse(NetworkResponse&& from) noexcept
    : NetworkResponse() {
    *this = ::std::move(from);
  }

  inline NetworkResponse& operator=(const NetworkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkResponse& operator=(NetworkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkResponse* internal_default_instance() {
    return reinterpret_cast<const NetworkResponse*>(
               &_NetworkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NetworkResponse& a, NetworkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.NetworkResponse";
  }
  protected:
  explicit NetworkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kBodyFieldNumber = 4,
    kErrorMessageFieldNumber = 7,
    kStatusCodeFieldNumber = 2,
    kSuccessFieldNumber = 6,
    kResponseTimeMsFieldNumber = 5,
  };
  // map<string, string> headers = 3;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // bytes body = 4;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // string error_message = 7;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 status_code = 2;
  void clear_status_code();
  int32_t status_code() const;
  void set_status_code(int32_t value);
  private:
  int32_t _internal_status_code() const;
  void _internal_set_status_code(int32_t value);
  public:

  // bool success = 6;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int64 response_time_ms = 5;
  void clear_response_time_ms();
  int64_t response_time_ms() const;
  void set_response_time_ms(int64_t value);
  private:
  int64_t _internal_response_time_ms() const;
  void _internal_set_response_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.NetworkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NetworkResponse_HeadersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int32_t status_code_;
  bool success_;
  int64_t response_time_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class MakeNetworkRequestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.MakeNetworkRequestRequest) */ {
 public:
  inline MakeNetworkRequestRequest() : MakeNetworkRequestRequest(nullptr) {}
  ~MakeNetworkRequestRequest() override;
  explicit constexpr MakeNetworkRequestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeNetworkRequestRequest(const MakeNetworkRequestRequest& from);
  MakeNetworkRequestRequest(MakeNetworkRequestRequest&& from) noexcept
    : MakeNetworkRequestRequest() {
    *this = ::std::move(from);
  }

  inline MakeNetworkRequestRequest& operator=(const MakeNetworkRequestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeNetworkRequestRequest& operator=(MakeNetworkRequestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeNetworkRequestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeNetworkRequestRequest* internal_default_instance() {
    return reinterpret_cast<const MakeNetworkRequestRequest*>(
               &_MakeNetworkRequestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MakeNetworkRequestRequest& a, MakeNetworkRequestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeNetworkRequestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeNetworkRequestRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeNetworkRequestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeNetworkRequestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeNetworkRequestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MakeNetworkRequestRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeNetworkRequestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.MakeNetworkRequestRequest";
  }
  protected:
  explicit MakeNetworkRequestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginIdFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // .vaelix.plugin.NetworkRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::vaelix::plugin::NetworkRequest& request() const;
  PROTOBUF_NODISCARD ::vaelix::plugin::NetworkRequest* release_request();
  ::vaelix::plugin::NetworkRequest* mutable_request();
  void set_allocated_request(::vaelix::plugin::NetworkRequest* request);
  private:
  const ::vaelix::plugin::NetworkRequest& _internal_request() const;
  ::vaelix::plugin::NetworkRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::vaelix::plugin::NetworkRequest* request);
  ::vaelix::plugin::NetworkRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:vaelix.plugin.MakeNetworkRequestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::vaelix::plugin::NetworkRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class MakeNetworkRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.MakeNetworkRequestResponse) */ {
 public:
  inline MakeNetworkRequestResponse() : MakeNetworkRequestResponse(nullptr) {}
  ~MakeNetworkRequestResponse() override;
  explicit constexpr MakeNetworkRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeNetworkRequestResponse(const MakeNetworkRequestResponse& from);
  MakeNetworkRequestResponse(MakeNetworkRequestResponse&& from) noexcept
    : MakeNetworkRequestResponse() {
    *this = ::std::move(from);
  }

  inline MakeNetworkRequestResponse& operator=(const MakeNetworkRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeNetworkRequestResponse& operator=(MakeNetworkRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeNetworkRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeNetworkRequestResponse* internal_default_instance() {
    return reinterpret_cast<const MakeNetworkRequestResponse*>(
               &_MakeNetworkRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MakeNetworkRequestResponse& a, MakeNetworkRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeNetworkRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeNetworkRequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeNetworkRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeNetworkRequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeNetworkRequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MakeNetworkRequestResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeNetworkRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.MakeNetworkRequestResponse";
  }
  protected:
  explicit MakeNetworkRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.MakeNetworkRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WidgetCreateRequest_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetCreateRequest_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetCreateRequest_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WidgetCreateRequest_PropertiesEntry_DoNotUse();
  explicit constexpr WidgetCreateRequest_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WidgetCreateRequest_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WidgetCreateRequest_PropertiesEntry_DoNotUse& other);
  static const WidgetCreateRequest_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WidgetCreateRequest_PropertiesEntry_DoNotUse*>(&_WidgetCreateRequest_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetCreateRequest.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetCreateRequest.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WidgetCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.WidgetCreateRequest) */ {
 public:
  inline WidgetCreateRequest() : WidgetCreateRequest(nullptr) {}
  ~WidgetCreateRequest() override;
  explicit constexpr WidgetCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WidgetCreateRequest(const WidgetCreateRequest& from);
  WidgetCreateRequest(WidgetCreateRequest&& from) noexcept
    : WidgetCreateRequest() {
    *this = ::std::move(from);
  }

  inline WidgetCreateRequest& operator=(const WidgetCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WidgetCreateRequest& operator=(WidgetCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WidgetCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WidgetCreateRequest* internal_default_instance() {
    return reinterpret_cast<const WidgetCreateRequest*>(
               &_WidgetCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(WidgetCreateRequest& a, WidgetCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WidgetCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WidgetCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WidgetCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WidgetCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WidgetCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WidgetCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WidgetCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.WidgetCreateRequest";
  }
  protected:
  explicit WidgetCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 6,
    kPluginIdFieldNumber = 1,
    kWidgetTypeFieldNumber = 2,
    kWidgetIdFieldNumber = 3,
    kWindowIdFieldNumber = 4,
    kTabIdFieldNumber = 5,
  };
  // map<string, string> properties = 6;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string widget_type = 2;
  void clear_widget_type();
  const std::string& widget_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_widget_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_widget_type();
  PROTOBUF_NODISCARD std::string* release_widget_type();
  void set_allocated_widget_type(std::string* widget_type);
  private:
  const std::string& _internal_widget_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_widget_type(const std::string& value);
  std::string* _internal_mutable_widget_type();
  public:

  // string widget_id = 3;
  void clear_widget_id();
  const std::string& widget_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_widget_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_widget_id();
  PROTOBUF_NODISCARD std::string* release_widget_id();
  void set_allocated_widget_id(std::string* widget_id);
  private:
  const std::string& _internal_widget_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_widget_id(const std::string& value);
  std::string* _internal_mutable_widget_id();
  public:

  // int32 window_id = 4;
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // int32 tab_id = 5;
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.WidgetCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WidgetCreateRequest_PropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr widget_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr widget_id_;
  int32_t window_id_;
  int32_t tab_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WidgetCreateResponse_WidgetDataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetCreateResponse_WidgetDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetCreateResponse_WidgetDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WidgetCreateResponse_WidgetDataEntry_DoNotUse();
  explicit constexpr WidgetCreateResponse_WidgetDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WidgetCreateResponse_WidgetDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WidgetCreateResponse_WidgetDataEntry_DoNotUse& other);
  static const WidgetCreateResponse_WidgetDataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WidgetCreateResponse_WidgetDataEntry_DoNotUse*>(&_WidgetCreateResponse_WidgetDataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetCreateResponse.WidgetDataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetCreateResponse.WidgetDataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WidgetCreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.WidgetCreateResponse) */ {
 public:
  inline WidgetCreateResponse() : WidgetCreateResponse(nullptr) {}
  ~WidgetCreateResponse() override;
  explicit constexpr WidgetCreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WidgetCreateResponse(const WidgetCreateResponse& from);
  WidgetCreateResponse(WidgetCreateResponse&& from) noexcept
    : WidgetCreateResponse() {
    *this = ::std::move(from);
  }

  inline WidgetCreateResponse& operator=(const WidgetCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WidgetCreateResponse& operator=(WidgetCreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WidgetCreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WidgetCreateResponse* internal_default_instance() {
    return reinterpret_cast<const WidgetCreateResponse*>(
               &_WidgetCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(WidgetCreateResponse& a, WidgetCreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WidgetCreateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WidgetCreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WidgetCreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WidgetCreateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WidgetCreateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WidgetCreateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WidgetCreateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.WidgetCreateResponse";
  }
  protected:
  explicit WidgetCreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWidgetDataFieldNumber = 10,
    kWidgetIdFieldNumber = 7,
    kErrorMessageFieldNumber = 9,
    kSuccessFieldNumber = 8,
  };
  // map<string, string> widget_data = 10;
  int widget_data_size() const;
  private:
  int _internal_widget_data_size() const;
  public:
  void clear_widget_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_widget_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_widget_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      widget_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_widget_data();

  // string widget_id = 7;
  void clear_widget_id();
  const std::string& widget_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_widget_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_widget_id();
  PROTOBUF_NODISCARD std::string* release_widget_id();
  void set_allocated_widget_id(std::string* widget_id);
  private:
  const std::string& _internal_widget_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_widget_id(const std::string& value);
  std::string* _internal_mutable_widget_id();
  public:

  // string error_message = 9;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 8;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.WidgetCreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WidgetCreateResponse_WidgetDataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> widget_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr widget_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WidgetModifyRequest_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetModifyRequest_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetModifyRequest_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WidgetModifyRequest_PropertiesEntry_DoNotUse();
  explicit constexpr WidgetModifyRequest_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WidgetModifyRequest_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WidgetModifyRequest_PropertiesEntry_DoNotUse& other);
  static const WidgetModifyRequest_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WidgetModifyRequest_PropertiesEntry_DoNotUse*>(&_WidgetModifyRequest_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetModifyRequest.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetModifyRequest.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WidgetModifyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.WidgetModifyRequest) */ {
 public:
  inline WidgetModifyRequest() : WidgetModifyRequest(nullptr) {}
  ~WidgetModifyRequest() override;
  explicit constexpr WidgetModifyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WidgetModifyRequest(const WidgetModifyRequest& from);
  WidgetModifyRequest(WidgetModifyRequest&& from) noexcept
    : WidgetModifyRequest() {
    *this = ::std::move(from);
  }

  inline WidgetModifyRequest& operator=(const WidgetModifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WidgetModifyRequest& operator=(WidgetModifyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WidgetModifyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WidgetModifyRequest* internal_default_instance() {
    return reinterpret_cast<const WidgetModifyRequest*>(
               &_WidgetModifyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(WidgetModifyRequest& a, WidgetModifyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WidgetModifyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WidgetModifyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WidgetModifyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WidgetModifyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WidgetModifyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WidgetModifyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WidgetModifyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.WidgetModifyRequest";
  }
  protected:
  explicit WidgetModifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kPluginIdFieldNumber = 1,
    kWidgetIdFieldNumber = 2,
    kPartialUpdateFieldNumber = 4,
  };
  // map<string, string> properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string plugin_id = 1;
  void clear_plugin_id();
  const std::string& plugin_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_id();
  PROTOBUF_NODISCARD std::string* release_plugin_id();
  void set_allocated_plugin_id(std::string* plugin_id);
  private:
  const std::string& _internal_plugin_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const std::string& value);
  std::string* _internal_mutable_plugin_id();
  public:

  // string widget_id = 2;
  void clear_widget_id();
  const std::string& widget_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_widget_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_widget_id();
  PROTOBUF_NODISCARD std::string* release_widget_id();
  void set_allocated_widget_id(std::string* widget_id);
  private:
  const std::string& _internal_widget_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_widget_id(const std::string& value);
  std::string* _internal_mutable_widget_id();
  public:

  // bool partial_update = 4;
  void clear_partial_update();
  bool partial_update() const;
  void set_partial_update(bool value);
  private:
  bool _internal_partial_update() const;
  void _internal_set_partial_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.WidgetModifyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WidgetModifyRequest_PropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr widget_id_;
  bool partial_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse();
  explicit constexpr WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse& other);
  static const WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse*>(&_WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetModifyResponse.UpdatedPropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vaelix.plugin.WidgetModifyResponse.UpdatedPropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WidgetModifyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.WidgetModifyResponse) */ {
 public:
  inline WidgetModifyResponse() : WidgetModifyResponse(nullptr) {}
  ~WidgetModifyResponse() override;
  explicit constexpr WidgetModifyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WidgetModifyResponse(const WidgetModifyResponse& from);
  WidgetModifyResponse(WidgetModifyResponse&& from) noexcept
    : WidgetModifyResponse() {
    *this = ::std::move(from);
  }

  inline WidgetModifyResponse& operator=(const WidgetModifyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WidgetModifyResponse& operator=(WidgetModifyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WidgetModifyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WidgetModifyResponse* internal_default_instance() {
    return reinterpret_cast<const WidgetModifyResponse*>(
               &_WidgetModifyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(WidgetModifyResponse& a, WidgetModifyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WidgetModifyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WidgetModifyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WidgetModifyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WidgetModifyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WidgetModifyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WidgetModifyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WidgetModifyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.WidgetModifyResponse";
  }
  protected:
  explicit WidgetModifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUpdatedPropertiesFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> updated_properties = 3;
  int updated_properties_size() const;
  private:
  int _internal_updated_properties_size() const;
  public:
  void clear_updated_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_updated_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_updated_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      updated_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_updated_properties();

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.WidgetModifyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WidgetModifyResponse_UpdatedPropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> updated_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginListRequest) */ {
 public:
  inline PluginListRequest() : PluginListRequest(nullptr) {}
  ~PluginListRequest() override;
  explicit constexpr PluginListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginListRequest(const PluginListRequest& from);
  PluginListRequest(PluginListRequest&& from) noexcept
    : PluginListRequest() {
    *this = ::std::move(from);
  }

  inline PluginListRequest& operator=(const PluginListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginListRequest& operator=(PluginListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginListRequest* internal_default_instance() {
    return reinterpret_cast<const PluginListRequest*>(
               &_PluginListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PluginListRequest& a, PluginListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginListRequest";
  }
  protected:
  explicit PluginListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterTypeFieldNumber = 2,
    kIncludeDisabledFieldNumber = 1,
  };
  // string filter_type = 2;
  void clear_filter_type();
  const std::string& filter_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_type();
  PROTOBUF_NODISCARD std::string* release_filter_type();
  void set_allocated_filter_type(std::string* filter_type);
  private:
  const std::string& _internal_filter_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_type(const std::string& value);
  std::string* _internal_mutable_filter_type();
  public:

  // bool include_disabled = 1;
  void clear_include_disabled();
  bool include_disabled() const;
  void set_include_disabled(bool value);
  private:
  bool _internal_include_disabled() const;
  void _internal_set_include_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_type_;
  bool include_disabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginListResponse) */ {
 public:
  inline PluginListResponse() : PluginListResponse(nullptr) {}
  ~PluginListResponse() override;
  explicit constexpr PluginListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginListResponse(const PluginListResponse& from);
  PluginListResponse(PluginListResponse&& from) noexcept
    : PluginListResponse() {
    *this = ::std::move(from);
  }

  inline PluginListResponse& operator=(const PluginListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginListResponse& operator=(PluginListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginListResponse* internal_default_instance() {
    return reinterpret_cast<const PluginListResponse*>(
               &_PluginListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PluginListResponse& a, PluginListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginListResponse";
  }
  protected:
  explicit PluginListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginsFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // repeated .vaelix.plugin.PluginInfo plugins = 1;
  int plugins_size() const;
  private:
  int _internal_plugins_size() const;
  public:
  void clear_plugins();
  ::vaelix::plugin::PluginInfo* mutable_plugins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginInfo >*
      mutable_plugins();
  private:
  const ::vaelix::plugin::PluginInfo& _internal_plugins(int index) const;
  ::vaelix::plugin::PluginInfo* _internal_add_plugins();
  public:
  const ::vaelix::plugin::PluginInfo& plugins(int index) const;
  ::vaelix::plugin::PluginInfo* add_plugins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginInfo >&
      plugins() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginInfo > plugins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PluginEventHooksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.PluginEventHooksResponse) */ {
 public:
  inline PluginEventHooksResponse() : PluginEventHooksResponse(nullptr) {}
  ~PluginEventHooksResponse() override;
  explicit constexpr PluginEventHooksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginEventHooksResponse(const PluginEventHooksResponse& from);
  PluginEventHooksResponse(PluginEventHooksResponse&& from) noexcept
    : PluginEventHooksResponse() {
    *this = ::std::move(from);
  }

  inline PluginEventHooksResponse& operator=(const PluginEventHooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginEventHooksResponse& operator=(PluginEventHooksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginEventHooksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginEventHooksResponse* internal_default_instance() {
    return reinterpret_cast<const PluginEventHooksResponse*>(
               &_PluginEventHooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(PluginEventHooksResponse& a, PluginEventHooksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginEventHooksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginEventHooksResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginEventHooksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginEventHooksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginEventHooksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginEventHooksResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginEventHooksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.PluginEventHooksResponse";
  }
  protected:
  explicit PluginEventHooksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHooksFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // repeated .vaelix.plugin.PluginEventHook hooks = 1;
  int hooks_size() const;
  private:
  int _internal_hooks_size() const;
  public:
  void clear_hooks();
  ::vaelix::plugin::PluginEventHook* mutable_hooks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginEventHook >*
      mutable_hooks();
  private:
  const ::vaelix::plugin::PluginEventHook& _internal_hooks(int index) const;
  ::vaelix::plugin::PluginEventHook* _internal_add_hooks();
  public:
  const ::vaelix::plugin::PluginEventHook& hooks(int index) const;
  ::vaelix::plugin::PluginEventHook* add_hooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginEventHook >&
      hooks() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.PluginEventHooksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginEventHook > hooks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InstallThemeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.InstallThemeRequest) */ {
 public:
  inline InstallThemeRequest() : InstallThemeRequest(nullptr) {}
  ~InstallThemeRequest() override;
  explicit constexpr InstallThemeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallThemeRequest(const InstallThemeRequest& from);
  InstallThemeRequest(InstallThemeRequest&& from) noexcept
    : InstallThemeRequest() {
    *this = ::std::move(from);
  }

  inline InstallThemeRequest& operator=(const InstallThemeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallThemeRequest& operator=(InstallThemeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallThemeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallThemeRequest* internal_default_instance() {
    return reinterpret_cast<const InstallThemeRequest*>(
               &_InstallThemeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(InstallThemeRequest& a, InstallThemeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallThemeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallThemeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallThemeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallThemeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallThemeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstallThemeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallThemeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.InstallThemeRequest";
  }
  protected:
  explicit InstallThemeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThemePathFieldNumber = 1,
    kThemeIdFieldNumber = 2,
    kMakeDefaultFieldNumber = 3,
  };
  // string theme_path = 1;
  void clear_theme_path();
  const std::string& theme_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_theme_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_theme_path();
  PROTOBUF_NODISCARD std::string* release_theme_path();
  void set_allocated_theme_path(std::string* theme_path);
  private:
  const std::string& _internal_theme_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_theme_path(const std::string& value);
  std::string* _internal_mutable_theme_path();
  public:

  // string theme_id = 2;
  void clear_theme_id();
  const std::string& theme_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_theme_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_theme_id();
  PROTOBUF_NODISCARD std::string* release_theme_id();
  void set_allocated_theme_id(std::string* theme_id);
  private:
  const std::string& _internal_theme_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_theme_id(const std::string& value);
  std::string* _internal_mutable_theme_id();
  public:

  // bool make_default = 3;
  void clear_make_default();
  bool make_default() const;
  void set_make_default(bool value);
  private:
  bool _internal_make_default() const;
  void _internal_set_make_default(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.InstallThemeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr theme_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr theme_id_;
  bool make_default_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InstallThemeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vaelix.plugin.InstallThemeResponse) */ {
 public:
  inline InstallThemeResponse() : InstallThemeResponse(nullptr) {}
  ~InstallThemeResponse() override;
  explicit constexpr InstallThemeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallThemeResponse(const InstallThemeResponse& from);
  InstallThemeResponse(InstallThemeResponse&& from) noexcept
    : InstallThemeResponse() {
    *this = ::std::move(from);
  }

  inline InstallThemeResponse& operator=(const InstallThemeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallThemeResponse& operator=(InstallThemeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallThemeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallThemeResponse* internal_default_instance() {
    return reinterpret_cast<const InstallThemeResponse*>(
               &_InstallThemeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(InstallThemeResponse& a, InstallThemeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallThemeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallThemeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallThemeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallThemeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallThemeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstallThemeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallThemeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vaelix.plugin.InstallThemeResponse";
  }
  protected:
  explicit InstallThemeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kThemeInfoFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .vaelix.plugin.ThemeInfo theme_info = 3;
  bool has_theme_info() const;
  private:
  bool _internal_has_theme_info() const;
  public:
  void clear_theme_info();
  const ::vaelix::plugin::ThemeInfo& theme_info() const;
  PROTOBUF_NODISCARD ::vaelix::plugin::ThemeInfo* release_theme_info();
  ::vaelix::plugin::ThemeInfo* mutable_theme_info();
  void set_allocated_theme_info(::vaelix::plugin::ThemeInfo* theme_info);
  private:
  const ::vaelix::plugin::ThemeInfo& _internal_theme_info() const;
  ::vaelix::plugin::ThemeInfo* _internal_mutable_theme_info();
  public:
  void unsafe_arena_set_allocated_theme_info(
      ::vaelix::plugin::ThemeInfo* theme_info);
  ::vaelix::plugin::ThemeInfo* unsafe_arena_release_theme_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vaelix.plugin.InstallThemeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::vaelix::plugin::ThemeInfo* theme_info_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plugin_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PluginInfo

// string plugin_id = 1;
inline void PluginInfo::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginInfo::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginInfo::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.plugin_id)
}
inline std::string* PluginInfo::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.plugin_id)
  return _s;
}
inline const std::string& PluginInfo::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginInfo::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginInfo::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginInfo::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginInfo.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginInfo::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginInfo.plugin_id)
}

// string name = 2;
inline void PluginInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PluginInfo::name() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.name)
}
inline std::string* PluginInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.name)
  return _s;
}
inline const std::string& PluginInfo::_internal_name() const {
  return name_.Get();
}
inline void PluginInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginInfo::release_name() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginInfo.name)
}

// string version = 3;
inline void PluginInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& PluginInfo::version() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.version)
}
inline std::string* PluginInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.version)
  return _s;
}
inline const std::string& PluginInfo::_internal_version() const {
  return version_.Get();
}
inline void PluginInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginInfo::release_version() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginInfo.version)
}

// string description = 4;
inline void PluginInfo::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& PluginInfo::description() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.description)
}
inline std::string* PluginInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.description)
  return _s;
}
inline const std::string& PluginInfo::_internal_description() const {
  return description_.Get();
}
inline void PluginInfo::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginInfo::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginInfo::release_description() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginInfo.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginInfo.description)
}

// string author = 5;
inline void PluginInfo::clear_author() {
  author_.ClearToEmpty();
}
inline const std::string& PluginInfo::author() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginInfo::set_author(ArgT0&& arg0, ArgT... args) {
 
 author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.author)
}
inline std::string* PluginInfo::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.author)
  return _s;
}
inline const std::string& PluginInfo::_internal_author() const {
  return author_.Get();
}
inline void PluginInfo::_internal_set_author(const std::string& value) {
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginInfo::_internal_mutable_author() {
  
  return author_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginInfo::release_author() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginInfo.author)
  return author_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginInfo::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  author_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (author_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    author_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginInfo.author)
}

// repeated string permissions = 6;
inline int PluginInfo::_internal_permissions_size() const {
  return permissions_.size();
}
inline int PluginInfo::permissions_size() const {
  return _internal_permissions_size();
}
inline void PluginInfo::clear_permissions() {
  permissions_.Clear();
}
inline std::string* PluginInfo::add_permissions() {
  std::string* _s = _internal_add_permissions();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.PluginInfo.permissions)
  return _s;
}
inline const std::string& PluginInfo::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const std::string& PluginInfo::permissions(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.permissions)
  return _internal_permissions(index);
}
inline std::string* PluginInfo::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.permissions)
  return permissions_.Mutable(index);
}
inline void PluginInfo::set_permissions(int index, const std::string& value) {
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::set_permissions(int index, std::string&& value) {
  permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::set_permissions(int index, const char* value, size_t size) {
  permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.PluginInfo.permissions)
}
inline std::string* PluginInfo::_internal_add_permissions() {
  return permissions_.Add();
}
inline void PluginInfo::add_permissions(const std::string& value) {
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::add_permissions(std::string&& value) {
  permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.PluginInfo.permissions)
}
inline void PluginInfo::add_permissions(const char* value, size_t size) {
  permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.PluginInfo.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PluginInfo::permissions() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginInfo.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PluginInfo::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginInfo.permissions)
  return &permissions_;
}

// repeated string dependencies = 7;
inline int PluginInfo::_internal_dependencies_size() const {
  return dependencies_.size();
}
inline int PluginInfo::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void PluginInfo::clear_dependencies() {
  dependencies_.Clear();
}
inline std::string* PluginInfo::add_dependencies() {
  std::string* _s = _internal_add_dependencies();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.PluginInfo.dependencies)
  return _s;
}
inline const std::string& PluginInfo::_internal_dependencies(int index) const {
  return dependencies_.Get(index);
}
inline const std::string& PluginInfo::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.dependencies)
  return _internal_dependencies(index);
}
inline std::string* PluginInfo::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginInfo.dependencies)
  return dependencies_.Mutable(index);
}
inline void PluginInfo::set_dependencies(int index, const std::string& value) {
  dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::set_dependencies(int index, std::string&& value) {
  dependencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::set_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::set_dependencies(int index, const char* value, size_t size) {
  dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.PluginInfo.dependencies)
}
inline std::string* PluginInfo::_internal_add_dependencies() {
  return dependencies_.Add();
}
inline void PluginInfo::add_dependencies(const std::string& value) {
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::add_dependencies(std::string&& value) {
  dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::add_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.PluginInfo.dependencies)
}
inline void PluginInfo::add_dependencies(const char* value, size_t size) {
  dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.PluginInfo.dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PluginInfo::dependencies() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginInfo.dependencies)
  return dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PluginInfo::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginInfo.dependencies)
  return &dependencies_;
}

// bool is_enabled = 8;
inline void PluginInfo::clear_is_enabled() {
  is_enabled_ = false;
}
inline bool PluginInfo::_internal_is_enabled() const {
  return is_enabled_;
}
inline bool PluginInfo::is_enabled() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.is_enabled)
  return _internal_is_enabled();
}
inline void PluginInfo::_internal_set_is_enabled(bool value) {
  
  is_enabled_ = value;
}
inline void PluginInfo::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.is_enabled)
}

// bool is_loaded = 9;
inline void PluginInfo::clear_is_loaded() {
  is_loaded_ = false;
}
inline bool PluginInfo::_internal_is_loaded() const {
  return is_loaded_;
}
inline bool PluginInfo::is_loaded() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.is_loaded)
  return _internal_is_loaded();
}
inline void PluginInfo::_internal_set_is_loaded(bool value) {
  
  is_loaded_ = value;
}
inline void PluginInfo::set_is_loaded(bool value) {
  _internal_set_is_loaded(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.is_loaded)
}

// double cpu_usage = 10;
inline void PluginInfo::clear_cpu_usage() {
  cpu_usage_ = 0;
}
inline double PluginInfo::_internal_cpu_usage() const {
  return cpu_usage_;
}
inline double PluginInfo::cpu_usage() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.cpu_usage)
  return _internal_cpu_usage();
}
inline void PluginInfo::_internal_set_cpu_usage(double value) {
  
  cpu_usage_ = value;
}
inline void PluginInfo::set_cpu_usage(double value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.cpu_usage)
}

// int64 memory_usage = 11;
inline void PluginInfo::clear_memory_usage() {
  memory_usage_ = int64_t{0};
}
inline int64_t PluginInfo::_internal_memory_usage() const {
  return memory_usage_;
}
inline int64_t PluginInfo::memory_usage() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginInfo.memory_usage)
  return _internal_memory_usage();
}
inline void PluginInfo::_internal_set_memory_usage(int64_t value) {
  
  memory_usage_ = value;
}
inline void PluginInfo::set_memory_usage(int64_t value) {
  _internal_set_memory_usage(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginInfo.memory_usage)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PluginLoadRequest

// string plugin_path = 1;
inline void PluginLoadRequest::clear_plugin_path() {
  plugin_path_.ClearToEmpty();
}
inline const std::string& PluginLoadRequest::plugin_path() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadRequest.plugin_path)
  return _internal_plugin_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginLoadRequest::set_plugin_path(ArgT0&& arg0, ArgT... args) {
 
 plugin_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadRequest.plugin_path)
}
inline std::string* PluginLoadRequest::mutable_plugin_path() {
  std::string* _s = _internal_mutable_plugin_path();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginLoadRequest.plugin_path)
  return _s;
}
inline const std::string& PluginLoadRequest::_internal_plugin_path() const {
  return plugin_path_.Get();
}
inline void PluginLoadRequest::_internal_set_plugin_path(const std::string& value) {
  
  plugin_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginLoadRequest::_internal_mutable_plugin_path() {
  
  return plugin_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginLoadRequest::release_plugin_path() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginLoadRequest.plugin_path)
  return plugin_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginLoadRequest::set_allocated_plugin_path(std::string* plugin_path) {
  if (plugin_path != nullptr) {
    
  } else {
    
  }
  plugin_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginLoadRequest.plugin_path)
}

// string plugin_id = 2;
inline void PluginLoadRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginLoadRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginLoadRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadRequest.plugin_id)
}
inline std::string* PluginLoadRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginLoadRequest.plugin_id)
  return _s;
}
inline const std::string& PluginLoadRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginLoadRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginLoadRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginLoadRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginLoadRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginLoadRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginLoadRequest.plugin_id)
}

// bool enable_immediately = 3;
inline void PluginLoadRequest::clear_enable_immediately() {
  enable_immediately_ = false;
}
inline bool PluginLoadRequest::_internal_enable_immediately() const {
  return enable_immediately_;
}
inline bool PluginLoadRequest::enable_immediately() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadRequest.enable_immediately)
  return _internal_enable_immediately();
}
inline void PluginLoadRequest::_internal_set_enable_immediately(bool value) {
  
  enable_immediately_ = value;
}
inline void PluginLoadRequest::set_enable_immediately(bool value) {
  _internal_set_enable_immediately(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadRequest.enable_immediately)
}

// map<string, string> config = 4;
inline int PluginLoadRequest::_internal_config_size() const {
  return config_.size();
}
inline int PluginLoadRequest::config_size() const {
  return _internal_config_size();
}
inline void PluginLoadRequest::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginLoadRequest::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginLoadRequest::config() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.PluginLoadRequest.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginLoadRequest::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginLoadRequest::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.PluginLoadRequest.config)
  return _internal_mutable_config();
}

// -------------------------------------------------------------------

// PluginLoadResponse

// bool success = 1;
inline void PluginLoadResponse::clear_success() {
  success_ = false;
}
inline bool PluginLoadResponse::_internal_success() const {
  return success_;
}
inline bool PluginLoadResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadResponse.success)
  return _internal_success();
}
inline void PluginLoadResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PluginLoadResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadResponse.success)
}

// string error_message = 2;
inline void PluginLoadResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& PluginLoadResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginLoadResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadResponse.error_message)
}
inline std::string* PluginLoadResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginLoadResponse.error_message)
  return _s;
}
inline const std::string& PluginLoadResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void PluginLoadResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginLoadResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginLoadResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginLoadResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginLoadResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginLoadResponse.error_message)
}

// .vaelix.plugin.PluginInfo plugin_info = 3;
inline bool PluginLoadResponse::_internal_has_plugin_info() const {
  return this != internal_default_instance() && plugin_info_ != nullptr;
}
inline bool PluginLoadResponse::has_plugin_info() const {
  return _internal_has_plugin_info();
}
inline void PluginLoadResponse::clear_plugin_info() {
  if (GetArenaForAllocation() == nullptr && plugin_info_ != nullptr) {
    delete plugin_info_;
  }
  plugin_info_ = nullptr;
}
inline const ::vaelix::plugin::PluginInfo& PluginLoadResponse::_internal_plugin_info() const {
  const ::vaelix::plugin::PluginInfo* p = plugin_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::plugin::PluginInfo&>(
      ::vaelix::plugin::_PluginInfo_default_instance_);
}
inline const ::vaelix::plugin::PluginInfo& PluginLoadResponse::plugin_info() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadResponse.plugin_info)
  return _internal_plugin_info();
}
inline void PluginLoadResponse::unsafe_arena_set_allocated_plugin_info(
    ::vaelix::plugin::PluginInfo* plugin_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plugin_info_);
  }
  plugin_info_ = plugin_info;
  if (plugin_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.plugin.PluginLoadResponse.plugin_info)
}
inline ::vaelix::plugin::PluginInfo* PluginLoadResponse::release_plugin_info() {
  
  ::vaelix::plugin::PluginInfo* temp = plugin_info_;
  plugin_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::plugin::PluginInfo* PluginLoadResponse::unsafe_arena_release_plugin_info() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginLoadResponse.plugin_info)
  
  ::vaelix::plugin::PluginInfo* temp = plugin_info_;
  plugin_info_ = nullptr;
  return temp;
}
inline ::vaelix::plugin::PluginInfo* PluginLoadResponse::_internal_mutable_plugin_info() {
  
  if (plugin_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::plugin::PluginInfo>(GetArenaForAllocation());
    plugin_info_ = p;
  }
  return plugin_info_;
}
inline ::vaelix::plugin::PluginInfo* PluginLoadResponse::mutable_plugin_info() {
  ::vaelix::plugin::PluginInfo* _msg = _internal_mutable_plugin_info();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginLoadResponse.plugin_info)
  return _msg;
}
inline void PluginLoadResponse::set_allocated_plugin_info(::vaelix::plugin::PluginInfo* plugin_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plugin_info_;
  }
  if (plugin_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::plugin::PluginInfo>::GetOwningArena(plugin_info);
    if (message_arena != submessage_arena) {
      plugin_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plugin_info, submessage_arena);
    }
    
  } else {
    
  }
  plugin_info_ = plugin_info;
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginLoadResponse.plugin_info)
}

// repeated string warnings = 4;
inline int PluginLoadResponse::_internal_warnings_size() const {
  return warnings_.size();
}
inline int PluginLoadResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline void PluginLoadResponse::clear_warnings() {
  warnings_.Clear();
}
inline std::string* PluginLoadResponse::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.PluginLoadResponse.warnings)
  return _s;
}
inline const std::string& PluginLoadResponse::_internal_warnings(int index) const {
  return warnings_.Get(index);
}
inline const std::string& PluginLoadResponse::warnings(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginLoadResponse.warnings)
  return _internal_warnings(index);
}
inline std::string* PluginLoadResponse::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginLoadResponse.warnings)
  return warnings_.Mutable(index);
}
inline void PluginLoadResponse::set_warnings(int index, const std::string& value) {
  warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::set_warnings(int index, std::string&& value) {
  warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::set_warnings(int index, const char* value, size_t size) {
  warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.PluginLoadResponse.warnings)
}
inline std::string* PluginLoadResponse::_internal_add_warnings() {
  return warnings_.Add();
}
inline void PluginLoadResponse::add_warnings(const std::string& value) {
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::add_warnings(std::string&& value) {
  warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.PluginLoadResponse.warnings)
}
inline void PluginLoadResponse::add_warnings(const char* value, size_t size) {
  warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.PluginLoadResponse.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PluginLoadResponse::warnings() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginLoadResponse.warnings)
  return warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PluginLoadResponse::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginLoadResponse.warnings)
  return &warnings_;
}

// -------------------------------------------------------------------

// PluginUnloadRequest

// string plugin_id = 1;
inline void PluginUnloadRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginUnloadRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginUnloadRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginUnloadRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadRequest.plugin_id)
}
inline std::string* PluginUnloadRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginUnloadRequest.plugin_id)
  return _s;
}
inline const std::string& PluginUnloadRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginUnloadRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginUnloadRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginUnloadRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginUnloadRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginUnloadRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginUnloadRequest.plugin_id)
}

// bool force_unload = 2;
inline void PluginUnloadRequest::clear_force_unload() {
  force_unload_ = false;
}
inline bool PluginUnloadRequest::_internal_force_unload() const {
  return force_unload_;
}
inline bool PluginUnloadRequest::force_unload() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginUnloadRequest.force_unload)
  return _internal_force_unload();
}
inline void PluginUnloadRequest::_internal_set_force_unload(bool value) {
  
  force_unload_ = value;
}
inline void PluginUnloadRequest::set_force_unload(bool value) {
  _internal_set_force_unload(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadRequest.force_unload)
}

// -------------------------------------------------------------------

// PluginUnloadResponse

// bool success = 1;
inline void PluginUnloadResponse::clear_success() {
  success_ = false;
}
inline bool PluginUnloadResponse::_internal_success() const {
  return success_;
}
inline bool PluginUnloadResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginUnloadResponse.success)
  return _internal_success();
}
inline void PluginUnloadResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PluginUnloadResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadResponse.success)
}

// string error_message = 2;
inline void PluginUnloadResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& PluginUnloadResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginUnloadResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginUnloadResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadResponse.error_message)
}
inline std::string* PluginUnloadResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginUnloadResponse.error_message)
  return _s;
}
inline const std::string& PluginUnloadResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void PluginUnloadResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginUnloadResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginUnloadResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginUnloadResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginUnloadResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginUnloadResponse.error_message)
}

// repeated string cleanup_tasks = 3;
inline int PluginUnloadResponse::_internal_cleanup_tasks_size() const {
  return cleanup_tasks_.size();
}
inline int PluginUnloadResponse::cleanup_tasks_size() const {
  return _internal_cleanup_tasks_size();
}
inline void PluginUnloadResponse::clear_cleanup_tasks() {
  cleanup_tasks_.Clear();
}
inline std::string* PluginUnloadResponse::add_cleanup_tasks() {
  std::string* _s = _internal_add_cleanup_tasks();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
  return _s;
}
inline const std::string& PluginUnloadResponse::_internal_cleanup_tasks(int index) const {
  return cleanup_tasks_.Get(index);
}
inline const std::string& PluginUnloadResponse::cleanup_tasks(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
  return _internal_cleanup_tasks(index);
}
inline std::string* PluginUnloadResponse::mutable_cleanup_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
  return cleanup_tasks_.Mutable(index);
}
inline void PluginUnloadResponse::set_cleanup_tasks(int index, const std::string& value) {
  cleanup_tasks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::set_cleanup_tasks(int index, std::string&& value) {
  cleanup_tasks_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::set_cleanup_tasks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cleanup_tasks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::set_cleanup_tasks(int index, const char* value, size_t size) {
  cleanup_tasks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline std::string* PluginUnloadResponse::_internal_add_cleanup_tasks() {
  return cleanup_tasks_.Add();
}
inline void PluginUnloadResponse::add_cleanup_tasks(const std::string& value) {
  cleanup_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::add_cleanup_tasks(std::string&& value) {
  cleanup_tasks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::add_cleanup_tasks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cleanup_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline void PluginUnloadResponse::add_cleanup_tasks(const char* value, size_t size) {
  cleanup_tasks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PluginUnloadResponse::cleanup_tasks() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
  return cleanup_tasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PluginUnloadResponse::mutable_cleanup_tasks() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginUnloadResponse.cleanup_tasks)
  return &cleanup_tasks_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PluginEvent

// string event_type = 1;
inline void PluginEvent::clear_event_type() {
  event_type_.ClearToEmpty();
}
inline const std::string& PluginEvent::event_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEvent.event_type)
}
inline std::string* PluginEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEvent.event_type)
  return _s;
}
inline const std::string& PluginEvent::_internal_event_type() const {
  return event_type_.Get();
}
inline void PluginEvent::_internal_set_event_type(const std::string& value) {
  
  event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEvent::_internal_mutable_event_type() {
  
  return event_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEvent.event_type)
  return event_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  event_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    event_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEvent.event_type)
}

// string plugin_id = 2;
inline void PluginEvent::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginEvent::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEvent.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEvent::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEvent.plugin_id)
}
inline std::string* PluginEvent::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEvent.plugin_id)
  return _s;
}
inline const std::string& PluginEvent::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginEvent::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEvent::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEvent::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEvent.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEvent::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEvent.plugin_id)
}

// map<string, string> data = 3;
inline int PluginEvent::_internal_data_size() const {
  return data_.size();
}
inline int PluginEvent::data_size() const {
  return _internal_data_size();
}
inline void PluginEvent::clear_data() {
  data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginEvent::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginEvent::data() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.PluginEvent.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginEvent::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginEvent::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.PluginEvent.data)
  return _internal_mutable_data();
}

// int64 timestamp = 4;
inline void PluginEvent::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t PluginEvent::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t PluginEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEvent.timestamp)
  return _internal_timestamp();
}
inline void PluginEvent::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void PluginEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEvent.timestamp)
}

// -------------------------------------------------------------------

// PluginEventHook

// string event_type = 1;
inline void PluginEventHook::clear_event_type() {
  event_type_.ClearToEmpty();
}
inline const std::string& PluginEventHook::event_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHook.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEventHook::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHook.event_type)
}
inline std::string* PluginEventHook::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEventHook.event_type)
  return _s;
}
inline const std::string& PluginEventHook::_internal_event_type() const {
  return event_type_.Get();
}
inline void PluginEventHook::_internal_set_event_type(const std::string& value) {
  
  event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEventHook::_internal_mutable_event_type() {
  
  return event_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEventHook::release_event_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEventHook.event_type)
  return event_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEventHook::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  event_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    event_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEventHook.event_type)
}

// string plugin_id = 2;
inline void PluginEventHook::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginEventHook::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHook.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEventHook::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHook.plugin_id)
}
inline std::string* PluginEventHook::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEventHook.plugin_id)
  return _s;
}
inline const std::string& PluginEventHook::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginEventHook::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEventHook::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEventHook::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEventHook.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEventHook::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEventHook.plugin_id)
}

// string handler_name = 3;
inline void PluginEventHook::clear_handler_name() {
  handler_name_.ClearToEmpty();
}
inline const std::string& PluginEventHook::handler_name() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHook.handler_name)
  return _internal_handler_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEventHook::set_handler_name(ArgT0&& arg0, ArgT... args) {
 
 handler_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHook.handler_name)
}
inline std::string* PluginEventHook::mutable_handler_name() {
  std::string* _s = _internal_mutable_handler_name();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEventHook.handler_name)
  return _s;
}
inline const std::string& PluginEventHook::_internal_handler_name() const {
  return handler_name_.Get();
}
inline void PluginEventHook::_internal_set_handler_name(const std::string& value) {
  
  handler_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEventHook::_internal_mutable_handler_name() {
  
  return handler_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEventHook::release_handler_name() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEventHook.handler_name)
  return handler_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEventHook::set_allocated_handler_name(std::string* handler_name) {
  if (handler_name != nullptr) {
    
  } else {
    
  }
  handler_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), handler_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handler_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handler_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEventHook.handler_name)
}

// bool is_active = 4;
inline void PluginEventHook::clear_is_active() {
  is_active_ = false;
}
inline bool PluginEventHook::_internal_is_active() const {
  return is_active_;
}
inline bool PluginEventHook::is_active() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHook.is_active)
  return _internal_is_active();
}
inline void PluginEventHook::_internal_set_is_active(bool value) {
  
  is_active_ = value;
}
inline void PluginEventHook::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHook.is_active)
}

// -------------------------------------------------------------------

// RegisterEventHookRequest

// string plugin_id = 1;
inline void RegisterEventHookRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& RegisterEventHookRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEventHookRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookRequest.plugin_id)
}
inline std::string* RegisterEventHookRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.RegisterEventHookRequest.plugin_id)
  return _s;
}
inline const std::string& RegisterEventHookRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void RegisterEventHookRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.RegisterEventHookRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterEventHookRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.RegisterEventHookRequest.plugin_id)
}

// string event_type = 2;
inline void RegisterEventHookRequest::clear_event_type() {
  event_type_.ClearToEmpty();
}
inline const std::string& RegisterEventHookRequest::event_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookRequest.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEventHookRequest::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookRequest.event_type)
}
inline std::string* RegisterEventHookRequest::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.RegisterEventHookRequest.event_type)
  return _s;
}
inline const std::string& RegisterEventHookRequest::_internal_event_type() const {
  return event_type_.Get();
}
inline void RegisterEventHookRequest::_internal_set_event_type(const std::string& value) {
  
  event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::_internal_mutable_event_type() {
  
  return event_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::release_event_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.RegisterEventHookRequest.event_type)
  return event_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterEventHookRequest::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  event_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    event_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.RegisterEventHookRequest.event_type)
}

// string handler_name = 3;
inline void RegisterEventHookRequest::clear_handler_name() {
  handler_name_.ClearToEmpty();
}
inline const std::string& RegisterEventHookRequest::handler_name() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookRequest.handler_name)
  return _internal_handler_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEventHookRequest::set_handler_name(ArgT0&& arg0, ArgT... args) {
 
 handler_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookRequest.handler_name)
}
inline std::string* RegisterEventHookRequest::mutable_handler_name() {
  std::string* _s = _internal_mutable_handler_name();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.RegisterEventHookRequest.handler_name)
  return _s;
}
inline const std::string& RegisterEventHookRequest::_internal_handler_name() const {
  return handler_name_.Get();
}
inline void RegisterEventHookRequest::_internal_set_handler_name(const std::string& value) {
  
  handler_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::_internal_mutable_handler_name() {
  
  return handler_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterEventHookRequest::release_handler_name() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.RegisterEventHookRequest.handler_name)
  return handler_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterEventHookRequest::set_allocated_handler_name(std::string* handler_name) {
  if (handler_name != nullptr) {
    
  } else {
    
  }
  handler_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), handler_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (handler_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    handler_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.RegisterEventHookRequest.handler_name)
}

// -------------------------------------------------------------------

// RegisterEventHookResponse

// bool success = 1;
inline void RegisterEventHookResponse::clear_success() {
  success_ = false;
}
inline bool RegisterEventHookResponse::_internal_success() const {
  return success_;
}
inline bool RegisterEventHookResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookResponse.success)
  return _internal_success();
}
inline void RegisterEventHookResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RegisterEventHookResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookResponse.success)
}

// string error_message = 2;
inline void RegisterEventHookResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& RegisterEventHookResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEventHookResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookResponse.error_message)
}
inline std::string* RegisterEventHookResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.RegisterEventHookResponse.error_message)
  return _s;
}
inline const std::string& RegisterEventHookResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void RegisterEventHookResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterEventHookResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterEventHookResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.RegisterEventHookResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterEventHookResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.RegisterEventHookResponse.error_message)
}

// string hook_id = 3;
inline void RegisterEventHookResponse::clear_hook_id() {
  hook_id_.ClearToEmpty();
}
inline const std::string& RegisterEventHookResponse::hook_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.RegisterEventHookResponse.hook_id)
  return _internal_hook_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEventHookResponse::set_hook_id(ArgT0&& arg0, ArgT... args) {
 
 hook_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.RegisterEventHookResponse.hook_id)
}
inline std::string* RegisterEventHookResponse::mutable_hook_id() {
  std::string* _s = _internal_mutable_hook_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.RegisterEventHookResponse.hook_id)
  return _s;
}
inline const std::string& RegisterEventHookResponse::_internal_hook_id() const {
  return hook_id_.Get();
}
inline void RegisterEventHookResponse::_internal_set_hook_id(const std::string& value) {
  
  hook_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterEventHookResponse::_internal_mutable_hook_id() {
  
  return hook_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterEventHookResponse::release_hook_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.RegisterEventHookResponse.hook_id)
  return hook_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterEventHookResponse::set_allocated_hook_id(std::string* hook_id) {
  if (hook_id != nullptr) {
    
  } else {
    
  }
  hook_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hook_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hook_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hook_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.RegisterEventHookResponse.hook_id)
}

// -------------------------------------------------------------------

// UnregisterEventHookRequest

// string plugin_id = 1;
inline void UnregisterEventHookRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& UnregisterEventHookRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.UnregisterEventHookRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterEventHookRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.UnregisterEventHookRequest.plugin_id)
}
inline std::string* UnregisterEventHookRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.UnregisterEventHookRequest.plugin_id)
  return _s;
}
inline const std::string& UnregisterEventHookRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void UnregisterEventHookRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.UnregisterEventHookRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnregisterEventHookRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.UnregisterEventHookRequest.plugin_id)
}

// string event_type = 2;
inline void UnregisterEventHookRequest::clear_event_type() {
  event_type_.ClearToEmpty();
}
inline const std::string& UnregisterEventHookRequest::event_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.UnregisterEventHookRequest.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterEventHookRequest::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.UnregisterEventHookRequest.event_type)
}
inline std::string* UnregisterEventHookRequest::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.UnregisterEventHookRequest.event_type)
  return _s;
}
inline const std::string& UnregisterEventHookRequest::_internal_event_type() const {
  return event_type_.Get();
}
inline void UnregisterEventHookRequest::_internal_set_event_type(const std::string& value) {
  
  event_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::_internal_mutable_event_type() {
  
  return event_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::release_event_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.UnregisterEventHookRequest.event_type)
  return event_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnregisterEventHookRequest::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  event_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    event_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.UnregisterEventHookRequest.event_type)
}

// string hook_id = 3;
inline void UnregisterEventHookRequest::clear_hook_id() {
  hook_id_.ClearToEmpty();
}
inline const std::string& UnregisterEventHookRequest::hook_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.UnregisterEventHookRequest.hook_id)
  return _internal_hook_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterEventHookRequest::set_hook_id(ArgT0&& arg0, ArgT... args) {
 
 hook_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.UnregisterEventHookRequest.hook_id)
}
inline std::string* UnregisterEventHookRequest::mutable_hook_id() {
  std::string* _s = _internal_mutable_hook_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.UnregisterEventHookRequest.hook_id)
  return _s;
}
inline const std::string& UnregisterEventHookRequest::_internal_hook_id() const {
  return hook_id_.Get();
}
inline void UnregisterEventHookRequest::_internal_set_hook_id(const std::string& value) {
  
  hook_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::_internal_mutable_hook_id() {
  
  return hook_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookRequest::release_hook_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.UnregisterEventHookRequest.hook_id)
  return hook_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnregisterEventHookRequest::set_allocated_hook_id(std::string* hook_id) {
  if (hook_id != nullptr) {
    
  } else {
    
  }
  hook_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hook_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hook_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hook_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.UnregisterEventHookRequest.hook_id)
}

// -------------------------------------------------------------------

// UnregisterEventHookResponse

// bool success = 1;
inline void UnregisterEventHookResponse::clear_success() {
  success_ = false;
}
inline bool UnregisterEventHookResponse::_internal_success() const {
  return success_;
}
inline bool UnregisterEventHookResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.UnregisterEventHookResponse.success)
  return _internal_success();
}
inline void UnregisterEventHookResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void UnregisterEventHookResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.UnregisterEventHookResponse.success)
}

// string error_message = 2;
inline void UnregisterEventHookResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& UnregisterEventHookResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.UnregisterEventHookResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterEventHookResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.UnregisterEventHookResponse.error_message)
}
inline std::string* UnregisterEventHookResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.UnregisterEventHookResponse.error_message)
  return _s;
}
inline const std::string& UnregisterEventHookResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void UnregisterEventHookResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnregisterEventHookResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.UnregisterEventHookResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnregisterEventHookResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.UnregisterEventHookResponse.error_message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ThemeInfo

// string theme_id = 1;
inline void ThemeInfo::clear_theme_id() {
  theme_id_.ClearToEmpty();
}
inline const std::string& ThemeInfo::theme_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.theme_id)
  return _internal_theme_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_theme_id(ArgT0&& arg0, ArgT... args) {
 
 theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.theme_id)
}
inline std::string* ThemeInfo::mutable_theme_id() {
  std::string* _s = _internal_mutable_theme_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.theme_id)
  return _s;
}
inline const std::string& ThemeInfo::_internal_theme_id() const {
  return theme_id_.Get();
}
inline void ThemeInfo::_internal_set_theme_id(const std::string& value) {
  
  theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_theme_id() {
  
  return theme_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_theme_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.theme_id)
  return theme_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_theme_id(std::string* theme_id) {
  if (theme_id != nullptr) {
    
  } else {
    
  }
  theme_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), theme_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (theme_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    theme_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.theme_id)
}

// string name = 2;
inline void ThemeInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ThemeInfo::name() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.name)
}
inline std::string* ThemeInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.name)
  return _s;
}
inline const std::string& ThemeInfo::_internal_name() const {
  return name_.Get();
}
inline void ThemeInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_name() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.name)
}

// string author = 3;
inline void ThemeInfo::clear_author() {
  author_.ClearToEmpty();
}
inline const std::string& ThemeInfo::author() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_author(ArgT0&& arg0, ArgT... args) {
 
 author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.author)
}
inline std::string* ThemeInfo::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.author)
  return _s;
}
inline const std::string& ThemeInfo::_internal_author() const {
  return author_.Get();
}
inline void ThemeInfo::_internal_set_author(const std::string& value) {
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_author() {
  
  return author_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_author() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.author)
  return author_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  author_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (author_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    author_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.author)
}

// string version = 4;
inline void ThemeInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ThemeInfo::version() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.version)
}
inline std::string* ThemeInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.version)
  return _s;
}
inline const std::string& ThemeInfo::_internal_version() const {
  return version_.Get();
}
inline void ThemeInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_version() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.version)
}

// string description = 5;
inline void ThemeInfo::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ThemeInfo::description() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.description)
}
inline std::string* ThemeInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.description)
  return _s;
}
inline const std::string& ThemeInfo::_internal_description() const {
  return description_.Get();
}
inline void ThemeInfo::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_description() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.description)
}

// repeated string variants = 6;
inline int ThemeInfo::_internal_variants_size() const {
  return variants_.size();
}
inline int ThemeInfo::variants_size() const {
  return _internal_variants_size();
}
inline void ThemeInfo::clear_variants() {
  variants_.Clear();
}
inline std::string* ThemeInfo::add_variants() {
  std::string* _s = _internal_add_variants();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.ThemeInfo.variants)
  return _s;
}
inline const std::string& ThemeInfo::_internal_variants(int index) const {
  return variants_.Get(index);
}
inline const std::string& ThemeInfo::variants(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.variants)
  return _internal_variants(index);
}
inline std::string* ThemeInfo::mutable_variants(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.variants)
  return variants_.Mutable(index);
}
inline void ThemeInfo::set_variants(int index, const std::string& value) {
  variants_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::set_variants(int index, std::string&& value) {
  variants_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::set_variants(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  variants_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::set_variants(int index, const char* value, size_t size) {
  variants_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.ThemeInfo.variants)
}
inline std::string* ThemeInfo::_internal_add_variants() {
  return variants_.Add();
}
inline void ThemeInfo::add_variants(const std::string& value) {
  variants_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::add_variants(std::string&& value) {
  variants_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::add_variants(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  variants_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.ThemeInfo.variants)
}
inline void ThemeInfo::add_variants(const char* value, size_t size) {
  variants_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.ThemeInfo.variants)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ThemeInfo::variants() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.ThemeInfo.variants)
  return variants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ThemeInfo::mutable_variants() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.ThemeInfo.variants)
  return &variants_;
}

// bytes preview_image = 7;
inline void ThemeInfo::clear_preview_image() {
  preview_image_.ClearToEmpty();
}
inline const std::string& ThemeInfo::preview_image() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ThemeInfo.preview_image)
  return _internal_preview_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThemeInfo::set_preview_image(ArgT0&& arg0, ArgT... args) {
 
 preview_image_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ThemeInfo.preview_image)
}
inline std::string* ThemeInfo::mutable_preview_image() {
  std::string* _s = _internal_mutable_preview_image();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ThemeInfo.preview_image)
  return _s;
}
inline const std::string& ThemeInfo::_internal_preview_image() const {
  return preview_image_.Get();
}
inline void ThemeInfo::_internal_set_preview_image(const std::string& value) {
  
  preview_image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThemeInfo::_internal_mutable_preview_image() {
  
  return preview_image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThemeInfo::release_preview_image() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ThemeInfo.preview_image)
  return preview_image_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThemeInfo::set_allocated_preview_image(std::string* preview_image) {
  if (preview_image != nullptr) {
    
  } else {
    
  }
  preview_image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), preview_image,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (preview_image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    preview_image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ThemeInfo.preview_image)
}

// map<string, string> properties = 8;
inline int ThemeInfo::_internal_properties_size() const {
  return properties_.size();
}
inline int ThemeInfo::properties_size() const {
  return _internal_properties_size();
}
inline void ThemeInfo::clear_properties() {
  properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ThemeInfo::_internal_properties() const {
  return properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ThemeInfo::properties() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.ThemeInfo.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ThemeInfo::_internal_mutable_properties() {
  return properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ThemeInfo::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.ThemeInfo.properties)
  return _internal_mutable_properties();
}

// -------------------------------------------------------------------

// ApplyThemeRequest

// string theme_id = 1;
inline void ApplyThemeRequest::clear_theme_id() {
  theme_id_.ClearToEmpty();
}
inline const std::string& ApplyThemeRequest::theme_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeRequest.theme_id)
  return _internal_theme_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyThemeRequest::set_theme_id(ArgT0&& arg0, ArgT... args) {
 
 theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeRequest.theme_id)
}
inline std::string* ApplyThemeRequest::mutable_theme_id() {
  std::string* _s = _internal_mutable_theme_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ApplyThemeRequest.theme_id)
  return _s;
}
inline const std::string& ApplyThemeRequest::_internal_theme_id() const {
  return theme_id_.Get();
}
inline void ApplyThemeRequest::_internal_set_theme_id(const std::string& value) {
  
  theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyThemeRequest::_internal_mutable_theme_id() {
  
  return theme_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyThemeRequest::release_theme_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ApplyThemeRequest.theme_id)
  return theme_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyThemeRequest::set_allocated_theme_id(std::string* theme_id) {
  if (theme_id != nullptr) {
    
  } else {
    
  }
  theme_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), theme_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (theme_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    theme_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ApplyThemeRequest.theme_id)
}

// string variant = 2;
inline void ApplyThemeRequest::clear_variant() {
  variant_.ClearToEmpty();
}
inline const std::string& ApplyThemeRequest::variant() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeRequest.variant)
  return _internal_variant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyThemeRequest::set_variant(ArgT0&& arg0, ArgT... args) {
 
 variant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeRequest.variant)
}
inline std::string* ApplyThemeRequest::mutable_variant() {
  std::string* _s = _internal_mutable_variant();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ApplyThemeRequest.variant)
  return _s;
}
inline const std::string& ApplyThemeRequest::_internal_variant() const {
  return variant_.Get();
}
inline void ApplyThemeRequest::_internal_set_variant(const std::string& value) {
  
  variant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyThemeRequest::_internal_mutable_variant() {
  
  return variant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyThemeRequest::release_variant() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ApplyThemeRequest.variant)
  return variant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyThemeRequest::set_allocated_variant(std::string* variant) {
  if (variant != nullptr) {
    
  } else {
    
  }
  variant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variant,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variant_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variant_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ApplyThemeRequest.variant)
}

// bool restart_required = 3;
inline void ApplyThemeRequest::clear_restart_required() {
  restart_required_ = false;
}
inline bool ApplyThemeRequest::_internal_restart_required() const {
  return restart_required_;
}
inline bool ApplyThemeRequest::restart_required() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeRequest.restart_required)
  return _internal_restart_required();
}
inline void ApplyThemeRequest::_internal_set_restart_required(bool value) {
  
  restart_required_ = value;
}
inline void ApplyThemeRequest::set_restart_required(bool value) {
  _internal_set_restart_required(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeRequest.restart_required)
}

// -------------------------------------------------------------------

// ApplyThemeResponse

// bool success = 1;
inline void ApplyThemeResponse::clear_success() {
  success_ = false;
}
inline bool ApplyThemeResponse::_internal_success() const {
  return success_;
}
inline bool ApplyThemeResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeResponse.success)
  return _internal_success();
}
inline void ApplyThemeResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ApplyThemeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeResponse.success)
}

// string error_message = 2;
inline void ApplyThemeResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ApplyThemeResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyThemeResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeResponse.error_message)
}
inline std::string* ApplyThemeResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ApplyThemeResponse.error_message)
  return _s;
}
inline const std::string& ApplyThemeResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void ApplyThemeResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyThemeResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyThemeResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.ApplyThemeResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyThemeResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.ApplyThemeResponse.error_message)
}

// repeated string affected_components = 3;
inline int ApplyThemeResponse::_internal_affected_components_size() const {
  return affected_components_.size();
}
inline int ApplyThemeResponse::affected_components_size() const {
  return _internal_affected_components_size();
}
inline void ApplyThemeResponse::clear_affected_components() {
  affected_components_.Clear();
}
inline std::string* ApplyThemeResponse::add_affected_components() {
  std::string* _s = _internal_add_affected_components();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.ApplyThemeResponse.affected_components)
  return _s;
}
inline const std::string& ApplyThemeResponse::_internal_affected_components(int index) const {
  return affected_components_.Get(index);
}
inline const std::string& ApplyThemeResponse::affected_components(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.ApplyThemeResponse.affected_components)
  return _internal_affected_components(index);
}
inline std::string* ApplyThemeResponse::mutable_affected_components(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.ApplyThemeResponse.affected_components)
  return affected_components_.Mutable(index);
}
inline void ApplyThemeResponse::set_affected_components(int index, const std::string& value) {
  affected_components_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::set_affected_components(int index, std::string&& value) {
  affected_components_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::set_affected_components(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  affected_components_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::set_affected_components(int index, const char* value, size_t size) {
  affected_components_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline std::string* ApplyThemeResponse::_internal_add_affected_components() {
  return affected_components_.Add();
}
inline void ApplyThemeResponse::add_affected_components(const std::string& value) {
  affected_components_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::add_affected_components(std::string&& value) {
  affected_components_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::add_affected_components(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  affected_components_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline void ApplyThemeResponse::add_affected_components(const char* value, size_t size) {
  affected_components_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.ApplyThemeResponse.affected_components)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ApplyThemeResponse::affected_components() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.ApplyThemeResponse.affected_components)
  return affected_components_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ApplyThemeResponse::mutable_affected_components() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.ApplyThemeResponse.affected_components)
  return &affected_components_;
}

// -------------------------------------------------------------------

// GetThemesRequest

// bool include_preview_images = 4;
inline void GetThemesRequest::clear_include_preview_images() {
  include_preview_images_ = false;
}
inline bool GetThemesRequest::_internal_include_preview_images() const {
  return include_preview_images_;
}
inline bool GetThemesRequest::include_preview_images() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetThemesRequest.include_preview_images)
  return _internal_include_preview_images();
}
inline void GetThemesRequest::_internal_set_include_preview_images(bool value) {
  
  include_preview_images_ = value;
}
inline void GetThemesRequest::set_include_preview_images(bool value) {
  _internal_set_include_preview_images(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetThemesRequest.include_preview_images)
}

// string category = 5;
inline void GetThemesRequest::clear_category() {
  category_.ClearToEmpty();
}
inline const std::string& GetThemesRequest::category() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetThemesRequest.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThemesRequest::set_category(ArgT0&& arg0, ArgT... args) {
 
 category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetThemesRequest.category)
}
inline std::string* GetThemesRequest::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetThemesRequest.category)
  return _s;
}
inline const std::string& GetThemesRequest::_internal_category() const {
  return category_.Get();
}
inline void GetThemesRequest::_internal_set_category(const std::string& value) {
  
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetThemesRequest::_internal_mutable_category() {
  
  return category_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetThemesRequest::release_category() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.GetThemesRequest.category)
  return category_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetThemesRequest::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    category_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.GetThemesRequest.category)
}

// -------------------------------------------------------------------

// GetThemesResponse

// repeated .vaelix.plugin.ThemeInfo themes = 1;
inline int GetThemesResponse::_internal_themes_size() const {
  return themes_.size();
}
inline int GetThemesResponse::themes_size() const {
  return _internal_themes_size();
}
inline void GetThemesResponse::clear_themes() {
  themes_.Clear();
}
inline ::vaelix::plugin::ThemeInfo* GetThemesResponse::mutable_themes(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetThemesResponse.themes)
  return themes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::ThemeInfo >*
GetThemesResponse::mutable_themes() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.GetThemesResponse.themes)
  return &themes_;
}
inline const ::vaelix::plugin::ThemeInfo& GetThemesResponse::_internal_themes(int index) const {
  return themes_.Get(index);
}
inline const ::vaelix::plugin::ThemeInfo& GetThemesResponse::themes(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetThemesResponse.themes)
  return _internal_themes(index);
}
inline ::vaelix::plugin::ThemeInfo* GetThemesResponse::_internal_add_themes() {
  return themes_.Add();
}
inline ::vaelix::plugin::ThemeInfo* GetThemesResponse::add_themes() {
  ::vaelix::plugin::ThemeInfo* _add = _internal_add_themes();
  // @@protoc_insertion_point(field_add:vaelix.plugin.GetThemesResponse.themes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::ThemeInfo >&
GetThemesResponse::themes() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.GetThemesResponse.themes)
  return themes_;
}

// bool success = 2;
inline void GetThemesResponse::clear_success() {
  success_ = false;
}
inline bool GetThemesResponse::_internal_success() const {
  return success_;
}
inline bool GetThemesResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetThemesResponse.success)
  return _internal_success();
}
inline void GetThemesResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetThemesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetThemesResponse.success)
}

// string error_message = 3;
inline void GetThemesResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& GetThemesResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetThemesResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThemesResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetThemesResponse.error_message)
}
inline std::string* GetThemesResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetThemesResponse.error_message)
  return _s;
}
inline const std::string& GetThemesResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void GetThemesResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetThemesResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetThemesResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.GetThemesResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetThemesResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.GetThemesResponse.error_message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PluginConfigUpdate

// string plugin_id = 1;
inline void PluginConfigUpdate::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& PluginConfigUpdate::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginConfigUpdate.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginConfigUpdate::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginConfigUpdate.plugin_id)
}
inline std::string* PluginConfigUpdate::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginConfigUpdate.plugin_id)
  return _s;
}
inline const std::string& PluginConfigUpdate::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void PluginConfigUpdate::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginConfigUpdate::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginConfigUpdate::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginConfigUpdate.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginConfigUpdate::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginConfigUpdate.plugin_id)
}

// map<string, string> config = 2;
inline int PluginConfigUpdate::_internal_config_size() const {
  return config_.size();
}
inline int PluginConfigUpdate::config_size() const {
  return _internal_config_size();
}
inline void PluginConfigUpdate::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginConfigUpdate::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PluginConfigUpdate::config() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.PluginConfigUpdate.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginConfigUpdate::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PluginConfigUpdate::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.PluginConfigUpdate.config)
  return _internal_mutable_config();
}

// string updated_by = 3;
inline void PluginConfigUpdate::clear_updated_by() {
  updated_by_.ClearToEmpty();
}
inline const std::string& PluginConfigUpdate::updated_by() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginConfigUpdate.updated_by)
  return _internal_updated_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginConfigUpdate::set_updated_by(ArgT0&& arg0, ArgT... args) {
 
 updated_by_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginConfigUpdate.updated_by)
}
inline std::string* PluginConfigUpdate::mutable_updated_by() {
  std::string* _s = _internal_mutable_updated_by();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginConfigUpdate.updated_by)
  return _s;
}
inline const std::string& PluginConfigUpdate::_internal_updated_by() const {
  return updated_by_.Get();
}
inline void PluginConfigUpdate::_internal_set_updated_by(const std::string& value) {
  
  updated_by_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginConfigUpdate::_internal_mutable_updated_by() {
  
  return updated_by_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginConfigUpdate::release_updated_by() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginConfigUpdate.updated_by)
  return updated_by_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginConfigUpdate::set_allocated_updated_by(std::string* updated_by) {
  if (updated_by != nullptr) {
    
  } else {
    
  }
  updated_by_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updated_by,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updated_by_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updated_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginConfigUpdate.updated_by)
}

// int64 timestamp = 4;
inline void PluginConfigUpdate::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t PluginConfigUpdate::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t PluginConfigUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginConfigUpdate.timestamp)
  return _internal_timestamp();
}
inline void PluginConfigUpdate::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void PluginConfigUpdate::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginConfigUpdate.timestamp)
}

// -------------------------------------------------------------------

// GetPluginConfigRequest

// string plugin_id = 1;
inline void GetPluginConfigRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& GetPluginConfigRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetPluginConfigRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPluginConfigRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetPluginConfigRequest.plugin_id)
}
inline std::string* GetPluginConfigRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetPluginConfigRequest.plugin_id)
  return _s;
}
inline const std::string& GetPluginConfigRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void GetPluginConfigRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPluginConfigRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPluginConfigRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.GetPluginConfigRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPluginConfigRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.GetPluginConfigRequest.plugin_id)
}

// repeated string config_keys = 2;
inline int GetPluginConfigRequest::_internal_config_keys_size() const {
  return config_keys_.size();
}
inline int GetPluginConfigRequest::config_keys_size() const {
  return _internal_config_keys_size();
}
inline void GetPluginConfigRequest::clear_config_keys() {
  config_keys_.Clear();
}
inline std::string* GetPluginConfigRequest::add_config_keys() {
  std::string* _s = _internal_add_config_keys();
  // @@protoc_insertion_point(field_add_mutable:vaelix.plugin.GetPluginConfigRequest.config_keys)
  return _s;
}
inline const std::string& GetPluginConfigRequest::_internal_config_keys(int index) const {
  return config_keys_.Get(index);
}
inline const std::string& GetPluginConfigRequest::config_keys(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetPluginConfigRequest.config_keys)
  return _internal_config_keys(index);
}
inline std::string* GetPluginConfigRequest::mutable_config_keys(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetPluginConfigRequest.config_keys)
  return config_keys_.Mutable(index);
}
inline void GetPluginConfigRequest::set_config_keys(int index, const std::string& value) {
  config_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::set_config_keys(int index, std::string&& value) {
  config_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::set_config_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  config_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::set_config_keys(int index, const char* value, size_t size) {
  config_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline std::string* GetPluginConfigRequest::_internal_add_config_keys() {
  return config_keys_.Add();
}
inline void GetPluginConfigRequest::add_config_keys(const std::string& value) {
  config_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::add_config_keys(std::string&& value) {
  config_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::add_config_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  config_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline void GetPluginConfigRequest::add_config_keys(const char* value, size_t size) {
  config_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vaelix.plugin.GetPluginConfigRequest.config_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetPluginConfigRequest::config_keys() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.GetPluginConfigRequest.config_keys)
  return config_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetPluginConfigRequest::mutable_config_keys() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.GetPluginConfigRequest.config_keys)
  return &config_keys_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetPluginConfigResponse

// map<string, string> config = 1;
inline int GetPluginConfigResponse::_internal_config_size() const {
  return config_.size();
}
inline int GetPluginConfigResponse::config_size() const {
  return _internal_config_size();
}
inline void GetPluginConfigResponse::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetPluginConfigResponse::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetPluginConfigResponse::config() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.GetPluginConfigResponse.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetPluginConfigResponse::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetPluginConfigResponse::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.GetPluginConfigResponse.config)
  return _internal_mutable_config();
}

// bool success = 2;
inline void GetPluginConfigResponse::clear_success() {
  success_ = false;
}
inline bool GetPluginConfigResponse::_internal_success() const {
  return success_;
}
inline bool GetPluginConfigResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetPluginConfigResponse.success)
  return _internal_success();
}
inline void GetPluginConfigResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetPluginConfigResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetPluginConfigResponse.success)
}

// string error_message = 3;
inline void GetPluginConfigResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& GetPluginConfigResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.GetPluginConfigResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPluginConfigResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.GetPluginConfigResponse.error_message)
}
inline std::string* GetPluginConfigResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.GetPluginConfigResponse.error_message)
  return _s;
}
inline const std::string& GetPluginConfigResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void GetPluginConfigResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPluginConfigResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPluginConfigResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.GetPluginConfigResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPluginConfigResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.GetPluginConfigResponse.error_message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetPluginConfigRequest

// string plugin_id = 1;
inline void SetPluginConfigRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& SetPluginConfigRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.SetPluginConfigRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPluginConfigRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.SetPluginConfigRequest.plugin_id)
}
inline std::string* SetPluginConfigRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.SetPluginConfigRequest.plugin_id)
  return _s;
}
inline const std::string& SetPluginConfigRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void SetPluginConfigRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetPluginConfigRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetPluginConfigRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.SetPluginConfigRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetPluginConfigRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.SetPluginConfigRequest.plugin_id)
}

// map<string, string> config = 2;
inline int SetPluginConfigRequest::_internal_config_size() const {
  return config_.size();
}
inline int SetPluginConfigRequest::config_size() const {
  return _internal_config_size();
}
inline void SetPluginConfigRequest::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetPluginConfigRequest::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetPluginConfigRequest::config() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.SetPluginConfigRequest.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetPluginConfigRequest::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetPluginConfigRequest::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.SetPluginConfigRequest.config)
  return _internal_mutable_config();
}

// bool validate = 3;
inline void SetPluginConfigRequest::clear_validate() {
  validate_ = false;
}
inline bool SetPluginConfigRequest::_internal_validate() const {
  return validate_;
}
inline bool SetPluginConfigRequest::validate() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.SetPluginConfigRequest.validate)
  return _internal_validate();
}
inline void SetPluginConfigRequest::_internal_set_validate(bool value) {
  
  validate_ = value;
}
inline void SetPluginConfigRequest::set_validate(bool value) {
  _internal_set_validate(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.SetPluginConfigRequest.validate)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetPluginConfigResponse

// bool success = 1;
inline void SetPluginConfigResponse::clear_success() {
  success_ = false;
}
inline bool SetPluginConfigResponse::_internal_success() const {
  return success_;
}
inline bool SetPluginConfigResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.SetPluginConfigResponse.success)
  return _internal_success();
}
inline void SetPluginConfigResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SetPluginConfigResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.SetPluginConfigResponse.success)
}

// string error_message = 2;
inline void SetPluginConfigResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& SetPluginConfigResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.SetPluginConfigResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPluginConfigResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.SetPluginConfigResponse.error_message)
}
inline std::string* SetPluginConfigResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.SetPluginConfigResponse.error_message)
  return _s;
}
inline const std::string& SetPluginConfigResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void SetPluginConfigResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetPluginConfigResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetPluginConfigResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.SetPluginConfigResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetPluginConfigResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.SetPluginConfigResponse.error_message)
}

// map<string, string> validated_config = 3;
inline int SetPluginConfigResponse::_internal_validated_config_size() const {
  return validated_config_.size();
}
inline int SetPluginConfigResponse::validated_config_size() const {
  return _internal_validated_config_size();
}
inline void SetPluginConfigResponse::clear_validated_config() {
  validated_config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetPluginConfigResponse::_internal_validated_config() const {
  return validated_config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetPluginConfigResponse::validated_config() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.SetPluginConfigResponse.validated_config)
  return _internal_validated_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetPluginConfigResponse::_internal_mutable_validated_config() {
  return validated_config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetPluginConfigResponse::mutable_validated_config() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.SetPluginConfigResponse.validated_config)
  return _internal_mutable_validated_config();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NetworkRequest

// string request_id = 1;
inline void NetworkRequest::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& NetworkRequest::request_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.request_id)
}
inline std::string* NetworkRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkRequest.request_id)
  return _s;
}
inline const std::string& NetworkRequest::_internal_request_id() const {
  return request_id_.Get();
}
inline void NetworkRequest::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkRequest::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkRequest.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkRequest.request_id)
}

// string url = 2;
inline void NetworkRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& NetworkRequest::url() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.url)
}
inline std::string* NetworkRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkRequest.url)
  return _s;
}
inline const std::string& NetworkRequest::_internal_url() const {
  return url_.Get();
}
inline void NetworkRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkRequest::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkRequest::release_url() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkRequest.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkRequest.url)
}

// string method = 3;
inline void NetworkRequest::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& NetworkRequest::method() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.method)
}
inline std::string* NetworkRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkRequest.method)
  return _s;
}
inline const std::string& NetworkRequest::_internal_method() const {
  return method_.Get();
}
inline void NetworkRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkRequest::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkRequest::release_method() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkRequest.method)
}

// map<string, string> headers = 4;
inline int NetworkRequest::_internal_headers_size() const {
  return headers_.size();
}
inline int NetworkRequest::headers_size() const {
  return _internal_headers_size();
}
inline void NetworkRequest::clear_headers() {
  headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NetworkRequest::_internal_headers() const {
  return headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NetworkRequest::headers() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.NetworkRequest.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NetworkRequest::_internal_mutable_headers() {
  return headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NetworkRequest::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.NetworkRequest.headers)
  return _internal_mutable_headers();
}

// bytes body = 5;
inline void NetworkRequest::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& NetworkRequest::body() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkRequest::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.body)
}
inline std::string* NetworkRequest::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkRequest.body)
  return _s;
}
inline const std::string& NetworkRequest::_internal_body() const {
  return body_.Get();
}
inline void NetworkRequest::_internal_set_body(const std::string& value) {
  
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkRequest::_internal_mutable_body() {
  
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkRequest::release_body() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkRequest.body)
  return body_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkRequest::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkRequest.body)
}

// bool allow_redirects = 6;
inline void NetworkRequest::clear_allow_redirects() {
  allow_redirects_ = false;
}
inline bool NetworkRequest::_internal_allow_redirects() const {
  return allow_redirects_;
}
inline bool NetworkRequest::allow_redirects() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.allow_redirects)
  return _internal_allow_redirects();
}
inline void NetworkRequest::_internal_set_allow_redirects(bool value) {
  
  allow_redirects_ = value;
}
inline void NetworkRequest::set_allow_redirects(bool value) {
  _internal_set_allow_redirects(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.allow_redirects)
}

// int32 timeout_ms = 7;
inline void NetworkRequest::clear_timeout_ms() {
  timeout_ms_ = 0;
}
inline int32_t NetworkRequest::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t NetworkRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkRequest.timeout_ms)
  return _internal_timeout_ms();
}
inline void NetworkRequest::_internal_set_timeout_ms(int32_t value) {
  
  timeout_ms_ = value;
}
inline void NetworkRequest::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkRequest.timeout_ms)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NetworkResponse

// string request_id = 1;
inline void NetworkResponse::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& NetworkResponse::request_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.request_id)
}
inline std::string* NetworkResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkResponse.request_id)
  return _s;
}
inline const std::string& NetworkResponse::_internal_request_id() const {
  return request_id_.Get();
}
inline void NetworkResponse::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkResponse::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkResponse.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkResponse.request_id)
}

// int32 status_code = 2;
inline void NetworkResponse::clear_status_code() {
  status_code_ = 0;
}
inline int32_t NetworkResponse::_internal_status_code() const {
  return status_code_;
}
inline int32_t NetworkResponse::status_code() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.status_code)
  return _internal_status_code();
}
inline void NetworkResponse::_internal_set_status_code(int32_t value) {
  
  status_code_ = value;
}
inline void NetworkResponse::set_status_code(int32_t value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.status_code)
}

// map<string, string> headers = 3;
inline int NetworkResponse::_internal_headers_size() const {
  return headers_.size();
}
inline int NetworkResponse::headers_size() const {
  return _internal_headers_size();
}
inline void NetworkResponse::clear_headers() {
  headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NetworkResponse::_internal_headers() const {
  return headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NetworkResponse::headers() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.NetworkResponse.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NetworkResponse::_internal_mutable_headers() {
  return headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NetworkResponse::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.NetworkResponse.headers)
  return _internal_mutable_headers();
}

// bytes body = 4;
inline void NetworkResponse::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& NetworkResponse::body() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkResponse::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.body)
}
inline std::string* NetworkResponse::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkResponse.body)
  return _s;
}
inline const std::string& NetworkResponse::_internal_body() const {
  return body_.Get();
}
inline void NetworkResponse::_internal_set_body(const std::string& value) {
  
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkResponse::_internal_mutable_body() {
  
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkResponse::release_body() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkResponse.body)
  return body_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkResponse::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkResponse.body)
}

// int64 response_time_ms = 5;
inline void NetworkResponse::clear_response_time_ms() {
  response_time_ms_ = int64_t{0};
}
inline int64_t NetworkResponse::_internal_response_time_ms() const {
  return response_time_ms_;
}
inline int64_t NetworkResponse::response_time_ms() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.response_time_ms)
  return _internal_response_time_ms();
}
inline void NetworkResponse::_internal_set_response_time_ms(int64_t value) {
  
  response_time_ms_ = value;
}
inline void NetworkResponse::set_response_time_ms(int64_t value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.response_time_ms)
}

// bool success = 6;
inline void NetworkResponse::clear_success() {
  success_ = false;
}
inline bool NetworkResponse::_internal_success() const {
  return success_;
}
inline bool NetworkResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.success)
  return _internal_success();
}
inline void NetworkResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void NetworkResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.success)
}

// string error_message = 7;
inline void NetworkResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& NetworkResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.NetworkResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.NetworkResponse.error_message)
}
inline std::string* NetworkResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.NetworkResponse.error_message)
  return _s;
}
inline const std::string& NetworkResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void NetworkResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.NetworkResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.NetworkResponse.error_message)
}

// -------------------------------------------------------------------

// MakeNetworkRequestRequest

// string plugin_id = 1;
inline void MakeNetworkRequestRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& MakeNetworkRequestRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.MakeNetworkRequestRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeNetworkRequestRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.MakeNetworkRequestRequest.plugin_id)
}
inline std::string* MakeNetworkRequestRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.MakeNetworkRequestRequest.plugin_id)
  return _s;
}
inline const std::string& MakeNetworkRequestRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void MakeNetworkRequestRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.MakeNetworkRequestRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeNetworkRequestRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.MakeNetworkRequestRequest.plugin_id)
}

// .vaelix.plugin.NetworkRequest request = 2;
inline bool MakeNetworkRequestRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool MakeNetworkRequestRequest::has_request() const {
  return _internal_has_request();
}
inline void MakeNetworkRequestRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::vaelix::plugin::NetworkRequest& MakeNetworkRequestRequest::_internal_request() const {
  const ::vaelix::plugin::NetworkRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::plugin::NetworkRequest&>(
      ::vaelix::plugin::_NetworkRequest_default_instance_);
}
inline const ::vaelix::plugin::NetworkRequest& MakeNetworkRequestRequest::request() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.MakeNetworkRequestRequest.request)
  return _internal_request();
}
inline void MakeNetworkRequestRequest::unsafe_arena_set_allocated_request(
    ::vaelix::plugin::NetworkRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.plugin.MakeNetworkRequestRequest.request)
}
inline ::vaelix::plugin::NetworkRequest* MakeNetworkRequestRequest::release_request() {
  
  ::vaelix::plugin::NetworkRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::plugin::NetworkRequest* MakeNetworkRequestRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.MakeNetworkRequestRequest.request)
  
  ::vaelix::plugin::NetworkRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::vaelix::plugin::NetworkRequest* MakeNetworkRequestRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::plugin::NetworkRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::vaelix::plugin::NetworkRequest* MakeNetworkRequestRequest::mutable_request() {
  ::vaelix::plugin::NetworkRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.MakeNetworkRequestRequest.request)
  return _msg;
}
inline void MakeNetworkRequestRequest::set_allocated_request(::vaelix::plugin::NetworkRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::plugin::NetworkRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.MakeNetworkRequestRequest.request)
}

// -------------------------------------------------------------------

// MakeNetworkRequestResponse

// string request_id = 1;
inline void MakeNetworkRequestResponse::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& MakeNetworkRequestResponse::request_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.MakeNetworkRequestResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeNetworkRequestResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.MakeNetworkRequestResponse.request_id)
}
inline std::string* MakeNetworkRequestResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.MakeNetworkRequestResponse.request_id)
  return _s;
}
inline const std::string& MakeNetworkRequestResponse::_internal_request_id() const {
  return request_id_.Get();
}
inline void MakeNetworkRequestResponse::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestResponse::_internal_mutable_request_id() {
  
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.MakeNetworkRequestResponse.request_id)
  return request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeNetworkRequestResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.MakeNetworkRequestResponse.request_id)
}

// bool success = 2;
inline void MakeNetworkRequestResponse::clear_success() {
  success_ = false;
}
inline bool MakeNetworkRequestResponse::_internal_success() const {
  return success_;
}
inline bool MakeNetworkRequestResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.MakeNetworkRequestResponse.success)
  return _internal_success();
}
inline void MakeNetworkRequestResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void MakeNetworkRequestResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.MakeNetworkRequestResponse.success)
}

// string error_message = 3;
inline void MakeNetworkRequestResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& MakeNetworkRequestResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.MakeNetworkRequestResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeNetworkRequestResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.MakeNetworkRequestResponse.error_message)
}
inline std::string* MakeNetworkRequestResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.MakeNetworkRequestResponse.error_message)
  return _s;
}
inline const std::string& MakeNetworkRequestResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void MakeNetworkRequestResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MakeNetworkRequestResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.MakeNetworkRequestResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MakeNetworkRequestResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.MakeNetworkRequestResponse.error_message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WidgetCreateRequest

// string plugin_id = 1;
inline void WidgetCreateRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& WidgetCreateRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetCreateRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateRequest.plugin_id)
}
inline std::string* WidgetCreateRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetCreateRequest.plugin_id)
  return _s;
}
inline const std::string& WidgetCreateRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void WidgetCreateRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetCreateRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetCreateRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetCreateRequest.plugin_id)
}

// string widget_type = 2;
inline void WidgetCreateRequest::clear_widget_type() {
  widget_type_.ClearToEmpty();
}
inline const std::string& WidgetCreateRequest::widget_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateRequest.widget_type)
  return _internal_widget_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetCreateRequest::set_widget_type(ArgT0&& arg0, ArgT... args) {
 
 widget_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateRequest.widget_type)
}
inline std::string* WidgetCreateRequest::mutable_widget_type() {
  std::string* _s = _internal_mutable_widget_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetCreateRequest.widget_type)
  return _s;
}
inline const std::string& WidgetCreateRequest::_internal_widget_type() const {
  return widget_type_.Get();
}
inline void WidgetCreateRequest::_internal_set_widget_type(const std::string& value) {
  
  widget_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::_internal_mutable_widget_type() {
  
  return widget_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::release_widget_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetCreateRequest.widget_type)
  return widget_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetCreateRequest::set_allocated_widget_type(std::string* widget_type) {
  if (widget_type != nullptr) {
    
  } else {
    
  }
  widget_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), widget_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (widget_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    widget_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetCreateRequest.widget_type)
}

// string widget_id = 3;
inline void WidgetCreateRequest::clear_widget_id() {
  widget_id_.ClearToEmpty();
}
inline const std::string& WidgetCreateRequest::widget_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateRequest.widget_id)
  return _internal_widget_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetCreateRequest::set_widget_id(ArgT0&& arg0, ArgT... args) {
 
 widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateRequest.widget_id)
}
inline std::string* WidgetCreateRequest::mutable_widget_id() {
  std::string* _s = _internal_mutable_widget_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetCreateRequest.widget_id)
  return _s;
}
inline const std::string& WidgetCreateRequest::_internal_widget_id() const {
  return widget_id_.Get();
}
inline void WidgetCreateRequest::_internal_set_widget_id(const std::string& value) {
  
  widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::_internal_mutable_widget_id() {
  
  return widget_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetCreateRequest::release_widget_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetCreateRequest.widget_id)
  return widget_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetCreateRequest::set_allocated_widget_id(std::string* widget_id) {
  if (widget_id != nullptr) {
    
  } else {
    
  }
  widget_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), widget_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (widget_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    widget_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetCreateRequest.widget_id)
}

// int32 window_id = 4;
inline void WidgetCreateRequest::clear_window_id() {
  window_id_ = 0;
}
inline int32_t WidgetCreateRequest::_internal_window_id() const {
  return window_id_;
}
inline int32_t WidgetCreateRequest::window_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateRequest.window_id)
  return _internal_window_id();
}
inline void WidgetCreateRequest::_internal_set_window_id(int32_t value) {
  
  window_id_ = value;
}
inline void WidgetCreateRequest::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateRequest.window_id)
}

// int32 tab_id = 5;
inline void WidgetCreateRequest::clear_tab_id() {
  tab_id_ = 0;
}
inline int32_t WidgetCreateRequest::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t WidgetCreateRequest::tab_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateRequest.tab_id)
  return _internal_tab_id();
}
inline void WidgetCreateRequest::_internal_set_tab_id(int32_t value) {
  
  tab_id_ = value;
}
inline void WidgetCreateRequest::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateRequest.tab_id)
}

// map<string, string> properties = 6;
inline int WidgetCreateRequest::_internal_properties_size() const {
  return properties_.size();
}
inline int WidgetCreateRequest::properties_size() const {
  return _internal_properties_size();
}
inline void WidgetCreateRequest::clear_properties() {
  properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetCreateRequest::_internal_properties() const {
  return properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetCreateRequest::properties() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.WidgetCreateRequest.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetCreateRequest::_internal_mutable_properties() {
  return properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetCreateRequest::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.WidgetCreateRequest.properties)
  return _internal_mutable_properties();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WidgetCreateResponse

// string widget_id = 7;
inline void WidgetCreateResponse::clear_widget_id() {
  widget_id_.ClearToEmpty();
}
inline const std::string& WidgetCreateResponse::widget_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateResponse.widget_id)
  return _internal_widget_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetCreateResponse::set_widget_id(ArgT0&& arg0, ArgT... args) {
 
 widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateResponse.widget_id)
}
inline std::string* WidgetCreateResponse::mutable_widget_id() {
  std::string* _s = _internal_mutable_widget_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetCreateResponse.widget_id)
  return _s;
}
inline const std::string& WidgetCreateResponse::_internal_widget_id() const {
  return widget_id_.Get();
}
inline void WidgetCreateResponse::_internal_set_widget_id(const std::string& value) {
  
  widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetCreateResponse::_internal_mutable_widget_id() {
  
  return widget_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetCreateResponse::release_widget_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetCreateResponse.widget_id)
  return widget_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetCreateResponse::set_allocated_widget_id(std::string* widget_id) {
  if (widget_id != nullptr) {
    
  } else {
    
  }
  widget_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), widget_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (widget_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    widget_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetCreateResponse.widget_id)
}

// bool success = 8;
inline void WidgetCreateResponse::clear_success() {
  success_ = false;
}
inline bool WidgetCreateResponse::_internal_success() const {
  return success_;
}
inline bool WidgetCreateResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateResponse.success)
  return _internal_success();
}
inline void WidgetCreateResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void WidgetCreateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateResponse.success)
}

// string error_message = 9;
inline void WidgetCreateResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& WidgetCreateResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetCreateResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetCreateResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetCreateResponse.error_message)
}
inline std::string* WidgetCreateResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetCreateResponse.error_message)
  return _s;
}
inline const std::string& WidgetCreateResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void WidgetCreateResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetCreateResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetCreateResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetCreateResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetCreateResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetCreateResponse.error_message)
}

// map<string, string> widget_data = 10;
inline int WidgetCreateResponse::_internal_widget_data_size() const {
  return widget_data_.size();
}
inline int WidgetCreateResponse::widget_data_size() const {
  return _internal_widget_data_size();
}
inline void WidgetCreateResponse::clear_widget_data() {
  widget_data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetCreateResponse::_internal_widget_data() const {
  return widget_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetCreateResponse::widget_data() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.WidgetCreateResponse.widget_data)
  return _internal_widget_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetCreateResponse::_internal_mutable_widget_data() {
  return widget_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetCreateResponse::mutable_widget_data() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.WidgetCreateResponse.widget_data)
  return _internal_mutable_widget_data();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WidgetModifyRequest

// string plugin_id = 1;
inline void WidgetModifyRequest::clear_plugin_id() {
  plugin_id_.ClearToEmpty();
}
inline const std::string& WidgetModifyRequest::plugin_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetModifyRequest.plugin_id)
  return _internal_plugin_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetModifyRequest::set_plugin_id(ArgT0&& arg0, ArgT... args) {
 
 plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetModifyRequest.plugin_id)
}
inline std::string* WidgetModifyRequest::mutable_plugin_id() {
  std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetModifyRequest.plugin_id)
  return _s;
}
inline const std::string& WidgetModifyRequest::_internal_plugin_id() const {
  return plugin_id_.Get();
}
inline void WidgetModifyRequest::_internal_set_plugin_id(const std::string& value) {
  
  plugin_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetModifyRequest::_internal_mutable_plugin_id() {
  
  return plugin_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetModifyRequest::release_plugin_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetModifyRequest.plugin_id)
  return plugin_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetModifyRequest::set_allocated_plugin_id(std::string* plugin_id) {
  if (plugin_id != nullptr) {
    
  } else {
    
  }
  plugin_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plugin_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plugin_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetModifyRequest.plugin_id)
}

// string widget_id = 2;
inline void WidgetModifyRequest::clear_widget_id() {
  widget_id_.ClearToEmpty();
}
inline const std::string& WidgetModifyRequest::widget_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetModifyRequest.widget_id)
  return _internal_widget_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetModifyRequest::set_widget_id(ArgT0&& arg0, ArgT... args) {
 
 widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetModifyRequest.widget_id)
}
inline std::string* WidgetModifyRequest::mutable_widget_id() {
  std::string* _s = _internal_mutable_widget_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetModifyRequest.widget_id)
  return _s;
}
inline const std::string& WidgetModifyRequest::_internal_widget_id() const {
  return widget_id_.Get();
}
inline void WidgetModifyRequest::_internal_set_widget_id(const std::string& value) {
  
  widget_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetModifyRequest::_internal_mutable_widget_id() {
  
  return widget_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetModifyRequest::release_widget_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetModifyRequest.widget_id)
  return widget_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetModifyRequest::set_allocated_widget_id(std::string* widget_id) {
  if (widget_id != nullptr) {
    
  } else {
    
  }
  widget_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), widget_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (widget_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    widget_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetModifyRequest.widget_id)
}

// map<string, string> properties = 3;
inline int WidgetModifyRequest::_internal_properties_size() const {
  return properties_.size();
}
inline int WidgetModifyRequest::properties_size() const {
  return _internal_properties_size();
}
inline void WidgetModifyRequest::clear_properties() {
  properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetModifyRequest::_internal_properties() const {
  return properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetModifyRequest::properties() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.WidgetModifyRequest.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetModifyRequest::_internal_mutable_properties() {
  return properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetModifyRequest::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.WidgetModifyRequest.properties)
  return _internal_mutable_properties();
}

// bool partial_update = 4;
inline void WidgetModifyRequest::clear_partial_update() {
  partial_update_ = false;
}
inline bool WidgetModifyRequest::_internal_partial_update() const {
  return partial_update_;
}
inline bool WidgetModifyRequest::partial_update() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetModifyRequest.partial_update)
  return _internal_partial_update();
}
inline void WidgetModifyRequest::_internal_set_partial_update(bool value) {
  
  partial_update_ = value;
}
inline void WidgetModifyRequest::set_partial_update(bool value) {
  _internal_set_partial_update(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetModifyRequest.partial_update)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WidgetModifyResponse

// bool success = 1;
inline void WidgetModifyResponse::clear_success() {
  success_ = false;
}
inline bool WidgetModifyResponse::_internal_success() const {
  return success_;
}
inline bool WidgetModifyResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetModifyResponse.success)
  return _internal_success();
}
inline void WidgetModifyResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void WidgetModifyResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetModifyResponse.success)
}

// string error_message = 2;
inline void WidgetModifyResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& WidgetModifyResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.WidgetModifyResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WidgetModifyResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.WidgetModifyResponse.error_message)
}
inline std::string* WidgetModifyResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.WidgetModifyResponse.error_message)
  return _s;
}
inline const std::string& WidgetModifyResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void WidgetModifyResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WidgetModifyResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WidgetModifyResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.WidgetModifyResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WidgetModifyResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.WidgetModifyResponse.error_message)
}

// map<string, string> updated_properties = 3;
inline int WidgetModifyResponse::_internal_updated_properties_size() const {
  return updated_properties_.size();
}
inline int WidgetModifyResponse::updated_properties_size() const {
  return _internal_updated_properties_size();
}
inline void WidgetModifyResponse::clear_updated_properties() {
  updated_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetModifyResponse::_internal_updated_properties() const {
  return updated_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WidgetModifyResponse::updated_properties() const {
  // @@protoc_insertion_point(field_map:vaelix.plugin.WidgetModifyResponse.updated_properties)
  return _internal_updated_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetModifyResponse::_internal_mutable_updated_properties() {
  return updated_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WidgetModifyResponse::mutable_updated_properties() {
  // @@protoc_insertion_point(field_mutable_map:vaelix.plugin.WidgetModifyResponse.updated_properties)
  return _internal_mutable_updated_properties();
}

// -------------------------------------------------------------------

// PluginListRequest

// bool include_disabled = 1;
inline void PluginListRequest::clear_include_disabled() {
  include_disabled_ = false;
}
inline bool PluginListRequest::_internal_include_disabled() const {
  return include_disabled_;
}
inline bool PluginListRequest::include_disabled() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginListRequest.include_disabled)
  return _internal_include_disabled();
}
inline void PluginListRequest::_internal_set_include_disabled(bool value) {
  
  include_disabled_ = value;
}
inline void PluginListRequest::set_include_disabled(bool value) {
  _internal_set_include_disabled(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginListRequest.include_disabled)
}

// string filter_type = 2;
inline void PluginListRequest::clear_filter_type() {
  filter_type_.ClearToEmpty();
}
inline const std::string& PluginListRequest::filter_type() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginListRequest.filter_type)
  return _internal_filter_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginListRequest::set_filter_type(ArgT0&& arg0, ArgT... args) {
 
 filter_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginListRequest.filter_type)
}
inline std::string* PluginListRequest::mutable_filter_type() {
  std::string* _s = _internal_mutable_filter_type();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginListRequest.filter_type)
  return _s;
}
inline const std::string& PluginListRequest::_internal_filter_type() const {
  return filter_type_.Get();
}
inline void PluginListRequest::_internal_set_filter_type(const std::string& value) {
  
  filter_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginListRequest::_internal_mutable_filter_type() {
  
  return filter_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginListRequest::release_filter_type() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginListRequest.filter_type)
  return filter_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginListRequest::set_allocated_filter_type(std::string* filter_type) {
  if (filter_type != nullptr) {
    
  } else {
    
  }
  filter_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filter_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginListRequest.filter_type)
}

// -------------------------------------------------------------------

// PluginListResponse

// repeated .vaelix.plugin.PluginInfo plugins = 1;
inline int PluginListResponse::_internal_plugins_size() const {
  return plugins_.size();
}
inline int PluginListResponse::plugins_size() const {
  return _internal_plugins_size();
}
inline void PluginListResponse::clear_plugins() {
  plugins_.Clear();
}
inline ::vaelix::plugin::PluginInfo* PluginListResponse::mutable_plugins(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginListResponse.plugins)
  return plugins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginInfo >*
PluginListResponse::mutable_plugins() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginListResponse.plugins)
  return &plugins_;
}
inline const ::vaelix::plugin::PluginInfo& PluginListResponse::_internal_plugins(int index) const {
  return plugins_.Get(index);
}
inline const ::vaelix::plugin::PluginInfo& PluginListResponse::plugins(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginListResponse.plugins)
  return _internal_plugins(index);
}
inline ::vaelix::plugin::PluginInfo* PluginListResponse::_internal_add_plugins() {
  return plugins_.Add();
}
inline ::vaelix::plugin::PluginInfo* PluginListResponse::add_plugins() {
  ::vaelix::plugin::PluginInfo* _add = _internal_add_plugins();
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginListResponse.plugins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginInfo >&
PluginListResponse::plugins() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginListResponse.plugins)
  return plugins_;
}

// bool success = 2;
inline void PluginListResponse::clear_success() {
  success_ = false;
}
inline bool PluginListResponse::_internal_success() const {
  return success_;
}
inline bool PluginListResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginListResponse.success)
  return _internal_success();
}
inline void PluginListResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PluginListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginListResponse.success)
}

// string error_message = 3;
inline void PluginListResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& PluginListResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginListResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginListResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginListResponse.error_message)
}
inline std::string* PluginListResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginListResponse.error_message)
  return _s;
}
inline const std::string& PluginListResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void PluginListResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginListResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginListResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginListResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginListResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginListResponse.error_message)
}

// -------------------------------------------------------------------

// PluginEventHooksResponse

// repeated .vaelix.plugin.PluginEventHook hooks = 1;
inline int PluginEventHooksResponse::_internal_hooks_size() const {
  return hooks_.size();
}
inline int PluginEventHooksResponse::hooks_size() const {
  return _internal_hooks_size();
}
inline void PluginEventHooksResponse::clear_hooks() {
  hooks_.Clear();
}
inline ::vaelix::plugin::PluginEventHook* PluginEventHooksResponse::mutable_hooks(int index) {
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEventHooksResponse.hooks)
  return hooks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginEventHook >*
PluginEventHooksResponse::mutable_hooks() {
  // @@protoc_insertion_point(field_mutable_list:vaelix.plugin.PluginEventHooksResponse.hooks)
  return &hooks_;
}
inline const ::vaelix::plugin::PluginEventHook& PluginEventHooksResponse::_internal_hooks(int index) const {
  return hooks_.Get(index);
}
inline const ::vaelix::plugin::PluginEventHook& PluginEventHooksResponse::hooks(int index) const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHooksResponse.hooks)
  return _internal_hooks(index);
}
inline ::vaelix::plugin::PluginEventHook* PluginEventHooksResponse::_internal_add_hooks() {
  return hooks_.Add();
}
inline ::vaelix::plugin::PluginEventHook* PluginEventHooksResponse::add_hooks() {
  ::vaelix::plugin::PluginEventHook* _add = _internal_add_hooks();
  // @@protoc_insertion_point(field_add:vaelix.plugin.PluginEventHooksResponse.hooks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vaelix::plugin::PluginEventHook >&
PluginEventHooksResponse::hooks() const {
  // @@protoc_insertion_point(field_list:vaelix.plugin.PluginEventHooksResponse.hooks)
  return hooks_;
}

// bool success = 2;
inline void PluginEventHooksResponse::clear_success() {
  success_ = false;
}
inline bool PluginEventHooksResponse::_internal_success() const {
  return success_;
}
inline bool PluginEventHooksResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHooksResponse.success)
  return _internal_success();
}
inline void PluginEventHooksResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PluginEventHooksResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHooksResponse.success)
}

// string error_message = 3;
inline void PluginEventHooksResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& PluginEventHooksResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.PluginEventHooksResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginEventHooksResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.PluginEventHooksResponse.error_message)
}
inline std::string* PluginEventHooksResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.PluginEventHooksResponse.error_message)
  return _s;
}
inline const std::string& PluginEventHooksResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void PluginEventHooksResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PluginEventHooksResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PluginEventHooksResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.PluginEventHooksResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PluginEventHooksResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.PluginEventHooksResponse.error_message)
}

// -------------------------------------------------------------------

// InstallThemeRequest

// string theme_path = 1;
inline void InstallThemeRequest::clear_theme_path() {
  theme_path_.ClearToEmpty();
}
inline const std::string& InstallThemeRequest::theme_path() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeRequest.theme_path)
  return _internal_theme_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallThemeRequest::set_theme_path(ArgT0&& arg0, ArgT... args) {
 
 theme_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.InstallThemeRequest.theme_path)
}
inline std::string* InstallThemeRequest::mutable_theme_path() {
  std::string* _s = _internal_mutable_theme_path();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.InstallThemeRequest.theme_path)
  return _s;
}
inline const std::string& InstallThemeRequest::_internal_theme_path() const {
  return theme_path_.Get();
}
inline void InstallThemeRequest::_internal_set_theme_path(const std::string& value) {
  
  theme_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstallThemeRequest::_internal_mutable_theme_path() {
  
  return theme_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstallThemeRequest::release_theme_path() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.InstallThemeRequest.theme_path)
  return theme_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstallThemeRequest::set_allocated_theme_path(std::string* theme_path) {
  if (theme_path != nullptr) {
    
  } else {
    
  }
  theme_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), theme_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (theme_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    theme_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.InstallThemeRequest.theme_path)
}

// string theme_id = 2;
inline void InstallThemeRequest::clear_theme_id() {
  theme_id_.ClearToEmpty();
}
inline const std::string& InstallThemeRequest::theme_id() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeRequest.theme_id)
  return _internal_theme_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallThemeRequest::set_theme_id(ArgT0&& arg0, ArgT... args) {
 
 theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.InstallThemeRequest.theme_id)
}
inline std::string* InstallThemeRequest::mutable_theme_id() {
  std::string* _s = _internal_mutable_theme_id();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.InstallThemeRequest.theme_id)
  return _s;
}
inline const std::string& InstallThemeRequest::_internal_theme_id() const {
  return theme_id_.Get();
}
inline void InstallThemeRequest::_internal_set_theme_id(const std::string& value) {
  
  theme_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstallThemeRequest::_internal_mutable_theme_id() {
  
  return theme_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstallThemeRequest::release_theme_id() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.InstallThemeRequest.theme_id)
  return theme_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstallThemeRequest::set_allocated_theme_id(std::string* theme_id) {
  if (theme_id != nullptr) {
    
  } else {
    
  }
  theme_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), theme_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (theme_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    theme_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.InstallThemeRequest.theme_id)
}

// bool make_default = 3;
inline void InstallThemeRequest::clear_make_default() {
  make_default_ = false;
}
inline bool InstallThemeRequest::_internal_make_default() const {
  return make_default_;
}
inline bool InstallThemeRequest::make_default() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeRequest.make_default)
  return _internal_make_default();
}
inline void InstallThemeRequest::_internal_set_make_default(bool value) {
  
  make_default_ = value;
}
inline void InstallThemeRequest::set_make_default(bool value) {
  _internal_set_make_default(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.InstallThemeRequest.make_default)
}

// -------------------------------------------------------------------

// InstallThemeResponse

// bool success = 1;
inline void InstallThemeResponse::clear_success() {
  success_ = false;
}
inline bool InstallThemeResponse::_internal_success() const {
  return success_;
}
inline bool InstallThemeResponse::success() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeResponse.success)
  return _internal_success();
}
inline void InstallThemeResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void InstallThemeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:vaelix.plugin.InstallThemeResponse.success)
}

// string error_message = 2;
inline void InstallThemeResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& InstallThemeResponse::error_message() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallThemeResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vaelix.plugin.InstallThemeResponse.error_message)
}
inline std::string* InstallThemeResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.InstallThemeResponse.error_message)
  return _s;
}
inline const std::string& InstallThemeResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void InstallThemeResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstallThemeResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstallThemeResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.InstallThemeResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstallThemeResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.InstallThemeResponse.error_message)
}

// .vaelix.plugin.ThemeInfo theme_info = 3;
inline bool InstallThemeResponse::_internal_has_theme_info() const {
  return this != internal_default_instance() && theme_info_ != nullptr;
}
inline bool InstallThemeResponse::has_theme_info() const {
  return _internal_has_theme_info();
}
inline void InstallThemeResponse::clear_theme_info() {
  if (GetArenaForAllocation() == nullptr && theme_info_ != nullptr) {
    delete theme_info_;
  }
  theme_info_ = nullptr;
}
inline const ::vaelix::plugin::ThemeInfo& InstallThemeResponse::_internal_theme_info() const {
  const ::vaelix::plugin::ThemeInfo* p = theme_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::vaelix::plugin::ThemeInfo&>(
      ::vaelix::plugin::_ThemeInfo_default_instance_);
}
inline const ::vaelix::plugin::ThemeInfo& InstallThemeResponse::theme_info() const {
  // @@protoc_insertion_point(field_get:vaelix.plugin.InstallThemeResponse.theme_info)
  return _internal_theme_info();
}
inline void InstallThemeResponse::unsafe_arena_set_allocated_theme_info(
    ::vaelix::plugin::ThemeInfo* theme_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme_info_);
  }
  theme_info_ = theme_info;
  if (theme_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vaelix.plugin.InstallThemeResponse.theme_info)
}
inline ::vaelix::plugin::ThemeInfo* InstallThemeResponse::release_theme_info() {
  
  ::vaelix::plugin::ThemeInfo* temp = theme_info_;
  theme_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vaelix::plugin::ThemeInfo* InstallThemeResponse::unsafe_arena_release_theme_info() {
  // @@protoc_insertion_point(field_release:vaelix.plugin.InstallThemeResponse.theme_info)
  
  ::vaelix::plugin::ThemeInfo* temp = theme_info_;
  theme_info_ = nullptr;
  return temp;
}
inline ::vaelix::plugin::ThemeInfo* InstallThemeResponse::_internal_mutable_theme_info() {
  
  if (theme_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vaelix::plugin::ThemeInfo>(GetArenaForAllocation());
    theme_info_ = p;
  }
  return theme_info_;
}
inline ::vaelix::plugin::ThemeInfo* InstallThemeResponse::mutable_theme_info() {
  ::vaelix::plugin::ThemeInfo* _msg = _internal_mutable_theme_info();
  // @@protoc_insertion_point(field_mutable:vaelix.plugin.InstallThemeResponse.theme_info)
  return _msg;
}
inline void InstallThemeResponse::set_allocated_theme_info(::vaelix::plugin::ThemeInfo* theme_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete theme_info_;
  }
  if (theme_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vaelix::plugin::ThemeInfo>::GetOwningArena(theme_info);
    if (message_arena != submessage_arena) {
      theme_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme_info, submessage_arena);
    }
    
  } else {
    
  }
  theme_info_ = theme_info;
  // @@protoc_insertion_point(field_set_allocated:vaelix.plugin.InstallThemeResponse.theme_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace plugin
}  // namespace vaelix

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_plugin_5fapi_2eproto
